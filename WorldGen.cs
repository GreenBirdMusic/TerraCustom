using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Biomes;
using Terraria.GameContent.Events;
using Terraria.GameContent.Generation;
using Terraria.GameContent.Tile_Entities;
using Terraria.Graphics.Capture;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.ObjectData;
using Terraria.Utilities;
using Terraria.World.Generation;
using Terraria.ModLoader;
using Terraria.ModLoader.IO;
#if CLIENT
using Terraria.Map;



#endif

namespace Terraria
{
	public class WorldGen
	{
		public class Hooks
		{
			public static event Action OnWorldLoad;

			public static void Initialize() {
				Player.Hooks.OnEnterWorld += delegate (Player player) {
					if (player.whoAmI == Main.myPlayer) {
						WorldLoaded();
						Main.FixUIScale();
					}
				};
			}

			public static void WorldLoaded() {
				if (Hooks.OnWorldLoad != null)
					Hooks.OnWorldLoad();
			}

			public static void ClearWorld() {
				PressurePlateHelper.Reset();
				TownManager.Clear();
				NPC.ResetKillCount();
			}
		}

		public class Spread
		{
			public static void Wall(int x, int y, int wallType) {
				if (!InWorld(x, y))
					return;

				byte wall = (byte)wallType;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0) {
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0) {
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1)) {
							list.Remove(item);
							continue;
						}

						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0) {
							if (tile.active() && tile.wall == 0)
								tile.wall = wall;

							continue;
						}

						tile.wall = wall;
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
							list2.Add(item2);
					}
				}
			}

			public static void Wall2(int x, int y, int wallType) {
				if (!InWorld(x, y))
					return;

				byte b = (byte)wallType;
				int num = 0;
				int maxWallOut = maxWallOut2;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0) {
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0) {
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1)) {
							list.Remove(item);
							continue;
						}

						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (!SolidTile(item.X, item.Y) && tile.wall != b && tile.wall != 4 && tile.wall != 40 && tile.wall != 3) {
							if (b == 63 && tile.wall == 0) {
								list.Remove(item);
								continue;
							}

							num++;
							if (num >= maxWallOut) {
								list.Remove(item);
								continue;
							}

							tile.wall = b;
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							if (b == 63) {
								item2 = new Point(item.X - 1, item.Y - 1);
								if (!hashSet.Contains(item2))
									list2.Add(item2);

								item2 = new Point(item.X + 1, item.Y - 1);
								if (!hashSet.Contains(item2))
									list2.Add(item2);

								item2 = new Point(item.X - 1, item.Y + 1);
								if (!hashSet.Contains(item2))
									list2.Add(item2);

								item2 = new Point(item.X + 1, item.Y + 1);
								if (!hashSet.Contains(item2))
									list2.Add(item2);

								item2 = new Point(item.X - 2, item.Y);
								if (!hashSet.Contains(item2))
									list2.Add(item2);

								item2 = new Point(item.X + 2, item.Y);
								if (!hashSet.Contains(item2))
									list2.Add(item2);
							}
						}
						else if (tile.active() && tile.wall != b && tile.wall != 4 && tile.wall != 40 && tile.wall != 3) {
							tile.wall = b;
						}
					}
				}
			}

			public static void Moss(int x, int y) {
				if (!InWorld(x, y))
					return;

				byte mossWall = WorldGen.mossWall;
				ushort mossTile = WorldGen.mossTile;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0) {
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0) {
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1)) {
							list.Remove(item);
							continue;
						}

						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0) {
							if (tile.active()) {
								if (tile.wall == 0)
									tile.wall = mossWall;

								if (tile.type == 1)
									tile.type = mossTile;
							}

							continue;
						}

						tile.wall = mossWall;
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
							list2.Add(item2);
					}
				}
			}

			public static void Gem(int x, int y) {
				if (!InWorld(x, y))
					return;

				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0) {
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0) {
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1)) {
							list.Remove(item);
							continue;
						}

						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0) {
							if (tile.active()) {
								if (Gemmable(tile.type))
									tile.type = randGemTile();

								Tile tile2 = Main.tile[item.X - 1, item.Y];
								if (Gemmable(tile2.type))
									tile2.type = randGemTile();

								tile2 = Main.tile[item.X + 1, item.Y];
								if (Gemmable(tile2.type))
									tile2.type = randGemTile();

								tile2 = Main.tile[item.X, item.Y - 1];
								if (Gemmable(tile2.type))
									tile2.type = randGemTile();

								tile2 = Main.tile[item.X, item.Y + 1];
								if (Gemmable(tile2.type))
									tile2.type = randGemTile();
							}
						}
						else {
							tile.wall = (byte)(48 + randGem());
							if (!tile.active() && genRand.Next(2) == 0)
								PlaceTile(item.X, item.Y, 178, mute: true, forced: false, -1, randGem());

							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
								list2.Add(item2);
						}
					}
				}
			}

			public static void Spider(int x, int y) {
				if (!InWorld(x, y))
					return;

				byte wall = 62;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0) {
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0) {
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1)) {
							list.Remove(item);
							continue;
						}

						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0) {
							if (tile.active() && tile.wall == 0)
								tile.wall = wall;

							continue;
						}

						tile.wall = wall;
						SquareWallFrame(item.X, item.Y);
						if (!tile.active()) {
							tile.liquid = 0;
							tile.lava(lava: false);
							if (SolidTile(item.X, item.Y + 1) && genRand.Next(3) == 0) {
								if (genRand.Next(15) == 0)
									AddBuriedChest(item.X, item.Y, 939, notNearOtherChests: true, 15);
								else
									PlacePot(item.X, item.Y, 28, genRand.Next(19, 21));
							}

							if (!tile.active()) {
								if (SolidTile(item.X, item.Y - 1) && genRand.Next(3) == 0) {
									PlaceTight(item.X, item.Y, 165, spiders: true);
								}
								else if (SolidTile(item.X, item.Y + 1)) {
									PlaceTile(item.X, item.Y, 187, mute: true, forced: false, -1, 9 + genRand.Next(5));
									if (genRand.Next(3) == 0) {
										if (!tile.active())
											PlaceSmallPile(item.X, item.Y, 34 + genRand.Next(4), 1, 185);

										if (!tile.active())
											PlaceSmallPile(item.X, item.Y, 48 + genRand.Next(6), 0, 185);
									}
								}
							}
						}

						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
							list2.Add(item2);

						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
							list2.Add(item2);
					}
				}
			}

			public static void WallDungeon(int x, int y, int wallType) {
				if (!InWorld(x, y))
					return;

				byte b = (byte)wallType;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0) {
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0) {
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1)) {
							list.Remove(item);
							continue;
						}

						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (!SolidTile(item.X, item.Y) && tile.wall != b && tile.wall > 0) {
							tile.wall = b;
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
								list2.Add(item2);

							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
								list2.Add(item2);
						}
						else if (tile.active()) {
							tile.wall = b;
						}
					}
				}
			}

			private static bool Gemmable(int type) {
				if (type != 0 && type != 1 && type != 40 && type != 59 && type != 60 && type != 70 && type != 147)
					return type == 161;

				return true;
			}
		}

		public static TownRoomManager TownManager = new TownRoomManager();
		private static int lAltarX;
		private static int lAltarY;
		public static int tileReframeCount = 0;
		public static bool noMapUpdate = false;
		public static StructureMap structures;
		public static double worldSurface;
		public static double worldSurfaceLow;
		public static double worldSurfaceHigh;
		public static double rockLayer;
		public static double rockLayerLow;
		public static double rockLayerHigh;
		public static int tLeft;
		public static int tRight;
		public static int tTop;
		public static int tBottom;
		public static int tRooms;
		public static int[] mossType = new int[3];
		private static int numPyramids = 0;
		public static int c = 0;
		public static int m = 0;
		public static int a = 0;
		public static int co = 0;
		public static int ir = 0;
		public static int si = 0;
		public static int go = 0;
		public static int copperBar = 20;
		public static int ironBar = 22;
		public static int silverBar = 21;
		public static int goldBar = 19;
		public static ushort CopperTierOre = 7;
		public static ushort IronTierOre = 6;
		public static ushort SilverTierOre = 9;
		public static ushort GoldTierOre = 8;
		public static int treeBG = 0;
		public static int corruptBG = 0;
		public static int jungleBG = 0;
		public static int snowBG = 0;
		public static int hallowBG = 0;
		public static int crimsonBG = 0;
		public static int desertBG = 0;
		public static int oceanBG = 0;
		public static int oreTier1 = -1;
		public static int oreTier2 = -1;
		public static int oreTier3 = -1;
		public static bool crimson = false;
		public static byte mossTile = 179;
		public static byte mossWall = 54;
		public static bool[] gem = new bool[6];
		public static int[] tileCounts = new int[470];
		public static int totalEvil = 0;
		public static int totalBlood = 0;
		public static int totalGood = 0;
		public static int totalSolid = 0;
		public static int totalEvil2 = 0;
		public static int totalBlood2 = 0;
		public static int totalGood2 = 0;
		public static int totalSolid2 = 0;
		public static byte tEvil = 0;
		public static byte tBlood = 0;
		public static byte tGood = 0;
		public static int totalX = 0;
		public static int totalD = 0;
		public static bool IsGeneratingHardMode = false;
		private static Vector2[] heartPos = new Vector2[100];
		private static int heartCount = 0;
		public static int lavaLine;
		public static int waterLine;
		public static bool noTileActions = false;
		public static bool spawnEye = false;
		public static int spawnHardBoss = 0;
		public static int numLarva = 0;
		public static int[] larvaX = new int[100];
		public static int[] larvaY = new int[100];
		public static bool gen = false;
		public static bool shadowOrbSmashed = false;
		public static int shadowOrbCount = 0;
		public static int altarCount = 0;
		public static bool spawnMeteor = false;
		public static bool loadFailed = false;
		public static bool loadSuccess = false;
		public static bool worldCleared = false;
		public static bool worldBackup = false;
		public static bool loadBackup = false;
		private static int lastMaxTilesX = 0;
		private static int lastMaxTilesY = 0;
		public static bool saveLock = false;
		private static bool mergeUp = false;
		private static bool mergeDown = false;
		private static bool mergeLeft = false;
		private static bool mergeRight = false;
		private static bool stopDrops = false;
		private static bool mudWall = false;
		private static int grassSpread = 0;
		public static bool noLiquidCheck = false;
		[ThreadStatic]
		public static UnifiedRandom _genRand;
		[ThreadStatic]
		public static int _genRandSeed = -2;
		public static int _lastSeed;
		public static string statusText = "";
		public static bool destroyObject = false;
		public static int spawnDelay = 0;
		public static int prioritizedTownNPC = 0;
		public static int numTileCount = 0;
		public static int maxTileCount = 3500;
		public static int maxWallOut2 = 5000;
		public static int[] countX = new int[maxTileCount];
		public static int[] countY = new int[maxTileCount];
		public static int lavaCount = 0;
		public static int iceCount = 0;
		public static int rockCount = 0;
		public static int maxRoomTiles = 750;
		public static int numRoomTiles;
		public static int[] roomX = new int[maxRoomTiles];
		public static int[] roomY = new int[maxRoomTiles];
		public static int roomCeilingsCount;
		public static int[] roomCeilingX = new int[maxRoomTiles];
		public static int[] roomCeilingY = new int[maxRoomTiles];
		public static int roomX1;
		public static int roomX2;
		public static int roomY1;
		public static int roomY2;
		public static bool canSpawn;
		public static bool[] houseTile = new bool[470];
		public static int bestX = 0;
		public static int bestY = 0;
		public static int hiScore = 0;
		public static int dungeonX;
		public static int dungeonY;
		public static Vector2 lastDungeonHall = Vector2.Zero;
		public static int maxDRooms = 1000; // TODO? prob?
		public static int numDRooms = 0;
		public static int[] dRoomX = new int[maxDRooms];
		public static int[] dRoomY = new int[maxDRooms];
		public static int[] dRoomSize = new int[maxDRooms];
		private static bool[] dRoomTreasure = new bool[maxDRooms];
		private static int[] dRoomL = new int[maxDRooms];
		private static int[] dRoomR = new int[maxDRooms];
		private static int[] dRoomT = new int[maxDRooms];
		private static int[] dRoomB = new int[maxDRooms];
		private static int numDDoors;
		private static int[] DDoorX = new int[3000];
		private static int[] DDoorY = new int[3000];
		private static int[] DDoorPos = new int[3000];
		private static int numDPlats;
		private static int[] DPlatX = new int[3000];
		private static int[] DPlatY = new int[3000];
		private static int JungleItemCount = 0;
		private static int[] JChestX = new int[1000];
		private static int[] JChestY = new int[1000];
		private static int numJChests = 0;
		public static int dEnteranceX = 0;
		public static bool dSurface = false;
		private static double dxStrength1;
		private static double dyStrength1;
		private static double dxStrength2;
		private static double dyStrength2;
		private static int dMinX;
		private static int dMaxX;
		private static int dMinY;
		private static int dMaxY;
		private static int numIslandHouses = 0;
		private static int houseCount = 0;


		private static int[] fihSX = new int[1000];
		private static int[] fihSY = new int[1000];
		private static int[] fihST = new int[1000];
		private static int NIH = 0;
		private static bool[] skyLake2 = new bool[1000];


		private static bool[] skyLake = new bool[1000];
		private static int[] fihX = new int[1000];
		private static int[] fihY = new int[1000];
		private static int[] fihT = new int[1000];
		private static int numMCaves = 0;
		private static int[] mCaveX = new int[1000];
		private static int[] mCaveY = new int[1000];
		private static int JungleX = 0;
		private static int hellChest = 0;
		private static int[] hellChestItem = new int[5];
		private static bool roomTorch;
		private static bool roomDoor;
		private static bool roomChair;
		private static bool roomTable;
		private static bool roomOccupied;
		private static bool roomEvil;
		public static Point16[] statueList;
		public static List<int> StatuesWithTraps = new List<int>(new int[4] {
			4,
			7,
			10,
			18
		});
		public static Rectangle UndergroundDesertLocation = Rectangle.Empty;
		private static bool currentlyTryingToUseAlternateHousingSpot = false;
		public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
		private static int[,] trapDiag = new int[4, 2];
		private static int tileCounterNum = 0;
		private static int tileCounterMax = 20;
		private static int[] tileCounterX = new int[tileCounterMax];
		private static int[] tileCounterY = new int[tileCounterMax];
		private static WorldGenerator _generator;
		public static int WorldGenParam_Evil = -1;

		public static UnifiedRandom genRand {
			get {
				if (_lastSeed != _genRandSeed) {
					_genRand = new UnifiedRandom(_lastSeed);
					_genRandSeed = _lastSeed;
				}

				if (_genRand == null) {
					_genRand = new UnifiedRandom(_lastSeed);
					_genRandSeed = _lastSeed;
				}

				return _genRand;
			}
		}

		public static void SetupStatueList() {
			List<Point16> list = new List<Point16>();
			for (int i = 0; i < 44; i++) {
				list.Add(new Point16(105, i));
			}

			list[34] = new Point16(349, 0);
			list[43] = new Point16(105, 50);
			list.Add(new Point16(105, 63));
			list.Add(new Point16(105, 64));
			list.Add(new Point16(105, 65));
			list.Add(new Point16(105, 66));
			list.Add(new Point16(105, 68));
			list.Add(new Point16(105, 69));
			list.Add(new Point16(105, 70));
			list.Add(new Point16(105, 71));
			list.Add(new Point16(105, 72));
			list.Add(new Point16(105, 73));
			list.Add(new Point16(105, 75));
			if (Main.expertMode) {
				list.Add(new Point16(105, 67));
				list.Add(new Point16(105, 74));
			}

			statueList = list.ToArray();
		}

		public static void PlaceStatueTrap(int x, int y) {
			for (int i = -10; i <= 10; i++) {
				for (int j = -10; j <= 10; j++) {
					Tile testTile = Main.tile[x + i, y + j + 1];
					Tile tile = Main.tile[x + i, y + j];
					if (!tile.active() && SolidTile2(testTile)) {
						PlaceTile(x + i, y + j, 135, mute: true);
						if (tile.active() && tile.type == 135) {
							WorldUtils.WireLine(new Point(x, y), new Point(x + i, y + j));
							return;
						}
					}
				}
			}
		}

		public static bool MoveTownNPC(int x, int y, int n) {
			if (!StartRoomCheck(x, y)) {
				string newText = Lang.inter[40].Value;
				switch (roomCheckFailureReason) {
					case TownNPCRoomCheckFailureReason.HoleInWallIsTooBig:
						newText = Language.GetTextValue("TownNPCHousingFailureReasons.HoleInWallIsTooBig");
						break;
					case TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile:
						newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomCheckStartedInASolidTile");
						break;
					case TownNPCRoomCheckFailureReason.RoomIsTooBig:
						newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooBig");
						break;
					case TownNPCRoomCheckFailureReason.RoomIsTooSmall:
						newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooSmall");
						break;
					case TownNPCRoomCheckFailureReason.TooCloseToWorldEdge:
						newText = Language.GetTextValue("TownNPCHousingFailureReasons.TooCloseToWorldEdge");
						break;
				}

				Main.NewText(newText, byte.MaxValue, 240, 20);
				return false;
			}

			if (!RoomNeeds(prioritizedTownNPC)) {
				int num = 0;
				int num2 = ((!roomTorch) ? 1 : 0) + ((!roomDoor) ? 1 : 0) + ((!roomTable) ? 1 : 0) + ((!roomChair) ? 1 : 0);
				string[] array = new string[num2];
				if (!roomTorch) {
					array[num] = Language.GetTextValue("Game.HouseLightSource");
					num++;
				}

				if (!roomDoor) {
					array[num] = Language.GetTextValue("Game.HouseDoor");
					num++;
				}

				if (!roomTable) {
					array[num] = Language.GetTextValue("Game.HouseTable");
					num++;
				}

				if (!roomChair) {
					array[num] = Language.GetTextValue("Game.HouseChair");
					num++;
				}

				Main.NewText(Language.GetTextValue("Game.HouseMissing_" + num2, array), byte.MaxValue, 240, 20);
				return false;
			}

			ScoreRoom();
			if (hiScore <= 0) {
				if (roomOccupied)
					Main.NewText(Lang.inter[41].Value, byte.MaxValue, 240, 20);
				else if (roomEvil)
					Main.NewText(Lang.inter[42].Value, byte.MaxValue, 240, 20);
				else
					Main.NewText(Lang.inter[40].Value, byte.MaxValue, 240, 20);

				return false;
			}

			if (n > 0 && !CheckSpecialTownNPCSpawningConditions(Main.npc[n].type)) {
				Main.NewText(Lang.inter[55].Value + " " + Main.npc[n].TypeName, byte.MaxValue, 240, 20);
				return false;
			}

			return true;
		}

		public static void moveRoom(int x, int y, int n) {
			if (Main.netMode == 1) {
				NetMessage.SendData(60, -1, -1, null, n, x, y);
				return;
			}

			prioritizedTownNPC = Main.npc[n].type;
			Main.npc[n].homeless = true;
			SpawnTownNPC(x, y);
			TownManager.SetRoom(Main.npc[n].type, Main.npc[n].homeTileX, Main.npc[n].homeTileY);
		}

		public static void kickOut(int n) {
			if (Main.netMode == 1) {
				NetMessage.SendData(60, -1, -1, null, n, 0f, 0f, 1f);
				return;
			}

			Main.npc[n].homeless = true;
			TownManager.KickOut(Main.npc[n]);
		}

		public static bool IsThereASpawnablePrioritizedTownNPC(int x, int y) {
			if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPC) && NPC.AnyNPCs(prioritizedTownNPC))
				return true;

			int num = TownManager.FindOccupation(x, y);
			if (num != -1 && Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num)) {
				prioritizedTownNPC = num;
				return true;
			}

			int num2 = -1;
			for (int i = 0; i < Main.townNPCCanSpawn.Length; i++) {
				if (!Main.townNPCCanSpawn[i] || !CheckSpecialTownNPCSpawningConditions(i))
					continue;

				if (NPC.AnyNPCs(i)) {
					Main.townNPCCanSpawn[i] = false;
					continue;
				}

				if (TownManager.HasRoomQuick(i)) {
					if (num2 == -1)
						num2 = i;

					continue;
				}

				prioritizedTownNPC = i;
				return true;
			}

			if (num2 != -1) {
				prioritizedTownNPC = num2;
				return true;
			}

			return false;
		}

		public static bool CheckSpecialTownNPCSpawningConditions(int type) {
			if (!NPCLoader.CheckConditions(type))
				return false;
			if (type == 160) {
				if ((double)roomY2 > Main.worldSurface)
					return false;

				int num = 0;
				int num2 = roomX1 - Main.zoneX / 2 / 16 - 1 - Lighting.offScreenTiles;
				int num3 = roomX2 + Main.zoneX / 2 / 16 + 1 + Lighting.offScreenTiles;
				int num4 = roomY1 - Main.zoneY / 2 / 16 - 1 - Lighting.offScreenTiles;
				int num5 = roomY2 + Main.zoneY / 2 / 16 + 1 + Lighting.offScreenTiles;
				if (num2 < 0)
					num2 = 0;

				if (num3 >= Main.maxTilesX)
					num3 = Main.maxTilesX - 1;

				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				for (int i = num2 + 1; i < num3; i++) {
					for (int j = num4 + 2; j < num5 + 2; j++) {
						if (Main.tile[i, j].active() && (Main.tile[i, j].type == 70 || Main.tile[i, j].type == 71 || Main.tile[i, j].type == 72))
							num++;
					}
				}

				if (num >= 100)
					return true;

				return false;
			}

			return true;
		}

		public static void UnspawnTravelNPC() {
			int num = -1;
			for (int i = 0; i < 200; i++) {
				if (Main.npc[i].active && Main.npc[i].type == 368) {
					num = i;
					break;
				}
			}

			if (num < 0)
				return;

			int num2 = (int)(Main.npc[num].Center.X / 16f);
			int num3 = (int)(Main.npc[num].Center.Y / 16f);
			bool flag = true;
			Rectangle value = new Rectangle(num2 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num3 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
			for (int j = 0; j < 255; j++) {
				if (Main.player[j].active && new Rectangle((int)Main.player[j].position.X, (int)Main.player[j].position.Y, Main.player[j].width, Main.player[j].height).Intersects(value)) {
					flag = false;
					break;
				}
			}

			if (flag) {
				string fullName = Main.npc[num].FullName;
				if (Main.netMode == 0)
					Main.NewText(Lang.misc[35].Format(fullName), 50, 125);
				else if (Main.netMode == 2)
					NetMessage.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, Main.npc[num].GetFullNetName()), new Color(50, 125, 255));

				Main.npc[num].active = false;
				Main.npc[num].netSkip = -1;
				Main.npc[num].life = 0;
				NetMessage.SendData(23, -1, -1, null, num);
			}
		}

		public static void SpawnTravelNPC() {
			if (Main.eclipse || !Main.dayTime || (Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0))
				return;

			for (int i = 0; i < 200; i++) {
				if (Main.npc[i].active && Main.npc[i].type == 368)
					return;
			}

			Chest.SetupTravelShop();
			NetMessage.SendTravelShop(-1);
			int num = 0;
			int[] array = new int[200];
			int num2 = 0;
			for (int j = 0; j < 200; j++) {
				if (Main.npc[j].active && Main.npc[j].townNPC && Main.npc[j].type != 37 && !Main.npc[j].homeless) {
					array[num2] = j;
					num2++;
				}
			}

			if (num2 == 0)
				return;

			num = array[Main.rand.Next(num2)];
			bestX = Main.npc[num].homeTileX;
			bestY = Main.npc[num].homeTileY;
			int minValue = bestX;
			int num3 = bestX;
			int num4 = bestY;
			int num5 = bestX;
			while (num5 > bestX - 10 && (SolidTile(num5, num4) || Main.tileSolidTop[Main.tile[num5, num4].type]) && (!Main.tile[num5, num4 - 1].active() || !Main.tileSolid[Main.tile[num5, num4 - 1].type] || Main.tileSolidTop[Main.tile[num5, num4 - 1].type]) && (!Main.tile[num5, num4 - 2].active() || !Main.tileSolid[Main.tile[num5, num4 - 2].type] || Main.tileSolidTop[Main.tile[num5, num4 - 2].type]) && (!Main.tile[num5, num4 - 3].active() || !Main.tileSolid[Main.tile[num5, num4 - 3].type] || Main.tileSolidTop[Main.tile[num5, num4 - 3].type])) {
				minValue = num5;
				num5--;
			}

			for (int k = bestX; k < bestX + 10 && (SolidTile(k, num4) || Main.tileSolidTop[Main.tile[k, num4].type]) && (!Main.tile[k, num4 - 1].active() || !Main.tileSolid[Main.tile[k, num4 - 1].type] || Main.tileSolidTop[Main.tile[k, num4 - 1].type]) && (!Main.tile[k, num4 - 2].active() || !Main.tileSolid[Main.tile[k, num4 - 2].type] || Main.tileSolidTop[Main.tile[k, num4 - 2].type]) && (!Main.tile[k, num4 - 3].active() || !Main.tileSolid[Main.tile[k, num4 - 3].type] || Main.tileSolidTop[Main.tile[k, num4 - 3].type]); k++) {
				num3 = k;
			}

			for (int l = 0; l < 30; l++) {
				int num6 = Main.rand.Next(minValue, num3 + 1);
				if (l < 20) {
					if (num6 < bestX - 1 || num6 > bestX + 1) {
						bestX = num6;
						break;
					}
				}
				else if (num6 != bestX) {
					bestX = num6;
					break;
				}
			}

			int num7 = bestX;
			int num8 = bestY;
			bool flag = false;
			if (!flag && !((double)num8 > Main.worldSurface)) {
				for (int m = 20; m < 500; m++) {
					for (int n = 0; n < 2; n++) {
						num7 = ((n != 0) ? (bestX - m * 2) : (bestX + m * 2));
						if (num7 > 10 && num7 < Main.maxTilesX - 10) {
							int num9 = bestY - m;
							double num10 = bestY + m;
							if (num9 < 10)
								num9 = 10;

							if (num10 > Main.worldSurface)
								num10 = Main.worldSurface;

							for (int num11 = num9; (double)num11 < num10; num11++) {
								num8 = num11;
								if (!Main.tile[num7, num8].nactive() || !Main.tileSolid[Main.tile[num7, num8].type])
									continue;

								if (Main.tile[num7, num8 - 3].liquid != 0 || Main.tile[num7, num8 - 2].liquid != 0 || Main.tile[num7, num8 - 1].liquid != 0 || Collision.SolidTiles(num7 - 1, num7 + 1, num8 - 3, num8 - 1))
									break;

								flag = true;
								Rectangle value = new Rectangle(num7 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num8 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
								for (int num12 = 0; num12 < 255; num12++) {
									if (Main.player[num12].active && new Rectangle((int)Main.player[num12].position.X, (int)Main.player[num12].position.Y, Main.player[num12].width, Main.player[num12].height).Intersects(value)) {
										flag = false;
										break;
									}
								}

								break;
							}
						}

						if (flag)
							break;
					}

					if (flag)
						break;
				}
			}

			int num13 = NPC.NewNPC(num7 * 16, num8 * 16, 368, 1);
			Main.npc[num13].homeTileX = bestX;
			Main.npc[num13].homeTileY = bestY;
			Main.npc[num13].homeless = true;
			if (num7 < bestX)
				Main.npc[num13].direction = 1;
			else if (num7 > bestX)
				Main.npc[num13].direction = -1;

			Main.npc[num13].netUpdate = true;
			string fullName = Main.npc[num13].FullName;
			if (Main.netMode == 0)
				Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
			else if (Main.netMode == 2)
				NetMessage.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num13].GetFullNetName()), new Color(50, 125, 255));
		}

		public static TownNPCSpawnResult SpawnTownNPC(int x, int y) {
			if (Main.wallHouse[Main.tile[x, y].wall])
				canSpawn = true;

			if (!canSpawn)
				return TownNPCSpawnResult.Blocked;

			if (!StartRoomCheck(x, y))
				return TownNPCSpawnResult.Blocked;

			if (!RoomNeeds(prioritizedTownNPC))
				return TownNPCSpawnResult.Blocked;

			ScoreRoom();
			if (hiScore <= 0)
				return TownNPCSpawnResult.Blocked;

			if (!IsThereASpawnablePrioritizedTownNPC(bestX, bestY))
				return TownNPCSpawnResult.Blocked;

			int num = -1;
			for (int i = 0; i < 200; i++) {
				if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].type == prioritizedTownNPC && CheckSpecialTownNPCSpawningConditions(Main.npc[i].type)) {
					num = i;
					break;
				}
			}

			if (num != -1) {
				Main.townNPCCanSpawn[prioritizedTownNPC] = false;
				Main.npc[num].homeTileX = bestX;
				Main.npc[num].homeTileY = bestY;
				Main.npc[num].homeless = false;
				AchievementsHelper.NotifyProgressionEvent(8);
				prioritizedTownNPC = 0;
				return TownNPCSpawnResult.RelocatedHomeless;
			}

			if (num == -1) {
				if (TownManager.HasRoom(prioritizedTownNPC, out Point roomPosition) && !currentlyTryingToUseAlternateHousingSpot) {
					int num2 = bestX;
					int num3 = bestY;
					currentlyTryingToUseAlternateHousingSpot = true;
					TownNPCSpawnResult townNPCSpawnResult = SpawnTownNPC(roomPosition.X, roomPosition.Y - 2);
					currentlyTryingToUseAlternateHousingSpot = false;
					bestX = num2;
					bestY = num3;
					if (townNPCSpawnResult == TownNPCSpawnResult.Successful)
						return townNPCSpawnResult;
				}

				int num4 = bestX;
				int num5 = bestY;
				bool flag = false;
				for (int j = 0; j < 200; j++) {
					NPC nPC = Main.npc[j];
					if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == num4 && nPC.homeTileY == num5) {
						flag = true;
						break;
					}
				}

				if (flag)
					return TownNPCSpawnResult.BlockedInfiHousing;

				bool flag2 = false;
				if (!flag2) {
					flag2 = true;
					Rectangle value = new Rectangle(num4 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num5 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
					for (int k = 0; k < 255; k++) {
						if (Main.player[k].active && new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height).Intersects(value)) {
							flag2 = false;
							break;
						}
					}
				}

				if (!flag2 && !((double)num5 > Main.worldSurface)) {
					for (int l = 1; l < 500; l++) {
						for (int m = 0; m < 2; m++) {
							num4 = ((m != 0) ? (bestX - l) : (bestX + l));
							if (num4 > 10 && num4 < Main.maxTilesX - 10) {
								int num6 = bestY - l;
								double num7 = bestY + l;
								if (num6 < 10)
									num6 = 10;

								if (num7 > Main.worldSurface)
									num7 = Main.worldSurface;

								for (int n = num6; (double)n < num7; n++) {
									num5 = n;
									if (!Main.tile[num4, num5].nactive() || !Main.tileSolid[Main.tile[num4, num5].type])
										continue;

									if (Collision.SolidTiles(num4 - 1, num4 + 1, num5 - 3, num5 - 1))
										break;

									flag2 = true;
									Rectangle value2 = new Rectangle(num4 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num5 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
									for (int num8 = 0; num8 < 255; num8++) {
										if (Main.player[num8].active && new Rectangle((int)Main.player[num8].position.X, (int)Main.player[num8].position.Y, Main.player[num8].width, Main.player[num8].height).Intersects(value2)) {
											flag2 = false;
											break;
										}
									}

									break;
								}
							}

							if (flag2)
								break;
						}

						if (flag2)
							break;
					}
				}

				int num9 = NPC.NewNPC(num4 * 16, num5 * 16, prioritizedTownNPC, 1);
				Main.townNPCCanSpawn[prioritizedTownNPC] = false;
				Main.npc[num9].homeTileX = bestX;
				Main.npc[num9].homeTileY = bestY;
				if (num4 < bestX)
					Main.npc[num9].direction = 1;
				else if (num4 > bestX)
					Main.npc[num9].direction = -1;

				Main.npc[num9].netUpdate = true;
				string fullName = Main.npc[num9].FullName;
				if (Main.netMode == 0)
					Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
				else if (Main.netMode == 2)
					NetMessage.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num9].GetFullNetName()), new Color(50, 125, 255));

				AchievementsHelper.NotifyProgressionEvent(8);
				if (Main.npc[num9].type == 160)
					AchievementsHelper.NotifyProgressionEvent(18);

				CheckAchievement_RealEstate();
				prioritizedTownNPC = 0;
			}

			return TownNPCSpawnResult.Successful;
		}

		private static void CheckAchievement_RealEstate() {
			bool[] array = new bool[580];
			for (int i = 0; i < 200; i++) {
				if (Main.npc[i].active && Main.npc[i].type >= 0 && Main.npc[i].type < 580)
					array[Main.npc[i].type] = true;
			}

			if (array[38] && array[17] && array[107] && array[19] && array[22] && array[124] && array[228] && array[178] && array[18] && array[229] && array[209] && array[54] && array[108] && array[160] && array[20] && array[369] && array[207] && array[227] && array[208] && array[441] && array[353])
				AchievementsHelper.NotifyProgressionEvent(17);
		}

		public static bool RoomNeeds(int npcType) {
			roomChair = false;
			roomDoor = false;
			roomTable = false;
			roomTorch = false;
			for (int i = 0; i < TileID.Sets.RoomNeeds.CountsAsChair.Length; i++) {
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsChair[i]]) {
					roomChair = true;
					break;
				}
			}

			for (int j = 0; j < TileID.Sets.RoomNeeds.CountsAsTable.Length; j++) {
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsTable[j]]) {
					roomTable = true;
					break;
				}
			}

			for (int k = 0; k < TileID.Sets.RoomNeeds.CountsAsTorch.Length; k++) {
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsTorch[k]]) {
					roomTorch = true;
					break;
				}
			}

			for (int l = 0; l < TileID.Sets.RoomNeeds.CountsAsDoor.Length; l++) {
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsDoor[l]]) {
					roomDoor = true;
					break;
				}
			}

			if (roomChair && roomTable && roomDoor && roomTorch)
				canSpawn = true;
			else
				canSpawn = false;

			return canSpawn;
		}

		public static void QuickFindHome(int npc) {
			if (Main.npc[npc].homeTileX <= 10 || Main.npc[npc].homeTileY <= 10 || Main.npc[npc].homeTileX >= Main.maxTilesX - 10 || Main.npc[npc].homeTileY >= Main.maxTilesY)
				return;

			canSpawn = false;
			StartRoomCheck(Main.npc[npc].homeTileX, Main.npc[npc].homeTileY - 1);
			if (!canSpawn) {
				for (int i = Main.npc[npc].homeTileX - 1; i < Main.npc[npc].homeTileX + 2; i++) {
					for (int j = Main.npc[npc].homeTileY - 1; j < Main.npc[npc].homeTileY + 2 && !StartRoomCheck(i, j); j++) {
					}
				}
			}

			if (!canSpawn) {
				int num = 10;
				for (int k = Main.npc[npc].homeTileX - num; k <= Main.npc[npc].homeTileX + num; k += 2) {
					for (int l = Main.npc[npc].homeTileY - num; l <= Main.npc[npc].homeTileY + num && !StartRoomCheck(k, l); l += 2) {
					}
				}
			}

			if (canSpawn) {
				RoomNeeds(Main.npc[npc].type);
				if (canSpawn)
					ScoreRoom(npc);

				if (canSpawn && hiScore > 0) {
					for (int m = 0; m < 200; m++) {
						if (m != npc) {
							NPC nPC = Main.npc[m];
							if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == bestX && nPC.homeTileY == bestY) {
								canSpawn = false;
								break;
							}
						}
					}
				}

				if (canSpawn && hiScore > 0) {
					Main.npc[npc].homeTileX = bestX;
					Main.npc[npc].homeTileY = bestY;
					Main.npc[npc].homeless = false;
					AchievementsHelper.NotifyProgressionEvent(8);
					canSpawn = false;
				}
				else {
					Main.npc[npc].homeless = true;
				}
			}
			else {
				Main.npc[npc].homeless = true;
			}
		}

		private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1) {
			for (int i = 0; i < 200; i++) {
				if (!Main.npc[i].active || !Main.npc[i].townNPC || ignoreNPC == i || Main.npc[i].homeless)
					continue;

				for (int j = 0; j < numRoomTiles; j++) {
					if (Main.npc[i].homeTileX != roomX[j] || Main.npc[i].homeTileY != roomY[j])
						continue;

					bool flag = false;
					for (int k = 0; k < numRoomTiles; k++) {
						if (Main.npc[i].homeTileX == roomX[k] && Main.npc[i].homeTileY - 1 == roomY[k]) {
							flag = true;
							break;
						}
					}

					if (flag)
						return true;
				}
			}

			return false;
		}

		public static void CountTileTypesInArea(int[] tileTypeCounts, int startX, int endX, int startY, int endY) {
			for (int i = startX; i <= endX; i++) {
				for (int j = startY; j <= endY; j++) {
					if (Main.tile[i, j].active())
						tileTypeCounts[Main.tile[i, j].type]++;
				}
			}
		}

		public static int GetTileTypeCountByCategory(int[] tileTypeCounts, TileScanGroup group) {
			switch (group) {
				case TileScanGroup.None:
					return 0;
				case TileScanGroup.Corruption:
					return tileTypeCounts[23] + tileTypeCounts[24] + tileTypeCounts[25] + tileTypeCounts[32] + tileTypeCounts[112] + tileTypeCounts[163] + tileTypeCounts[400] + tileTypeCounts[398] + -5 * tileTypeCounts[27];
				case TileScanGroup.Crimson:
					return tileTypeCounts[199] + tileTypeCounts[203] + tileTypeCounts[200] + tileTypeCounts[401] + tileTypeCounts[399] + tileTypeCounts[234] + tileTypeCounts[352] - 5 * tileTypeCounts[27];
				case TileScanGroup.Hallow:
					return tileTypeCounts[109] + tileTypeCounts[110] + tileTypeCounts[113] + tileTypeCounts[117] + tileTypeCounts[116] + tileTypeCounts[164] + tileTypeCounts[403] + tileTypeCounts[402];
				case TileScanGroup.TotalGoodEvil: {
						int tileTypeCountByCategory = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Hallow);
						int tileTypeCountByCategory2 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Corruption);
						int tileTypeCountByCategory3 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Crimson);
						int num = 5 * tileTypeCounts[27];
						int num2 = tileTypeCountByCategory2 + tileTypeCountByCategory3 + num;
						return tileTypeCountByCategory - num2;
					}
				default:
					return 0;
			}
		}

		public static void ScoreRoom(int ignoreNPC = -1) {
			roomOccupied = false;
			roomEvil = false;
			if (ScoreRoom_IsThisRoomOccupiedBySomeone(ignoreNPC)) {
				roomOccupied = true;
				hiScore = -1;
				return;
			}

			hiScore = 0;
			int num = 0;
			int num2 = 50;
			int num3 = 40;
			int num4 = roomX1 - Main.zoneX / 2 / 16 - 1 - num3;
			int num5 = roomX2 + Main.zoneX / 2 / 16 + 1 + num3;
			int num6 = roomY1 - Main.zoneY / 2 / 16 - 1 - num3;
			int num7 = roomY2 + Main.zoneY / 2 / 16 + 1 + num3;
			if (num4 < 0)
				num4 = 0;

			if (num5 >= Main.maxTilesX)
				num5 = Main.maxTilesX - 1;

			if (num6 < 0)
				num6 = 0;

			if (num7 > Main.maxTilesY)
				num7 = Main.maxTilesY - 1;

			int[] tileTypeCounts = new int[TileLoader.TileCount];
			CountTileTypesInArea(tileTypeCounts, num4 + 1, num5 - 1, num6 + 2, num7 + 1);
			int num8 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
			if (num8 < 50)
				num8 = 0;

			num2 -= num8;
			if (num2 <= -250) {
				hiScore = num2;
				roomEvil = true;
				return;
			}

			num4 = roomX1;
			num5 = roomX2;
			num6 = roomY1;
			num7 = roomY2;
			for (int i = num4 + 1; i < num5; i++) {
				for (int j = num6 + 2; j < num7 + 2; j++) {
					if (!Main.tile[i, j].nactive())
						continue;

					num = num2;
					if (!Main.tileSolid[Main.tile[i, j].type] || Main.tileSolidTop[Main.tile[i, j].type] || Collision.SolidTiles(i - 1, i + 1, j - 3, j - 1) || !Main.tile[i - 1, j].nactive() || !Main.tileSolid[Main.tile[i - 1, j].type] || !Main.tile[i + 1, j].nactive() || !Main.tileSolid[Main.tile[i + 1, j].type])
						continue;

					int num9 = 0;
					int num10 = 0;
					for (int k = i - 2; k < i + 3; k++) {
						for (int l = j - 4; l < j; l++) {
							if (!Main.tile[k, l].nactive())
								continue;

							if (k == i) {
								num9++;
								continue;
							}

							Tile tile = Main.tile[k, l];
							if (TileID.Sets.BasicChest[tile.type])
								num10++;
							else
								num = ((tile.type != 10 && tile.type != 388) ? ((!IsOpenDoorAnchorFrame(k, l)) ? ((!Main.tileSolid[tile.type]) ? (num + 5) : (num - 5)) : (num - 20)) : (num - 20));
						}
					}

					if (num > 0 && num10 > 0) {
						num -= 30 * num10;
						if (num < 1)
							num = 1;
					}

					if (num > 0 && num9 > 0) {
						num -= 15 * num9;
						if (num <= 0)
							num = 0;
					}

					if (num <= hiScore)
						continue;

					bool flag = Housing_CheckIfInRoom(i, j);
					bool[] array = new bool[3];
					for (int m = 1; m <= 3; m++) {
						if (!Main.tile[i, j - m].active() || !Main.tileSolid[Main.tile[i, j - m].type])
							array[m - 1] = true;

						if (!Housing_CheckIfInRoom(i, j - m))
							array[m - 1] = false;
					}

					bool[] array2 = array;
					for (int n = 0; n < array2.Length; n++) {
						if (!array2[n]) {
							flag = false;
							break;
						}
					}

					if (flag && !Housing_CheckIfIsCeiling(i, j)) {
						hiScore = num;
						bestX = i;
						bestY = j;
					}
				}
			}
		}

		private static void ScoreRoom_CountEvilTilesOld(ref int startScore, int startX, int endX, int startY, int endY) {
			int num = 0;
			for (int i = startX + 1; i < endX; i++) {
				for (int j = startY + 2; j < endY + 2; j++) {
					if (Main.tile[i, j].active()) {
						if (Main.tile[i, j].type == 23 || Main.tile[i, j].type == 24 || Main.tile[i, j].type == 25 || Main.tile[i, j].type == 32 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 163)
							num++;
						else if (Main.tile[i, j].type == 199 || Main.tile[i, j].type == 201 || Main.tile[i, j].type == 200 || Main.tile[i, j].type == 203 || Main.tile[i, j].type == 234)
							num++;
						else if (Main.tile[i, j].type == 27)
							num -= 5;
						else if (Main.tile[i, j].type == 109 || Main.tile[i, j].type == 110 || Main.tile[i, j].type == 113 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 164)
							num--;
					}
				}
			}

			if (num < 50)
				num = 0;

			startScore -= num;
		}

		private static bool Housing_CheckIfIsCeiling(int i, int j) {
			bool result = false;
			for (int k = 0; k < roomCeilingsCount; k++) {
				if (roomCeilingX[k] == i) {
					if (roomCeilingY[k] == j)
						result = true;

					break;
				}
			}

			return result;
		}

		private static bool Housing_CheckIfInRoom(int i, int j) {
			bool result = false;
			for (int k = 0; k < numRoomTiles; k++) {
				if (roomX[k] == i && roomY[k] == j) {
					result = true;
					break;
				}
			}

			return result;
		}

		public static bool StartRoomCheck(int x, int y) {
			roomX1 = x;
			roomX2 = x;
			roomY1 = y;
			roomY2 = y;
			numRoomTiles = 0;
			roomCeilingsCount = 0;
			for (int i = 0; i < houseTile.Length; i++) {
				houseTile[i] = false;
			}

			canSpawn = true;
			if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type]) {
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile;
				canSpawn = false;
				return false;
			}

			roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
			CheckRoom(x, y);
			if (!canSpawn)
				return false;

			if (numRoomTiles < 60) {
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooSmall;
				canSpawn = false;
				return false;
			}

			if (canSpawn)
				return true;

			return false;
		}

		public static void CheckRoom(int x, int y) {
			if (!canSpawn)
				return;

			if (x < 10 || y < 10 || x >= Main.maxTilesX - 10 || y >= lastMaxTilesY - 10) {
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooCloseToWorldEdge;
				canSpawn = false;
				return;
			}

			for (int i = 0; i < numRoomTiles; i++) {
				if (roomX[i] == x && roomY[i] == y)
					return;
			}

			roomX[numRoomTiles] = x;
			roomY[numRoomTiles] = y;
			bool flag = false;
			for (int j = 0; j < roomCeilingsCount; j++) {
				if (roomCeilingX[j] == x) {
					flag = true;
					if (roomCeilingY[j] > y)
						roomCeilingY[j] = y;

					break;
				}
			}

			if (!flag) {
				roomCeilingX[roomCeilingsCount] = x;
				roomCeilingY[roomCeilingsCount] = y;
				roomCeilingsCount++;
			}

			numRoomTiles++;
			if (numRoomTiles >= maxRoomTiles) {
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
				canSpawn = false;
				return;
			}

			if (Main.tile[x, y].nactive()) {
				houseTile[Main.tile[x, y].type] = true;
				if (Main.tileSolid[Main.tile[x, y].type] || (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)) || Main.tile[x, y].type == 389 || (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0))))
					return;
				if (TileLoader.CloseDoorID(Main.tile[x, y]) >= 0 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126))
					return;
			}

			if (x < roomX1)
				roomX1 = x;

			if (x > roomX2)
				roomX2 = x;

			if (y < roomY1)
				roomY1 = y;

			if (y > roomY2)
				roomY2 = y;

			bool flag2 = false;
			bool flag3 = false;
			for (int k = -2; k < 3; k++) {
				if (Main.wallHouse[Main.tile[x + k, y].wall])
					flag2 = true;

				if (Main.tile[x + k, y].nactive() && (Main.tileSolid[Main.tile[x + k, y].type] || TileID.Sets.HousingWalls[Main.tile[x + k, y].type]))
					flag2 = true;

				if (Main.wallHouse[Main.tile[x, y + k].wall])
					flag3 = true;

				if (Main.tile[x, y + k].nactive() && (Main.tileSolid[Main.tile[x, y + k].type] || TileID.Sets.HousingWalls[Main.tile[x, y + k].type]))
					flag3 = true;
			}

			if (!flag2 || !flag3) {
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.HoleInWallIsTooBig;
				canSpawn = false;
				return;
			}

			for (int l = x - 1; l < x + 2; l++) {
				for (int m = y - 1; m < y + 2; m++) {
					if ((l != x || m != y) && canSpawn)
						CheckRoom(l, m);
				}
			}
		}

		public static void dropMeteor() {
			bool flag = false;
			if (Main.netMode == 1)
				return;

			for (int i = 0; i < 255; i++) {
				if (Main.player[i].active) {
					flag = false;
					break;
				}
			}

			int num = 0;
			float num2 = Main.maxTilesX / 4200f;
			int num3 = (int)(400f * num2);
			for (int j = 5; j < Main.maxTilesX - 5; j++) {
				for (int k = 5; (double)k < Main.worldSurface; k++) {
					if (Main.tile[j, k].active() && Main.tile[j, k].type == 37) {
						//num++; // prevents dropmeteor from failing
						if (num > num3)
							return;
					}
				}
			}

			float num4 = 600f;
			while (!flag) {
				float num5 = (float)Main.maxTilesX * 0.08f;
				int num6 = Main.rand.Next(150, Main.maxTilesX - 150);
				while ((float)num6 > (float)Main.spawnTileX - num5 && (float)num6 < (float)Main.spawnTileX + num5) {
					num6 = Main.rand.Next(150, Main.maxTilesX - 150);
				}

				for (int l = (int)(Main.worldSurface * 0.3); l < Main.maxTilesY; l++) {
					if (!Main.tile[num6, l].active() || !Main.tileSolid[Main.tile[num6, l].type])
						continue;

					int num7 = 0;
					int num8 = 15;
					for (int m = num6 - num8; m < num6 + num8; m++) {
						for (int n = l - num8; n < l + num8; n++) {
							if (SolidTile(m, n)) {
								num7++;
								if (Main.tile[m, n].type == 189 || Main.tile[m, n].type == 202)
									num7 -= 100;
							}
							else if (Main.tile[m, n].liquid > 0) {
								num7--;
							}
						}
					}

					if ((float)num7 >= num4) {
						flag = meteor(num6, l);
						if (!flag) {
						}
					}
					else {
						num4 -= 0.5f;
					}

					break;
				}

				//if (num4 < 100f)
				//	break;
			}
		}

		public static bool meteor(int i, int j) {
			if (i < 50 || i > Main.maxTilesX - 50)
				return false;

			if (j < 50 || j > Main.maxTilesY - 50)
				return false;

			int num = 35;
			Rectangle rectangle = new Rectangle((i - num) * 16, (j - num) * 16, num * 2 * 16, num * 2 * 16);
			for (int k = 0; k < 255; k++) {
				if (Main.player[k].active) {
					Rectangle value = new Rectangle((int)(Main.player[k].position.X + (float)(Main.player[k].width / 2) - (float)(NPC.sWidth / 2) - (float)NPC.safeRangeX), (int)(Main.player[k].position.Y + (float)(Main.player[k].height / 2) - (float)(NPC.sHeight / 2) - (float)NPC.safeRangeY), NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
					if (rectangle.Intersects(value))
						return false;
				}
			}

			for (int l = 0; l < 200; l++) {
				if (Main.npc[l].active) {
					Rectangle value2 = new Rectangle((int)Main.npc[l].position.X, (int)Main.npc[l].position.Y, Main.npc[l].width, Main.npc[l].height);
					if (rectangle.Intersects(value2))
						return false;
				}
			}

			for (int m = i - num; m < i + num; m++) {
				for (int n = j - num; n < j + num; n++) {
					if (Main.tile[m, n].active() && TileID.Sets.BasicChest[Main.tile[m, n].type])
						return false;
				}
			}

			stopDrops = true;
			num = genRand.Next(17, 23);
			for (int num2 = i - num; num2 < i + num; num2++) {
				for (int num3 = j - num; num3 < j + num; num3++) {
					if (num3 <= j + Main.rand.Next(-2, 3) - 5)
						continue;

					float num4 = Math.Abs(i - num2);
					float num5 = Math.Abs(j - num3);
					if ((double)(float)Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.9 + (double)Main.rand.Next(-4, 5)) {
						if (!Main.tileSolid[Main.tile[num2, num3].type])
							Main.tile[num2, num3].active(active: false);

						Main.tile[num2, num3].type = 37;
					}
				}
			}

			num = genRand.Next(8, 14);
			for (int num6 = i - num; num6 < i + num; num6++) {
				for (int num7 = j - num; num7 < j + num; num7++) {
					if (num7 > j + Main.rand.Next(-2, 3) - 4) {
						float num8 = Math.Abs(i - num6);
						float num9 = Math.Abs(j - num7);
						if ((double)(float)Math.Sqrt(num8 * num8 + num9 * num9) < (double)num * 0.8 + (double)Main.rand.Next(-3, 4))
							Main.tile[num6, num7].active(active: false);
					}
				}
			}

			num = genRand.Next(25, 35);
			for (int num10 = i - num; num10 < i + num; num10++) {
				for (int num11 = j - num; num11 < j + num; num11++) {
					float num12 = Math.Abs(i - num10);
					float num13 = Math.Abs(j - num11);
					if ((double)(float)Math.Sqrt(num12 * num12 + num13 * num13) < (double)num * 0.7) {
						if (Main.tile[num10, num11].type == 5 || Main.tile[num10, num11].type == 32 || Main.tile[num10, num11].type == 352)
							KillTile(num10, num11);

						Main.tile[num10, num11].liquid = 0;
					}

					if (Main.tile[num10, num11].type == 37) {
						if (!SolidTile(num10 - 1, num11) && !SolidTile(num10 + 1, num11) && !SolidTile(num10, num11 - 1) && !SolidTile(num10, num11 + 1))
							Main.tile[num10, num11].active(active: false);
						else if ((Main.tile[num10, num11].halfBrick() || Main.tile[num10 - 1, num11].topSlope()) && !SolidTile(num10, num11 + 1))
							Main.tile[num10, num11].active(active: false);
					}

					SquareTileFrame(num10, num11);
					SquareWallFrame(num10, num11);
				}
			}

			num = genRand.Next(23, 32);
			for (int num14 = i - num; num14 < i + num; num14++) {
				for (int num15 = j - num; num15 < j + num; num15++) {
					if (num15 <= j + genRand.Next(-3, 4) - 3 || !Main.tile[num14, num15].active() || Main.rand.Next(10) != 0)
						continue;

					float num16 = Math.Abs(i - num14);
					float num17 = Math.Abs(j - num15);
					if ((double)(float)Math.Sqrt(num16 * num16 + num17 * num17) < (double)num * 0.8) {
						if (Main.tile[num14, num15].type == 5 || Main.tile[num14, num15].type == 32 || Main.tile[num14, num15].type == 352)
							KillTile(num14, num15);

						Main.tile[num14, num15].type = 37;
						SquareTileFrame(num14, num15);
					}
				}
			}

			num = genRand.Next(30, 38);
			for (int num18 = i - num; num18 < i + num; num18++) {
				for (int num19 = j - num; num19 < j + num; num19++) {
					if (num19 <= j + genRand.Next(-2, 3) || !Main.tile[num18, num19].active() || Main.rand.Next(20) != 0)
						continue;

					float num20 = Math.Abs(i - num18);
					float num21 = Math.Abs(j - num19);
					if ((double)(float)Math.Sqrt(num20 * num20 + num21 * num21) < (double)num * 0.85) {
						if (Main.tile[num18, num19].type == 5 || Main.tile[num18, num19].type == 32 || Main.tile[num18, num19].type == 352)
							KillTile(num18, num19);

						Main.tile[num18, num19].type = 37;
						SquareTileFrame(num18, num19);
					}
				}
			}

			stopDrops = false;
			if (Main.netMode == 0)
				Main.NewText(Lang.gen[59].Value, 50, byte.MaxValue, 130);
			else if (Main.netMode == 2)
				NetMessage.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, 255, 130));

			if (Main.netMode != 1)
				NetMessage.SendTileSquare(-1, i, j, 40);

			return true;
		}

		public static void setWorldSize() {
			Main.bottomWorld = Main.maxTilesY * 16;
			Main.rightWorld = Main.maxTilesX * 16;
			Main.maxSectionsX = Main.maxTilesX / 200;
			Main.maxSectionsY = Main.maxTilesY / 150;
		}

		public static void worldGenCallBack(object threadContext) {
			try {
				do_worldGenCallBack(threadContext);
			}
			catch (Exception e) {
				Logging.Terraria.Error(Language.GetTextValue("tModLoader.WorldGenError"), e);
			}
		}

		public static void do_worldGenCallBack(object threadContext) {
			Main.PlaySound(10);
			clearWorld();
			generateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
			WorldFile.saveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
			BackupIO.archiveLock = false;
			/*
			if (Main.menuMode == 10 || Main.menuMode == 888)
				Main.menuMode = 6;
			*/
			Main.PlaySound(10);
			Main.menuMode = (int)TerraCustom.MenuModes.Settings;
		}

		public static void CreateNewWorld(GenerationProgress progress = null) {
			Main.rand = new UnifiedRandom(Main.ActiveWorldFileData.Seed);
			ThreadPool.QueueUserWorkItem(worldGenCallBack, progress);
		}

		public static void SaveAndQuitCallBack(object threadContext) {
			try {
				Main.PlaySound(34, -1, -1, 0);
				Main.PlaySound(35, -1, -1, 0);
			}
			catch {
			}

			if (Main.netMode == 0)
				WorldFile.CacheSaveTime();

			Main.invasionProgress = 0;
			Main.invasionProgressDisplayLeft = 0;
			Main.invasionProgressAlpha = 0f;
			Main.menuMode = 10;
			Main.gameMenu = true;
			Main.StopTrackedSounds();
			CaptureInterface.ResetFocus();
			Main.ActivePlayerFileData.StopPlayTimer();
			Player.SavePlayer(Main.ActivePlayerFileData);
			if (Main.netMode == 0) {
				WorldFile.saveWorld();
				Main.PlaySound(10);
			}
			else {
				Netplay.disconnect = true;
				Main.netMode = 0;
			}

			Main.fastForwardTime = false;
			Main.UpdateSundial();
			Main.menuMode = 0;
			if (threadContext != null)
				((Action)threadContext)();
		}

		public static void SaveAndQuit(Action callback = null) {
			Main.PlaySound(11);
			ModHooks.PreSaveAndQuit();
			ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, callback);
		}

		public static void playWorldCallBack(object threadContext) {
			try {
				Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}", Main.ActiveWorldFileData.Name, Main.ActiveWorldFileData.IsCloudSave);
				do_playWorldCallBack(threadContext);
			}
			catch (Exception e) {
				Logging.Terraria.Error(Language.GetTextValue("tModLoader.PlayerLoadWorldFail"), e);
			}
		}

		public static void do_playWorldCallBack(object threadContext) {
			if (Main.rand == null)
				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);

			for (int i = 0; i < 255; i++) {
				if (i != Main.myPlayer)
					Main.player[i].active = false;
			}

			noMapUpdate = true;
			WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess) {
				WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess) {
					bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
					if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
						worldBackup = true;
					else
						worldBackup = false;

					if (!Main.dedServ) {
						if (worldBackup)
							Main.menuMode = 200;
						else
							Main.menuMode = 201;

						return;
					}

					if (!worldBackup) {
						string message = Language.GetTextValue("Error.LoadFailedNoBackup");
						if (WorldIO.customDataFail != null) {
							message = WorldIO.customDataFail.modName + " " + message;
							message += "\n" + WorldIO.customDataFail.InnerException;
						}

						Console.WriteLine(message);
						return;
					}

					FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
					WorldIO.LoadDedServBackup(Main.worldPathName, isCloudSave);
					WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess) {
						WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
						if (loadFailed || !loadSuccess) {
							FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
							FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
							FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
							WorldIO.RevertDedServBackup(Main.worldPathName, isCloudSave);
							string message = Language.GetTextValue("Error.LoadFailed");
							if (WorldIO.customDataFail != null) {
								message = WorldIO.customDataFail.modName + " " + message;
								message += "\n" + WorldIO.customDataFail.InnerException;
							}

							Console.WriteLine(message);
							return;
						}
					}
				}
			}

			if (Main.mapEnabled)
				Main.Map.Load();

			if (Main.netMode != 2)
				Main.sectionManager.SetAllFramesLoaded();

			while (Main.loadMapLock) {
				float num = (float)Main.loadMapLastX / (float)Main.maxTilesX;
				Main.statusText = Lang.gen[68].Value + " " + (int)(num * 100f + 1f) + "%";
				Thread.Sleep(0);
				if (!Main.mapEnabled)
					break;
			}

			if (Main.gameMenu)
				Main.gameMenu = false;

			if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
				Main.anglerQuestFinished = true;

			// Move rest of method to main thread to fix concurrent modification exceptions
			Main.OnTick += FinishPlayWorld;
		}

		internal static void FinishPlayWorld() {
			Main.OnTick -= FinishPlayWorld;
			Main.player[Main.myPlayer].Spawn();
			Main.player[Main.myPlayer].Update(Main.myPlayer);
			Main.ActivePlayerFileData.StartPlayTimer();
			_lastSeed = Main.ActiveWorldFileData.Seed;
			Player.Hooks.EnterWorld(Main.myPlayer);
			WorldFile.SetOngoingToTemps();
			Main.PlaySound(11);
			Main.resetClouds = true;
			noMapUpdate = false;
		}

		public static void playWorld() {
			ThreadPool.QueueUserWorkItem(playWorldCallBack, 1);
		}

		public static void saveAndPlayCallBack(object threadContext) {
			WorldFile.saveWorld();
		}

		public static void saveAndPlay() {
			ThreadPool.QueueUserWorkItem(saveAndPlayCallBack, 1);
		}

		public static void saveToonWhilePlayingCallBack(object threadContext) {
			Player.SavePlayer(Main.ActivePlayerFileData);
		}

		public static void saveToonWhilePlaying() {
			ThreadPool.QueueUserWorkItem(saveToonWhilePlayingCallBack, 1);
		}

		public static void serverLoadWorldCallBack(object threadContext) {
			Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}", Main.ActiveWorldFileData.Name, Main.ActiveWorldFileData.IsCloudSave);
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
			WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess) {
				WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess) {
					bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
					if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
						worldBackup = true;
					else
						worldBackup = false;

					if (!Main.dedServ) {
						if (worldBackup)
							Main.menuMode = 200;
						else
							Main.menuMode = 201;

						return;
					}

					if (!worldBackup) {
						Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
						return;
					}

					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
					WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess) {
						WorldFile.loadWorld(Main.ActiveWorldFileData.IsCloudSave);
						if (loadFailed || !loadSuccess) {
							Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
							return;
						}
					}
				}
			}

			_lastSeed = Main.ActiveWorldFileData.Seed;
			Main.PlaySound(10);
			Netplay.StartServer();
			WorldFile.SetOngoingToTemps();
			Hooks.WorldLoaded();
		}

		public static void serverLoadWorld() {
			ThreadPool.QueueUserWorkItem(serverLoadWorldCallBack, 1);
		}

		public static void clearWorld() {
			WorldGen.numPyramids = 0;
			TownManager = new TownRoomManager();
			Hooks.ClearWorld();
			TileEntity.Clear();
			Main.checkXMas();
			Main.checkHalloween();
			if (Main.mapReady) {
				for (int i = 0; i < lastMaxTilesX; i++) {
					_ = (float)i / (float)lastMaxTilesX;
					Main.statusText = Lang.gen[65].Value;
				}

				//Main.Map.Clear();
			}

			NPC.MoonLordCountdown = 0;
			Main.pumpkinMoon = false;
			Main.clearMap = true;
			Main.mapTime = 0;
			Main.updateMap = false;
			Main.mapReady = false;
			Main.refreshMap = false;
			Main.eclipse = false;
			Main.slimeRain = false;
			Main.slimeRainTime = 0.0;
			Main.sundialCooldown = 0;
			Main.fastForwardTime = false;
			BirthdayParty.WorldClear();
			Sandstorm.WorldClear();
			Main.UpdateSundial();
			Main.wof = -1;
			NPC.waveKills = 0f;
			spawnHardBoss = 0;
			totalSolid2 = 0;
			totalGood2 = 0;
			totalEvil2 = 0;
			totalBlood2 = 0;
			totalSolid = 0;
			totalGood = 0;
			totalEvil = 0;
			totalBlood = 0;
			WorldFile.ResetTemps();
			Main.maxRaining = 0f;
			totalX = 0;
			totalD = 0;
			tEvil = 0;
			tBlood = 0;
			tGood = 0;
			spawnEye = false;
			prioritizedTownNPC = 0;
			shadowOrbCount = 0;
			altarCount = 0;
			//WorldGen.oreTier1 = -1;
			//WorldGen.oreTier2 = -1;
			//WorldGen.oreTier3 = -1;
			Main.cloudBGActive = 0f;
			Main.raining = false;
			//Main.hardMode = false;
			Main.helpText = 0;
			Main.BartenderHelpTextIndex = 0;
			Main.dungeonX = 0;
			Main.dungeonY = 0;
			/*
			NPC.downedBoss1 = false;
			NPC.downedBoss2 = false;
			NPC.downedBoss3 = false;
			NPC.downedQueenBee = false;
			NPC.downedSlimeKing = false;
			NPC.downedMechBossAny = false;
			NPC.downedMechBoss1 = false;
			NPC.downedMechBoss2 = false;
			NPC.downedMechBoss3 = false;
			NPC.downedFishron = false;
			NPC.downedAncientCultist = false;
			NPC.downedMoonlord = false;
			*/
			NPC.downedBoss1 = Main.setting.downedEyeOfCthulu;
			NPC.downedBoss2 = Main.setting.downedEaterBrain;
			NPC.downedBoss3 = Main.setting.downedSkeletron;
			NPC.downedQueenBee = Main.setting.downedQueenBee;
			NPC.downedSlimeKing = Main.setting.downedSlimeKing;
			NPC.downedMechBossAny = Main.setting.downedTwins | Main.setting.downedDestroyer | Main.setting.downedSkeletronPrime;//false;
			NPC.downedMechBoss1 = Main.setting.downedTwins;
			NPC.downedMechBoss2 = Main.setting.downedDestroyer;
			NPC.downedMechBoss3 = Main.setting.downedSkeletronPrime;
			NPC.downedFishron = Main.setting.downedFishron;
			NPC.downedAncientCultist = Main.setting.downedAncientCultist;
			NPC.downedMoonlord = Main.setting.downedMoonlord;
			NPC.downedHalloweenKing = false;
			NPC.downedHalloweenTree = false;
			NPC.downedChristmasIceQueen = false;
			NPC.downedChristmasSantank = false;
			NPC.downedChristmasTree = false;
			/*
			NPC.downedPlantBoss = false;
			NPC.downedGolemBoss = false;
			NPC.savedStylist = false;
			NPC.savedGoblin = false;
			NPC.savedWizard = false;
			NPC.savedMech = false;
			NPC.savedTaxCollector = false;
			NPC.savedAngler = false;
			NPC.savedBartender = false;
			*/
			NPC.downedPlantBoss = Main.setting.downedPlantera;
			NPC.downedGolemBoss = Main.setting.downedGolem;
			NPC.savedStylist = Main.setting.savedStylist;
			NPC.savedGoblin = Main.setting.savedGoblin;
			NPC.savedWizard = Main.setting.savedWizard;
			NPC.savedMech = Main.setting.savedMechanic;
			NPC.savedTaxCollector = Main.setting.savedTaxCollector;
			NPC.savedAngler = Main.setting.savedAngler;
			NPC.savedBartender = Main.setting.savedBartender;
			NPC.downedGoblins = false;
			NPC.downedClown = false;
			NPC.downedFrost = false;
			NPC.downedPirates = false;
			NPC.downedMartians = false;
			NPC.downedTowerSolar = (NPC.downedTowerVortex = (NPC.downedTowerNebula = (NPC.downedTowerStardust = (NPC.LunarApocalypseIsUp = false))));
			NPC.TowerActiveSolar = (NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveStardust = false)));
			DD2Event.ResetProgressEntirely();
			NPC.ClearFoundActiveNPCs();
			shadowOrbSmashed = false;
			spawnMeteor = false;
			stopDrops = false;
			Main.invasionDelay = 0;
			Main.invasionType = 0;
			Main.invasionSize = 0;
			Main.invasionWarn = 0;
			Main.invasionX = 0.0;
			Main.invasionSizeStart = 0;
			Main.treeX[0] = Main.maxTilesX;
			Main.treeX[1] = Main.maxTilesX;
			Main.treeX[2] = Main.maxTilesX;
			//Main.treeStyle[0] = 0;
			//Main.treeStyle[1] = 0;
			//Main.treeStyle[2] = 0;
			//Main.treeStyle[3] = 0;
			noLiquidCheck = false;
			Liquid.numLiquid = 0;
			LiquidBuffer.numLiquidBuffer = 0;
			Main.tile = new Tile[Main.maxTilesX + 1, Main.maxTilesY + 1]; // should be +1?
			/*
			if (Main.netMode == 1 || lastMaxTilesX > Main.maxTilesX || lastMaxTilesY > Main.maxTilesY) {
				for (int j = 0; j < lastMaxTilesX; j++) {
					float num = (float)j / (float)lastMaxTilesX;
					Main.statusText = Lang.gen[46].Value + " " + (int)(num * 100f + 1f) + "%";
					for (int k = 0; k < lastMaxTilesY; k++) {
						Main.tile[j, k] = null;
					}
				}
			}
			*/
			lastMaxTilesX = Main.maxTilesX;
			lastMaxTilesY = Main.maxTilesY;
			if (Main.netMode != 2)
				Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);

			if (Main.netMode != 1) {
				for (int l = 0; l < Main.maxTilesX; l++) {
					float num2 = (float)l / (float)Main.maxTilesX;
					Main.statusText = Lang.gen[47].Value + " " + (int)(num2 * 100f + 1f) + "%";
					for (int m = 0; m < Main.maxTilesY; m++) {
						if (Main.tile[l, m] == null)
							Main.tile[l, m] = new Tile();
						else
							Main.tile[l, m].ClearEverything();
					}
				}
			}

			CombatText.clearAll();
			for (int n = 0; n < 6000; n++) {
				Main.dust[n] = new Dust();
				Main.dust[n].dustIndex = n;
			}

			for (int num3 = 0; num3 < 500; num3++) {
				Main.gore[num3] = new Gore();
			}

			for (int num4 = 0; num4 < 400; num4++) {
				Main.item[num4] = new Item();
				Main.itemLockoutTime[num4] = 0;
			}

			for (int num5 = 0; num5 < 200; num5++) {
				Main.npc[num5] = new NPC();
			}

			for (int num6 = 0; num6 < 1000; num6++) {
				Main.projectile[num6] = new Projectile();
			}

			for (int num7 = 0; num7 < 1000; num7++) {
				Main.chest[num7] = null;
			}

			for (int num8 = 0; num8 < 1000; num8++) {
				Main.sign[num8] = null;
			}

			for (int num9 = 0; num9 < Liquid.resLiquid; num9++) {
				Main.liquid[num9] = new Liquid();
			}

			for (int num10 = 0; num10 < 10000; num10++) {
				Main.liquidBuffer[num10] = new LiquidBuffer();
			}

			setWorldSize();
			WorldHooks.SetupWorld();
			worldCleared = true;
		}

		public static void setBG(int bg, int style) {
			switch (bg) {
				case 0:
					treeBG = style;
					Main.treeMntBG[0] = 7;
					Main.treeMntBG[1] = 8;
					switch (style) {
						case 1:
							Main.treeBG[0] = 50;
							Main.treeBG[1] = 51;
							Main.treeBG[2] = 52;
							break;
						case 2:
							Main.treeBG[0] = 53;
							Main.treeBG[1] = 54;
							Main.treeBG[2] = 55;
							break;
						case 3:
							Main.treeMntBG[1] = 90;
							Main.treeBG[0] = 91;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = 92;
							break;
						case 31:
							Main.treeMntBG[1] = 90;
							Main.treeBG[0] = 91;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = 11;
							break;
						case 4:
							Main.treeMntBG[0] = 93;
							Main.treeMntBG[1] = 94;
							Main.treeBG[0] = -1;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = -1;
							break;
						case 5:
							Main.treeMntBG[0] = 93;
							Main.treeMntBG[1] = 94;
							Main.treeBG[0] = -1;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = 55;
							break;
						case 51:
							Main.treeMntBG[0] = 93;
							Main.treeMntBG[1] = 94;
							Main.treeBG[0] = -1;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = 11;
							break;
						case 6:
							Main.treeMntBG[0] = 171;
							Main.treeMntBG[1] = 172;
							Main.treeBG[0] = 173;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = -1;
							break;
						case 7:
							Main.treeMntBG[0] = 176;
							Main.treeMntBG[1] = 177;
							Main.treeBG[0] = 178;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = -1;
							break;
						case 71:
							Main.treeMntBG[0] = 176;
							Main.treeMntBG[1] = 177;
							Main.treeBG[0] = 178;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = 11;
							break;
						case 72:
							Main.treeMntBG[0] = 176;
							Main.treeMntBG[1] = 177;
							Main.treeBG[0] = 178;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = 52;
							break;
						case 73:
							Main.treeMntBG[0] = 176;
							Main.treeMntBG[1] = 177;
							Main.treeBG[0] = 178;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = 55;
							break;
						case 8:
							Main.treeMntBG[0] = 179;
							Main.treeMntBG[1] = 180;
							Main.treeBG[0] = 184;
							Main.treeBG[1] = -1;
							Main.treeBG[2] = -1;
							break;
						default:
							Main.treeBG[0] = 9;
							Main.treeBG[1] = 10;
							Main.treeBG[2] = 11;
							break;
					}
					break;
				case 1:
					corruptBG = style;
					if (style == 1) {
						Main.corruptBG[0] = 56;
						Main.corruptBG[1] = 57;
						Main.corruptBG[2] = 58;
					}
					else {
						Main.corruptBG[0] = 12;
						Main.corruptBG[1] = 13;
						Main.corruptBG[2] = 14;
					}
					break;
				case 2:
					jungleBG = style;
					if (style == 1) {
						Main.jungleBG[0] = 59;
						Main.jungleBG[1] = 60;
						Main.jungleBG[2] = 61;
					}
					else {
						Main.jungleBG[0] = 15;
						Main.jungleBG[1] = 16;
						Main.jungleBG[2] = 17;
					}
					break;
				case 3:
					snowBG = style;
					Main.snowMntBG[0] = 35;
					Main.snowMntBG[1] = 36;
					switch (style) {
						case 1:
							Main.snowBG[0] = 97;
							Main.snowBG[1] = 96;
							Main.snowBG[2] = 95;
							break;
						case 2:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 99;
							Main.snowBG[0] = -1;
							Main.snowBG[1] = -1;
							Main.snowBG[2] = -1;
							break;
						case 21:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 99;
							Main.snowBG[0] = 95;
							Main.snowBG[1] = 96;
							Main.snowBG[2] = 97;
							break;
						case 22:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 99;
							Main.snowBG[0] = 37;
							Main.snowBG[1] = 38;
							Main.snowBG[2] = 39;
							break;
						case 3:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 100;
							Main.snowBG[0] = -1;
							Main.snowBG[1] = -1;
							Main.snowBG[2] = -1;
							break;
						case 31:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 100;
							Main.snowBG[0] = 95;
							Main.snowBG[1] = 96;
							Main.snowBG[2] = 97;
							break;
						case 32:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 100;
							Main.snowBG[0] = 37;
							Main.snowBG[1] = 38;
							Main.snowBG[2] = 39;
							break;
						case 4:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 101;
							Main.snowBG[0] = -1;
							Main.snowBG[1] = -1;
							Main.snowBG[2] = -1;
							break;
						case 41:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 101;
							Main.snowBG[0] = 95;
							Main.snowBG[1] = 96;
							Main.snowBG[2] = 97;
							break;
						case 42:
							Main.snowMntBG[0] = 98;
							Main.snowMntBG[1] = 101;
							Main.snowBG[0] = 37;
							Main.snowBG[1] = 38;
							Main.snowBG[2] = 39;
							break;
						default:
							Main.snowBG[0] = 37;
							Main.snowBG[1] = 38;
							Main.snowBG[2] = 39;
							break;
					}
					break;
				case 4:
					hallowBG = style;
					if (style == 1) {
						Main.hallowBG[0] = 102;
						Main.hallowBG[1] = 103;
						Main.hallowBG[2] = 104;
					}
					else {
						Main.hallowBG[0] = 29;
						Main.hallowBG[1] = 30;
						Main.hallowBG[2] = 31;
					}
					break;
				case 5:
					crimsonBG = style;
					if (style == 1) {
						Main.crimsonBG[0] = 105;
						Main.crimsonBG[1] = 106;
						Main.crimsonBG[2] = 107;
					}
					if (style == 2) {
						Main.crimsonBG[0] = 174;
						Main.crimsonBG[1] = -1;
						Main.crimsonBG[2] = 175;
					}
					else {
						Main.crimsonBG[0] = 43;
						Main.crimsonBG[1] = 44;
						Main.crimsonBG[2] = 45;
					}
					break;
				case 6:
					desertBG = style;
					if (style == 1) {
						Main.desertBG[0] = 108;
						Main.desertBG[1] = 109;
					}
					else {
						Main.desertBG[0] = 21;
						Main.desertBG[1] = 20;
					}
					break;
				case 7:
					oceanBG = style;
					switch (style) {
						case 1:
							Main.oceanBG = 110;
							break;
						case 2:
							Main.oceanBG = 111;
							break;
						default:
							Main.oceanBG = 28;
							break;
					}
					break;
			}
		}

		public static void RandomizeWeather() {
			if (Main.cloudLimit >= 10) {
				Main.numClouds = genRand.Next(10, Main.cloudLimit);
				Main.windSpeed = 0f;
				while (Main.windSpeed == 0f) {
					Main.windSpeed = (float)genRand.Next(-100, 101) * 0.01f;
					Main.windSpeedSet = Main.windSpeed;
				}

				Cloud.resetClouds();
			}
		}

		public static void RandomizeMoonState() {
			Main.moonType = Main.setting.MoonStyle;
			if (Main.setting.MoonStyle == 3)
			{
				Main.moonType = WorldGen.genRand.Next(Main.maxMoons);
			}
		}

		public static void RandomizeBackgrounds() {
			if (Main.setting.ForestStyle == 14)
			{
				WorldGen.treeBG = WorldGen.genRand.Next(9);
				if ((WorldGen.treeBG == 1 || WorldGen.treeBG == 2) && WorldGen.genRand.Next(2) == 0)
				{
					WorldGen.treeBG = WorldGen.genRand.Next(7);
				}
				if (WorldGen.treeBG == 0)
				{
					WorldGen.treeBG = WorldGen.genRand.Next(7);
				}
				if (WorldGen.treeBG == 3 && WorldGen.genRand.Next(3) == 0)
				{
					WorldGen.treeBG = 31;
				}
				if (WorldGen.treeBG == 5 && WorldGen.genRand.Next(2) == 0)
				{
					WorldGen.treeBG = 51;
				}
				if (WorldGen.treeBG == 7 && WorldGen.genRand.Next(4) == 0)
				{
					WorldGen.treeBG = WorldGen.genRand.Next(71, 74);
				}
				WorldGen.setBG(0, WorldGen.treeBG);
			}
			else
			{
				switch (Main.setting.ForestStyle)
				{
					case 9:
						WorldGen.setBG(0, 31);
						break;
					case 10:
						WorldGen.setBG(0, 51);
						break;
					case 11:
						WorldGen.setBG(0, 71);
						break;
					case 12:
						WorldGen.setBG(0, 72);
						break;
					case 13:
						WorldGen.setBG(0, 73);
						break;
					default:
						WorldGen.setBG(0, Main.setting.ForestStyle);
						break;
				}
			}
			if (Main.setting.CorruptStyle == 2)
			{
				WorldGen.setBG(1, WorldGen.genRand.Next(2));
			}
			else
			{
				WorldGen.setBG(1, Main.setting.CorruptStyle);
			}
			if (Main.setting.JungleStyle == 2)
			{
				WorldGen.setBG(2, WorldGen.genRand.Next(2));
			}
			else
			{
				WorldGen.setBG(2, Main.setting.JungleStyle);
			}
			if (Main.setting.SnowStyle == 11)
			{
				WorldGen.snowBG = WorldGen.genRand.Next(6);
				if (WorldGen.snowBG == 2 && WorldGen.genRand.Next(2) == 0)
				{
					if (WorldGen.genRand.Next(2) == 0)
					{
						WorldGen.snowBG = 21;
					}
					else
					{
						WorldGen.snowBG = 22;
					}
				}
				if (WorldGen.snowBG == 3 && WorldGen.genRand.Next(2) == 0)
				{
					if (WorldGen.genRand.Next(2) == 0)
					{
						WorldGen.snowBG = 31;
					}
					else
					{
						WorldGen.snowBG = 32;
					}
				}
				if (WorldGen.snowBG == 4 && WorldGen.genRand.Next(2) == 0)
				{
					if (WorldGen.genRand.Next(2) == 0)
					{
						WorldGen.snowBG = 41;
					}
					else
					{
						WorldGen.snowBG = 42;
					}
				}
				WorldGen.setBG(3, WorldGen.snowBG);
			}
			else
			{
				switch (Main.setting.SnowStyle)
				{
					case 5:
						WorldGen.setBG(3, 21);
						break;
					case 6:
						WorldGen.setBG(3, 22);
						break;
					case 7:
						WorldGen.setBG(3, 31);
						break;
					case 8:
						WorldGen.setBG(3, 32);
						break;
					case 9:
						WorldGen.setBG(3, 41);
						break;
					case 10:
						WorldGen.setBG(3, 42);
						break;
					default:
						WorldGen.setBG(3, Main.setting.SnowStyle);
						break;
				}
			}
			if (Main.setting.HallowStyle == 2)
			{
				WorldGen.setBG(4, WorldGen.genRand.Next(2));
			}
			else
			{
				WorldGen.setBG(4, Main.setting.HallowStyle);
			}
			if (Main.setting.CrimsonStyle == 3)
			{
				WorldGen.setBG(5, WorldGen.genRand.Next(3));
			}
			else
			{
				WorldGen.setBG(5, Main.setting.CrimsonStyle);
			}
			if (Main.setting.DesertStyle == 2)
			{
				WorldGen.setBG(6, WorldGen.genRand.Next(2));
			}
			else
			{
				WorldGen.setBG(6, Main.setting.DesertStyle);
			}
			if (Main.setting.OceanStyle == 3)
			{
				WorldGen.setBG(7, WorldGen.genRand.Next(3));
				return;
			}
			WorldGen.setBG(7, Main.setting.OceanStyle);
			/*
			if ((treeBG == 1 || treeBG == 2) && genRand.Next(2) == 0)
				treeBG = genRand.Next(7);

			if (treeBG == 0)
				treeBG = genRand.Next(7);

			if (treeBG == 3 && genRand.Next(3) == 0)
				treeBG = 31;

			if (treeBG == 5 && genRand.Next(2) == 0)
				treeBG = 51;

			if (treeBG == 7 && genRand.Next(4) == 0)
				treeBG = genRand.Next(71, 74);

			setBG(0, treeBG);
			setBG(1, genRand.Next(2));
			setBG(2, genRand.Next(2));
			snowBG = genRand.Next(6);
			if (snowBG == 2 && genRand.Next(2) == 0) {
				if (genRand.Next(2) == 0)
					snowBG = 21;
				else
					snowBG = 22;
			}

			if (snowBG == 3 && genRand.Next(2) == 0) {
				if (genRand.Next(2) == 0)
					snowBG = 31;
				else
					snowBG = 32;
			}

			if (snowBG == 4 && genRand.Next(2) == 0) {
				if (genRand.Next(2) == 0)
					snowBG = 41;
				else
					snowBG = 42;
			}

			setBG(3, snowBG);
			setBG(4, genRand.Next(2));
			setBG(5, genRand.Next(3));
			setBG(6, genRand.Next(2));
			setBG(7, genRand.Next(3));
			*/
		}

		public static void RandomizeTreeStyle() {
			if (Main.maxTilesX == 4200) {
				Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.25f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.25f)));
				Main.treeStyle[0] = genRand.Next(6);
				Main.treeStyle[1] = genRand.Next(6);
				while (Main.treeStyle[1] == Main.treeStyle[0]) {
					Main.treeStyle[1] = genRand.Next(6);
				}

				Main.treeX[1] = Main.maxTilesX;
				Main.treeX[2] = Main.maxTilesX;
				TerraCustom.TerraCustomUtils.FixTreeStyles();
				return;
			}

			if (Main.maxTilesX == 6400) {
				Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.334 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.667 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.treeStyle[0] = genRand.Next(6);
				Main.treeStyle[1] = genRand.Next(6);
				Main.treeStyle[2] = genRand.Next(6);
				while (Main.treeStyle[1] == Main.treeStyle[0]) {
					Main.treeStyle[1] = genRand.Next(6);
				}

				while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1]) {
					Main.treeStyle[2] = genRand.Next(6);
				}

				Main.treeX[2] = Main.maxTilesX;
				TerraCustom.TerraCustomUtils.FixTreeStyles();
				return;
			}

			Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.25 + (double)((float)Main.maxTilesX * 0.15f)));
			Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.15f)));
			Main.treeX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.75 + (double)((float)Main.maxTilesX * 0.15f)));
			Main.treeStyle[0] = genRand.Next(6);
			Main.treeStyle[1] = genRand.Next(6);
			Main.treeStyle[2] = genRand.Next(6);
			Main.treeStyle[3] = genRand.Next(6);
			while (Main.treeStyle[1] == Main.treeStyle[0]) {
				Main.treeStyle[1] = genRand.Next(6);
			}

			while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1]) {
				Main.treeStyle[2] = genRand.Next(6);
			}

			while (Main.treeStyle[3] == Main.treeStyle[0] || Main.treeStyle[3] == Main.treeStyle[1] || Main.treeStyle[3] == Main.treeStyle[2]) {
				Main.treeStyle[3] = genRand.Next(6);
			}
			TerraCustom.TerraCustomUtils.FixTreeStyles();
		}

		public static void RandomizeCaveBackgrounds() {
			int maxValue = 8;
			if (Main.maxTilesX == 4200) {
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.25f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.25f)));
				Main.caveBackX[1] = Main.maxTilesX;
				Main.caveBackX[2] = Main.maxTilesX;
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0]) {
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}
			}
			else if (Main.maxTilesX == 6400) {
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.334 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.667 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.caveBackX[2] = Main.maxTilesX;
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				Main.caveBackStyle[2] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0]) {
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}

				while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1]) {
					Main.caveBackStyle[2] = genRand.Next(maxValue);
				}
			}
			else {
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.25 + (double)((float)Main.maxTilesX * 0.15f)));
				Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.15f)));
				Main.caveBackX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.75 + (double)((float)Main.maxTilesX * 0.15f)));
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				Main.caveBackStyle[2] = genRand.Next(maxValue);
				Main.caveBackStyle[3] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0]) {
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}

				while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1]) {
					Main.caveBackStyle[2] = genRand.Next(maxValue);
				}

				while (Main.caveBackStyle[3] == Main.caveBackStyle[0] || Main.caveBackStyle[3] == Main.caveBackStyle[1] || Main.caveBackStyle[3] == Main.caveBackStyle[2]) {
					Main.caveBackStyle[3] = genRand.Next(maxValue);
				}
			}

			Main.iceBackStyle = genRand.Next(4);
			Main.hellBackStyle = genRand.Next(3);
			Main.jungleBackStyle = genRand.Next(2);
			Main.iceBackStyle = Main.setting.IceBackStyle == 0 ? Main.iceBackStyle : Main.setting.IceBackStyle - 1;
			Main.hellBackStyle = Main.setting.HellBackStyle == 0 ? Main.hellBackStyle : Main.setting.HellBackStyle - 1;
			Main.jungleBackStyle = Main.setting.JungleBackStyle == 0 ? Main.jungleBackStyle : Main.setting.JungleBackStyle - 1;
			Main.caveBackStyle[0] = Main.setting.CaveBackStyle1 == 0 ? Main.caveBackStyle[0] : Main.setting.CaveBackStyle1 - 1;
			Main.caveBackStyle[1] = Main.setting.CaveBackStyle2 == 0 ? Main.caveBackStyle[1] : Main.setting.CaveBackStyle2 - 1;
			Main.caveBackStyle[2] = Main.setting.CaveBackStyle3 == 0 ? Main.caveBackStyle[2] : Main.setting.CaveBackStyle3 - 1;
			Main.caveBackStyle[3] = Main.setting.CaveBackStyle4 == 0 ? Main.caveBackStyle[3] : Main.setting.CaveBackStyle4 - 1;
		}

		private static void ResetGenerator() {
			mudWall = false;
			hellChest = 0;
			JungleX = 0;
			numMCaves = 0;
			numIslandHouses = 0;
			houseCount = 0;
			dEnteranceX = 0;
			numDRooms = 0;
			numDDoors = 0;
			numDPlats = 0;
			numJChests = 0;
			JungleItemCount = 0;
		}

		public static bool mayanTrap(int x2, int y2) {
			int num = 1;
			if (genRand.Next(3) == 0)
				num = 0;

			int num2 = y2;
			while (!SolidTile(x2, num2)) {
				num2++;
				if (num2 >= Main.maxTilesY - 300)
					return false;
			}

			if (Main.tile[x2, num2].type == 232)
				return false;

			num2--;
			if (Main.tile[x2, num2].liquid > 0 && Main.tile[x2, num2].lava())
				return false;

			if (num == -1 && genRand.Next(20) == 0)
				num = 2;
			else if (num == -1)
				num = genRand.Next(2);

			if (Main.tile[x2, num2].nactive() || Main.tile[x2 - 1, num2].nactive() || Main.tile[x2 + 1, num2].nactive() || Main.tile[x2, num2 - 1].nactive() || Main.tile[x2 - 1, num2 - 1].nactive() || Main.tile[x2 + 1, num2 - 1].nactive() || Main.tile[x2, num2 - 2].nactive() || Main.tile[x2 - 1, num2 - 2].nactive() || Main.tile[x2 + 1, num2 - 2].nactive())
				return false;

			if (Main.tile[x2, num2 + 1].type == 48)
				return false;

			if (Main.tile[x2, num2 + 1].type == 232)
				return false;

			switch (num) {
				case 0: {
						int num12 = x2;
						int num13 = num2;
						num13 -= genRand.Next(3);
						while (!SolidTile(num12, num13)) {
							num12--;
						}

						int num14 = num12;
						for (num12 = x2; !SolidTile(num12, num13); num12++) {
						}

						int num15 = num12;
						int num16 = x2 - num14;
						int num17 = num15 - x2;
						bool flag = false;
						bool flag2 = false;
						if (num16 > 5 && num16 < 50)
							flag = true;

						if (num17 > 5 && num17 < 50)
							flag2 = true;

						if (flag && !SolidTile(num14, num13 + 1))
							flag = false;

						if (flag2 && !SolidTile(num15, num13 + 1))
							flag2 = false;

						if (flag && (Main.tile[num14, num13].type == 10 || Main.tile[num14, num13].type == 48 || Main.tile[num14, num13 + 1].type == 10 || Main.tile[num14, num13 + 1].type == 48))
							flag = false;

						if (flag2 && (Main.tile[num15, num13].type == 10 || Main.tile[num15, num13].type == 48 || Main.tile[num15, num13 + 1].type == 10 || Main.tile[num15, num13 + 1].type == 48))
							flag2 = false;

						int num18 = 0;
						if (flag && flag2) {
							num18 = 1;
							num12 = num14;
							if (genRand.Next(2) == 0) {
								num12 = num15;
								num18 = -1;
							}
						}
						else if (flag2) {
							num12 = num15;
							num18 = -1;
						}
						else {
							if (!flag)
								return false;

							num12 = num14;
							num18 = 1;
						}

						if (Main.tile[num12, num13].wall != 87)
							return false;

						if (Main.tile[num12, num13].type == 190)
							return false;

						if (Main.tile[num12, num13].type == 135)
							return false;

						if (Main.tile[num12, num13].type == 137)
							return false;

						if (Main.tile[num12, num13].type == 232)
							return false;

						PlaceTile(x2, num2, 135, mute: true, forced: true, -1, 6);
						KillTile(num12, num13);
						int num19 = genRand.Next(3);
						if (Main.tile[x2, num2].wire())
							num19 = 0;

						if (Main.tile[x2, num2].wire2())
							num19 = 1;

						if (Main.tile[x2, num2].wire3())
							num19 = 2;

						int num20 = Math.Abs(num12 - x2);
						int style2 = 1;
						if (num20 < 10 && genRand.Next(3) != 0)
							style2 = 2;

						PlaceTile(num12, num13, 137, mute: true, forced: true, -1, style2);
						if (num18 == 1)
							Main.tile[num12, num13].frameX += 18;

						int num21 = genRand.Next(5);
						int num22 = num13;
						while (num21 > 0) {
							num21--;
							num22--;
							if (!SolidTile(num12, num22) || !SolidTile(num12 - num18, num22) || SolidTile(num12 + num18, num22))
								break;

							PlaceTile(num12, num22, 137, mute: true, forced: true, -1, style2);
							if (num18 == 1)
								Main.tile[num12, num22].frameX += 18;

							switch (num19) {
								case 0:
									Main.tile[num12, num22].wire(wire: true);
									break;
								case 1:
									Main.tile[num12, num22].wire2(wire2: true);
									break;
								case 2:
									Main.tile[num12, num22].wire3(wire3: true);
									break;
							}
						}

						int num23 = x2;
						int num24 = num2;
						while (num23 != num12 || num24 != num13) {
							switch (num19) {
								case 0:
									Main.tile[num23, num24].wire(wire: true);
									break;
								case 1:
									Main.tile[num23, num24].wire2(wire2: true);
									break;
								case 2:
									Main.tile[num23, num24].wire3(wire3: true);
									break;
							}

							if (num23 > num12)
								num23--;

							if (num23 < num12)
								num23++;

							switch (num19) {
								case 0:
									Main.tile[num23, num24].wire(wire: true);
									break;
								case 1:
									Main.tile[num23, num24].wire2(wire2: true);
									break;
								case 2:
									Main.tile[num23, num24].wire3(wire3: true);
									break;
							}

							if (num24 > num13)
								num24--;

							if (num24 < num13)
								num24++;

							switch (num19) {
								case 0:
									Main.tile[num23, num24].wire(wire: true);
									break;
								case 1:
									Main.tile[num23, num24].wire2(wire2: true);
									break;
								case 2:
									Main.tile[num23, num24].wire3(wire3: true);
									break;
							}
						}

						return true;
					}
				case 1: {
						int num3 = x2;
						int num4 = num2;
						while (!SolidTile(num3, num4)) {
							num4--;
							if ((double)num4 < Main.worldSurface)
								return false;
						}

						int num5 = Math.Abs(num4 - num2);
						if (num5 < 3)
							return false;

						int num6 = genRand.Next(3);
						if (Main.tile[x2, num2].wire())
							num6 = 0;

						if (Main.tile[x2, num2].wire2())
							num6 = 1;

						if (Main.tile[x2, num2].wire3())
							num6 = 2;

						int style = 3;
						if (num5 < 16 && genRand.Next(3) != 0)
							style = 4;

						if (Main.tile[num3, num4].type == 135)
							return false;

						if (Main.tile[num3, num4].type == 137)
							return false;

						if (Main.tile[num3, num4].type == 232)
							return false;

						if (Main.tile[num3, num4].wall != 87)
							return false;

						PlaceTile(x2, num2, 135, mute: true, forced: true, -1, 6);
						PlaceTile(num3, num4, 137, mute: true, forced: true, -1, style);
						for (int i = 0; i < 2; i++) {
							int num7 = genRand.Next(1, 5);
							int num8 = num3;
							int num9 = -1;
							if (i == 1)
								num9 = 1;

							while (num7 > 0) {
								num7--;
								num8 += num9;
								if (!SolidTile(num8, num4 - 1) || SolidTile(num8, num4 + 1))
									break;

								PlaceTile(num8, num4, 137, mute: true, forced: true, -1, style);
								switch (num6) {
									case 0:
										Main.tile[num8, num4].wire(wire: true);
										break;
									case 1:
										Main.tile[num8, num4].wire2(wire2: true);
										break;
									case 2:
										Main.tile[num8, num4].wire3(wire3: true);
										break;
								}
							}
						}

						int num10 = x2;
						int num11 = num2;
						while (num10 != num3 || num11 != num4) {
							switch (num6) {
								case 0:
									Main.tile[num10, num11].wire(wire: true);
									break;
								case 1:
									Main.tile[num10, num11].wire2(wire2: true);
									break;
								case 2:
									Main.tile[num10, num11].wire3(wire3: true);
									break;
							}

							if (num10 > num3)
								num10--;

							if (num10 < num3)
								num10++;

							switch (num6) {
								case 0:
									Main.tile[num10, num11].wire(wire: true);
									break;
								case 1:
									Main.tile[num10, num11].wire2(wire2: true);
									break;
								case 2:
									Main.tile[num10, num11].wire3(wire3: true);
									break;
							}

							if (num11 > num4)
								num11--;

							if (num11 < num4)
								num11++;

							switch (num6) {
								case 0:
									Main.tile[num10, num11].wire(wire: true);
									break;
								case 1:
									Main.tile[num10, num11].wire2(wire2: true);
									break;
								case 2:
									Main.tile[num10, num11].wire3(wire3: true);
									break;
							}
						}

						return true;
					}
				default:
					return false;
			}
		}

		// type: -1: random
		// 0: 19/40, Dart
		// 1: 19/40, Boulder // If snow/ice, change to dart
		// 2: 1/20 Explosives
		// 3: Below Lava: 5/6 Geyser
		public static bool placeTrap(int x2, int y2, int type = -1) {
			int inType = type;
			int wireType = WorldGen.genRand.Next(3);
			if (Main.setting.SmartTrapsOff == true)
			{
				wireType = 0;
			}
			Tile.WireTypeOverride = wireType;
			int num = y2;
			bool flag = false;
			bool flag2 = false;
			while (!SolidTile(x2, num)) {
				num++;
				if (num >= Main.maxTilesY - 300)
					flag2 = true;
			}

			num--;
			if (Main.tile[x2, num].wall == 87)
				return false;

			if (Main.tile[x2, num].liquid > 0 && Main.tile[x2, num].lava())
				flag = true;

			if (type == -1 && genRand.Next(20) == 0)
				type = 2;
			else if (type == -1 && num > lavaLine + 30 && genRand.Next(6) != 0)
				type = 3;
			else if (type == -1)
				type = genRand.Next(2);

			if (!InWorld(x2, num, 3))
				return false;

			if (flag && type != 3)
				return false;

			if (flag2 && type != 3)
				return false;

			if (Main.tile[x2, num].nactive() || Main.tile[x2 - 1, num].nactive() || Main.tile[x2 + 1, num].nactive() || Main.tile[x2, num - 1].nactive() || Main.tile[x2 - 1, num - 1].nactive() || Main.tile[x2 + 1, num - 1].nactive() || Main.tile[x2, num - 2].nactive() || Main.tile[x2 - 1, num - 2].nactive() || Main.tile[x2 + 1, num - 2].nactive())
				return false;

			if (Main.tile[x2, num + 1].type == 48)
				return false;

			if (Main.tile[x2, num + 1].type == 232)
				return false;

			if (type == 1) {
				for (int i = x2 - 3; i <= x2 + 3; i++) {
					for (int j = num - 3; j <= num + 3; j++) {
						if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161)
							type = 0; // change 1 to 0 if snow or ice block around
					}
				}
			}

			switch (type) {
				case 0: {
						int num15 = x2;
						int num16 = num;
						num16 -= genRand.Next(3);
						while (!SolidTile(num15, num16) && num15 > 0 && num15 < Main.maxTilesX) {
							num15--;
						}

						int num17 = num15;
						for (num15 = x2; !SolidTile(num15, num16) && num15 > 0 && num15 < Main.maxTilesX; num15++) {
						}

						if (!SolidTile(num17, num16) || !SolidTile(num15, num16)) {
							return false;
						}

						int num18 = num15;
						int num19 = x2 - num17;
						int num20 = num18 - x2;
						bool flag4 = false;
						bool flag5 = false;
						if (num19 > 5 && num19 < 50)
							flag4 = true;

						if (num20 > 5 && num20 < 50)
							flag5 = true;

						if (flag4 && !SolidTile(num17, num16 + 1))
							flag4 = false;

						if (flag5 && !SolidTile(num18, num16 + 1))
							flag5 = false;

						if (flag4 && (Main.tile[num17, num16].type == 10 || Main.tile[num17, num16].type == 48 || Main.tile[num17, num16 + 1].type == 10 || Main.tile[num17, num16 + 1].type == 48))
							flag4 = false;

						if (flag5 && (Main.tile[num18, num16].type == 10 || Main.tile[num18, num16].type == 48 || Main.tile[num18, num16 + 1].type == 10 || Main.tile[num18, num16 + 1].type == 48))
							flag5 = false;

						int num21 = 0;
						if (flag4 && flag5) {
							num21 = 1;
							num15 = num17;
							if (genRand.Next(2) == 0) {
								num15 = num18;
								num21 = -1;
							}
						}
						else if (flag5) {
							num15 = num18;
							num21 = -1;
						}
						else {
							if (!flag4) {
								trapDiag[type, 0]++;
								return false;
							}

							num15 = num17;
							num21 = 1;
						}

						if (Main.tile[num15, num16].type == 190) {
							trapDiag[type, 0]++;
							return false;
						}

						if (Main.tile[x2, num].wall > 0)
							PlaceTile(x2, num, 135, mute: true, forced: true, -1, 2);
						else
							PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));

						KillTile(num15, num16);
						PlaceTile(num15, num16, 137, mute: true, forced: true);
						if (num21 == 1)
							Main.tile[num15, num16].frameX += 18;

						int num22 = x2;
						int num23 = num;
						while (num22 != num15 || num23 != num16) {
							Main.tile[num22, num23].wire(wire: true);
							if (num22 > num15)
								num22--;

							if (num22 < num15)
								num22++;

							Main.tile[num22, num23].wire(wire: true);
							if (num23 > num16)
								num23--;

							if (num23 < num16)
								num23++;

							Main.tile[num22, num23].wire(wire: true);
						}

						trapDiag[type, 1]++;
						return true;
					}
				case 1: {
						int num32 = x2;
						int num33 = num - 8;
						num32 += genRand.Next(-1, 2);
						bool flag6 = true;
						while (flag6) {
							bool flag7 = true;
							int num34 = 0;
							for (int num35 = num32 - 2; num35 <= num32 + 3; num35++) {
								for (int num36 = num33; num36 <= num33 + 3; num36++) {
									if (!SolidTile(num35, num36))
										flag7 = false;

									if (Main.tile[num35, num36].active() && (Main.tile[num35, num36].type == 0 || Main.tile[num35, num36].type == 1 || Main.tile[num35, num36].type == 59))
										num34++;
								}
							}

							num33--;
							if ((double)num33 < Main.worldSurface) {
								trapDiag[type, 0]++;
								return false;
							}

							if (flag7 && num34 > 2)
								flag6 = false;
						}

						if (num - num33 <= 5 || num - num33 >= 40) {
							trapDiag[type, 0]++;
							return false;
						}

						for (int num37 = num32; num37 <= num32 + 1; num37++) {
							for (int num38 = num33; num38 <= num; num38++) {
								if (SolidTile(num37, num38))
									KillTile(num37, num38);
							}
						}

						for (int num39 = num32 - 2; num39 <= num32 + 3; num39++) {
							for (int num40 = num33 - 2; num40 <= num33 + 3; num40++) {
								if (SolidTile(num39, num40))
									Main.tile[num39, num40].type = 1;
							}
						}

						PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
						PlaceTile(num32, num33 + 2, 130, mute: true);
						PlaceTile(num32 + 1, num33 + 2, 130, mute: true);
						PlaceTile(num32 + 1, num33 + 1, 138, mute: true);
						num33 += 2;
						Main.tile[num32, num33].wire(wire: true);
						Main.tile[num32 + 1, num33].wire(wire: true);
						num33++;
						PlaceTile(num32, num33, 130, mute: true);
						PlaceTile(num32 + 1, num33, 130, mute: true);
						Main.tile[num32, num33].wire(wire: true);
						Main.tile[num32 + 1, num33].wire(wire: true);
						PlaceTile(num32, num33 + 1, 130, mute: true);
						PlaceTile(num32 + 1, num33 + 1, 130, mute: true);
						Main.tile[num32, num33 + 1].wire(wire: true);
						Main.tile[num32 + 1, num33 + 1].wire(wire: true);
						int num41 = x2;
						int num42 = num;
						while (num41 != num32 || num42 != num33) {
							Main.tile[num41, num42].wire(wire: true);
							if (num41 > num32)
								num41--;

							if (num41 < num32)
								num41++;

							Main.tile[num41, num42].wire(wire: true);
							if (num42 > num33)
								num42--;

							if (num42 < num33)
								num42++;

							Main.tile[num41, num42].wire(wire: true);
						}

						trapDiag[type, 1]++;
						return true;
					}
				case 2: {
						int num24 = genRand.Next(4, 7);
						int num25 = x2;
						num25 += genRand.Next(-1, 2);
						int num26 = num;
						for (int num27 = 0; num27 < num24; num27++) {
							num26++;
							if (!SolidTile(num25, num26)) {
								trapDiag[type, 0]++;
								return false;
							}
						}

						for (int num28 = num25 - 2; num28 <= num25 + 2; num28++) {
							for (int num29 = num26 - 2; num29 <= num26 + 2; num29++) {
								if (!SolidTile(num28, num29))
									return false;
							}
						}

						KillTile(num25, num26);
						Main.tile[num25, num26].active(active: true);
						Main.tile[num25, num26].type = 141;
						Main.tile[num25, num26].frameX = 0;
						Main.tile[num25, num26].frameY = (short)(18 * genRand.Next(2));
						PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
						int num30 = x2;
						int num31 = num;
						while (num30 != num25 || num31 != num26) {
							Main.tile[num30, num31].wire(wire: true);
							if (num30 > num25)
								num30--;

							if (num30 < num25)
								num30++;

							Main.tile[num30, num31].wire(wire: true);
							if (num31 > num26)
								num31--;

							if (num31 < num26)
								num31++;

							Main.tile[num30, num31].wire(wire: true);
						}

						trapDiag[type, 1]++;
						break;
					}
				case 3: {
						int num2 = 0;
						int num3 = 0;
						for (int k = 0; k < 4; k++) {
							if (num2 < 2 && genRand.Next(5) == 0) {
								num2++;
								continue;
							}

							int num4 = x2;
							int num5 = num;
							bool flag3 = false;
							num4 = ((num3 != 0) ? (num4 + genRand.Next(-15, 16)) : (num4 + genRand.Next(-1, 2)));
							int num6 = genRand.Next(3, 6 + (num3 > 0).ToInt() * 3);
							for (int l = 0; l < num6; l++) {
								num5++;
								if (!SolidTile(num4, num5)) {
									trapDiag[type, 0]++;
									flag3 = true;
									break;
								}
							}

							if (flag3)
								continue;

							int num7 = 2;
							for (int m = num4 - num7; m <= num4 + num7; m++) {
								for (int n = num5 - num7; n <= num5 + num7; n++) {
									if (!SolidTile(m, n)) {
										trapDiag[type, 0]++;
										flag3 = true;
										break;
									}
								}

								if (flag3)
									break;
							}

							if (flag3)
								continue;

							num7 = 10;
							for (int num8 = num4; num8 <= num4 + 1; num8++) {
								int num9 = num5;
								while (num9 > num5 - 20 && SolidTile(num8, num9)) {
									num9--;
								}

								for (int num10 = num9 - num7; num10 <= num9; num10++) {
									if (SolidTile(num8, num10)) {
										trapDiag[type, 0]++;
										flag3 = true;
										break;
									}
								}

								if (flag3)
									break;
							}

							if (flag3)
								continue;

							KillTile(num4, num5);
							KillTile(num4 + 1, num5);
							int num11 = genRand.Next(2);
							for (int num12 = 0; num12 < 2; num12++) {
								Main.tile[num4 + num12, num5].active(active: true);
								Main.tile[num4 + num12, num5].type = 443;
								Main.tile[num4 + num12, num5].frameX = (short)(18 * num12 + 36 * num11);
								Main.tile[num4 + num12, num5].frameY = 0;
							}

							PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
							int num13 = x2;
							int num14 = num;
							while (num13 != num4 || num14 != num5) {
								Main.tile[num13, num14].wire(wire: true);
								if (num13 > num4)
									num13--;

								if (num13 < num4)
									num13++;

								Main.tile[num13, num14].wire(wire: true);
								if (num14 > num5)
									num14--;

								if (num14 < num5)
									num14++;

								Main.tile[num13, num14].wire(wire: true);
							}

							num3++;
							trapDiag[type, 1]++;
						}

						break;
					}
			}

			return false;
		}

		public static int countTiles(int x, int y, bool jungle = false, bool lavaOk = false) {
			numTileCount = 0;
			lavaCount = 0;
			iceCount = 0;
			rockCount = 0;
			nextCount(x, y, jungle, lavaOk);
			return numTileCount;
		}

		public static void nextCount(int x, int y, bool jungle = false, bool lavaOk = false) {
			if (numTileCount >= maxTileCount)
				return;

			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1) {
				numTileCount = maxTileCount;
				return;
			}

			for (int i = 0; i < numTileCount; i++) {
				if (countX[i] == x && countY[i] == y)
					return;
			}

			if (!jungle) {
				if (Main.tile[x, y].wall != 0) {
					numTileCount = maxTileCount;
					return;
				}

				if (!lavaOk) {
					if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0) {
						lavaCount++;
						numTileCount = maxTileCount;
						return;
					}
				}
				else if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0) {
					lavaCount++;
				}
			}

			if (Main.tile[x, y].active()) {
				if (Main.tile[x, y].type == 1)
					rockCount++;

				if (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161)
					iceCount++;
			}

			if (!SolidTile(x, y)) {
				countX[numTileCount] = x;
				countY[numTileCount] = y;
				numTileCount++;
				nextCount(x - 1, y, jungle, lavaOk);
				nextCount(x + 1, y, jungle, lavaOk);
				nextCount(x, y - 1, jungle, lavaOk);
				nextCount(x, y + 1, jungle, lavaOk);
			}
		}

		public static int countDirtTiles(int x, int y) {
			numTileCount = 0;
			nextDirtCount(x, y);
			return numTileCount;
		}

		public static void nextDirtCount(int x, int y) {
			if (numTileCount >= maxTileCount)
				return;

			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1) {
				numTileCount = maxTileCount;
				return;
			}

			for (int i = 0; i < numTileCount; i++) {
				if (countX[i] == x && countY[i] == y)
					return;
			}

			if (Main.tile[x, y].active() && (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161)) {
				numTileCount = maxTileCount;
			}
			else if (Main.tile[x, y].wall == 78 || Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3) {
				numTileCount = maxTileCount;
			}
			else if (!SolidTile(x, y) && (Main.tile[x, y].wall == 2 || Main.tile[x, y].wall == 59)) {
				countX[numTileCount] = x;
				countY[numTileCount] = y;
				numTileCount++;
				nextDirtCount(x - 1, y);
				nextDirtCount(x + 1, y);
				nextDirtCount(x, y - 1);
				nextDirtCount(x, y + 1);
				nextDirtCount(x - 1, y - 1);
				nextDirtCount(x - 1, y + 1);
				nextDirtCount(x + 1, y - 1);
				nextDirtCount(x + 1, y + 1);
				nextDirtCount(x - 2, y);
				nextDirtCount(x + 2, y);
			}
		}

		public static bool InWorld(int x, int y, int fluff = 0) {
			if (x < fluff || x >= Main.maxTilesX - fluff || y < fluff || y >= Main.maxTilesY - fluff)
				return false;

			return true;
		}

		public static bool InWorldY(int y, int fluff = 0)
		{
			return y >= fluff && y < Main.maxTilesY - fluff;
		}
		public static void gemCave(int x, int y) {
			countTiles(x, y);
			for (int i = 0; i < 6; i++) {
				gem[i] = false;
			}

			gem[genRand.Next(6)] = true;
			for (int j = 0; j < 6; j++) {
				if (genRand.Next(6) == 0)
					gem[j] = true;
			}

			Spread.Gem(x, y);
		}

		public static int randGem() {
			int num = genRand.Next(6);
			while (!gem[num]) {
				num = genRand.Next(6);
			}

			return num;
		}

		public static ushort randGemTile() {
			if (genRand.Next(20) != 0)
				return 1;

			switch ((ushort)randGem()) {
				case 0:
					return 67;
				case 1:
					return 66;
				case 2:
					return 63;
				case 3:
					return 65;
				case 4:
					return 64;
				default:
					return 68;
			}
		}

		public static void randMoss() {
			mossType[0] = genRand.Next(5);
			mossType[1] = genRand.Next(5);
			while (mossType[1] == mossType[0]) {
				mossType[1] = genRand.Next(5);
			}

			mossType[2] = genRand.Next(5);
			while (mossType[2] == mossType[0] || mossType[2] == mossType[1]) {
				mossType[2] = genRand.Next(5);
			}
			TerraCustom.TerraCustomUtils.FixMossStyles();
		}

		public static void setMoss(int x, int y) {
			int num = 0;
			num = ((!((double)x < (double)Main.maxTilesX * 0.334)) ? (((double)x < (double)Main.maxTilesX * 0.667) ? 1 : 2) : 0);
			mossWall = (byte)(54 + mossType[num]);
			mossTile = (byte)(179 + mossType[num]);
		}

		public static void tileCountAndDestroy() {
			for (int i = 10; i < Main.maxTilesX - 10; i++) {
				for (int j = 10; j < Main.maxTilesY - 10; j++) {
					if (Main.tile[i, j].active() && tileCounter(i, j) < tileCounterMax)
						tileCounterKill();
				}
			}
		}

		public static int tileCounter(int x, int y) {
			tileCounterNum = 0;
			tileCounterNext(x, y);
			return tileCounterNum;
		}

		public static void tileCounterNext(int x, int y) {
			if (tileCounterNum >= tileCounterMax || x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5 || !Main.tile[x, y].active() || !Main.tileSolid[Main.tile[x, y].type] || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, y].type])
				return;

			for (int i = 0; i < tileCounterNum; i++) {
				if (tileCounterX[i] == x && tileCounterY[i] == y)
					return;
			}

			tileCounterX[tileCounterNum] = x;
			tileCounterY[tileCounterNum] = y;
			tileCounterNum++;
			tileCounterNext(x - 1, y);
			tileCounterNext(x + 1, y);
			tileCounterNext(x, y - 1);
			tileCounterNext(x, y + 1);
		}

		public static void tileCounterKill() {
			for (int i = 0; i < tileCounterNum; i++) {
				int num = tileCounterX[i];
				int num2 = tileCounterY[i];
				Main.tile[num, num2].active(active: false);
			}
		}

		private static void AddGenerationPass(string name, WorldGenLegacyMethod method) {
			_generator.Append(new PassLegacy(name, method));
		}

		private static void AddGenerationPass(string name, float weight, WorldGenLegacyMethod method) {
			_generator.Append(new PassLegacy(name, method, weight));
		}

		public static bool checkUnderground(int x, int y) {
			try {
				int num = 120;
				int num2 = 80;
				int num3 = 3;
				if ((double)y > Main.worldSurface + (double)num2)
					return true;

				if ((double)y < Main.worldSurface / 2.0)
					return false;

				int num4 = y - num2;
				int num5 = x - num / 2;
				int num6 = 0;
				if (num5 < 0)
					num5 = 0;

				if (num5 >= Main.maxTilesX - num)
					num5 = Main.maxTilesX - num - 1;

				for (int i = num5; i < num5 + num; i++) {
					for (int j = num4; j < num4 + num3; j++) {
						if (SolidTile(i, j) || Main.tile[x, y].wall > 0)
							num6++;
					}
				}

				if ((double)num6 >= (double)(num * num3) * 0.8)
					return true;
			}
			catch {
			}

			return false;
		}

		public static int GetNextJungleChestItem() {
			int result = 211;
			switch (JungleItemCount % 4) {
				case 0:
					result = 211;
					break;
				case 1:
					result = 212;
					break;
				case 2:
					result = 213;
					break;
				case 3:
					result = 964;
					break;
			}

			if (genRand.Next(50) == 0)
				result = 753;
			else if (genRand.Next(30) == 0)
				result = 2292;
			else if (genRand.Next(20) == 0)
				result = 3017;

			JungleItemCount++;
			return result;
		}

		public static void generateWorld(int seed, GenerationProgress customProgressObject = null) {
			Logging.Terraria.InfoFormat("Generating World: {0}", Main.ActiveWorldFileData.Name);
			Logging.Terraria.InfoFormat("Numerical Seed: {0}", seed);
			_lastSeed = seed;
			_generator = new WorldGenerator(seed);
			Main.rand = new UnifiedRandom(seed);
			MicroBiome.ResetAll();
			structures = new StructureMap();
			worldSurface = 0.0;
			worldSurfaceLow = 0.0;
			worldSurfaceHigh = 0.0;
			rockLayer = 0.0;
			rockLayerLow = 0.0;
			rockLayerHigh = 0.0;
			int copper = 7;
			int iron = 6;
			int silver = 9;
			int gold = 8;
			int dungeonSide = 0;
			int crimsonSide = 0;
			ushort jungleHut = (ushort)genRand.Next(5);
			int howFar = 0;
			int[] PyrX = null;
			int[] PyrY = null;
			int numPyr = 0;
			int[] snowMinX = new int[Main.maxTilesY];
			int[] snowMaxX = new int[Main.maxTilesY];
			int snowTop = 0;
			int snowBottom = 0;
			float dub2 = 0f;
			int skyLakes = 1;
			if (Main.maxTilesX > 8000)
				skyLakes++;

			if (Main.maxTilesX > 6000)
				skyLakes++;

			skyLakes = (int)Math.Ceiling((float)skyLakes * (float)Main.setting.SkyLakeMultiplier);

			for (int j = 0; j < hellChestItem.Length; j++) {
				bool flag = true;
				while (flag) {
					flag = false;
					hellChestItem[j] = genRand.Next(hellChestItem.Length);
					for (int k = 0; k < j; k++) {
						if (hellChestItem[k] == hellChestItem[j])
							flag = true;
					}
				}
			}

			WorldHooks.PreWorldGen();
			AddGenerationPass("Reset", delegate (GenerationProgress progress) {
				Liquid.ReInit();
				noTileActions = true;
				progress.Message = "";
				SetupStatueList();
				RandomizeWeather();
				Main.cloudAlpha = 0f;
				Main.maxRaining = 0f;
				WorldFile.tempMaxRain = 0f;
				Main.raining = false;
				heartCount = 0;
				Main.checkXMas();
				Main.checkHalloween();
				gen = true;
				ResetGenerator();
				numLarva = 0;
				int num706 = 86400;
				Main.slimeRainTime = -genRand.Next(num706 * 2, num706 * 3);
				Main.cloudBGActive = -genRand.Next(8640, 86400);
				CopperTierOre = 7;
				IronTierOre = 6;
				SilverTierOre = 9;
				GoldTierOre = 8;
				copperBar = 20;
				ironBar = 22;
				silverBar = 21;
				goldBar = 19;
				if (Main.setting.IsCopper == 0 || (Main.setting.IsCopper == 2 && genRand.Next(2) == 0)) {
					copper = 166;
					copperBar = 703;
					CopperTierOre = 166;
				}

				if (Main.setting.IsIron == 0 || (Main.setting.IsIron == 2 && genRand.Next(2) == 0)) {
					iron = 167;
					ironBar = 704;
					IronTierOre = 167;
				}

				if (Main.setting.IsSilver == 0 || (Main.setting.IsSilver == 2 && genRand.Next(2) == 0)) {
					silver = 168;
					silverBar = 705;
					SilverTierOre = 168;
				}

				if (Main.setting.IsGold == 0 || (Main.setting.IsGold == 2 && genRand.Next(2) == 0)) {
					gold = 169;
					goldBar = 706;
					GoldTierOre = 169;
				}
				if (Main.setting.IsCobalt == 0)
				{
					oreTier1 = 221;
				}
				else if (Main.setting.IsCobalt == 1)
				{
					oreTier1 = 107;//Terraria.ID.TileID.Cobalt
				}
				else
				{
					oreTier1 = -1;
				}
				if (Main.setting.IsMythril == 0)
				{
					oreTier2 = 222;
				}
				else if (Main.setting.IsMythril == 1)
				{
					oreTier2 = 108;
				}
				else
				{
					oreTier2 = -1;
				}
				if (Main.setting.IsAdaman == 0)
				{
					oreTier3 = 223;
				}
				else if (Main.setting.IsAdaman == 1)
				{
					oreTier3 = 111;
				}
				else
				{
					oreTier3 = -1;
				}

				crimson = (genRand.Next(2) == 0);
				if (WorldGenParam_Evil == 0)
					crimson = false;

				if (WorldGenParam_Evil == 1)
					crimson = true;

				jungleHut = (ushort)Main.setting.ShrineType;
				if (jungleHut == 0)
				{
					jungleHut = (ushort)WorldGen.genRand.Next(5);
				}
				else
				{
					jungleHut--;
				}
				if (jungleHut == 0)
				{
					jungleHut = 119;
				}
				else if (jungleHut == 1)
					jungleHut = 120;
				else if (jungleHut == 2)
					jungleHut = 158;
				else if (jungleHut == 3)
					jungleHut = 175;
				else if (jungleHut == 4)
					jungleHut = 45;
				else
					jungleHut = 45;
				switch (Main.setting.IsCorruption)
				{
					case 2:
					case 4:
						WorldGen.crimson = true;
						break;
					case 1:
					case 3:
						WorldGen.crimson = false;
						break;
				}
				Main.worldID = genRand.Next(int.MaxValue);
				RandomizeTreeStyle();
				RandomizeCaveBackgrounds();
				RandomizeBackgrounds();
				RandomizeMoonState();
				dungeonSide = ((genRand.Next(2) != 0) ? 1 : (-1));
				switch (Main.setting.DungeonSide)
				{
					case 1:
						dungeonSide = -1;
						break;
					case 2:
						dungeonSide = 1;
						break;
				}
				if (Main.setting.CrimsonCorruptionAvoidEachOther && (Main.setting.IsCorruption == 3 || Main.setting.IsCorruption == 4) && !Main.setting.CrimsonCorruptionAvoidJungle)
				{
					crimsonSide = ((WorldGen.genRand.Next(2) == 0) ? -1 : 1);
				}
			});

			AddGenerationPass("Terrain", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[0].Value;
				int num700 = 0;
				int num701 = 0;
				worldSurface = (double)Main.maxTilesY * Main.setting.SurfaceTerrainHeightMin; // 0.3
				worldSurface *= (double)genRand.Next(90, 110) * 0.005;
				rockLayer = worldSurface + (double)Main.maxTilesY * 0.2;
				rockLayer *= (double)genRand.Next(90, 110) * 0.01;
				worldSurfaceLow = worldSurface;
				worldSurfaceHigh = worldSurface;
				rockLayerLow = rockLayer;
				rockLayerHigh = rockLayer;
				double oldWorldSurface = worldSurface;
				for (int num702 = 0; num702 < Main.maxTilesX; num702++) {
					float value21 = (float)num702 / (float)Main.maxTilesX;
					progress.Set(value21);
					if (worldSurface < worldSurfaceLow)
						worldSurfaceLow = worldSurface;

					if (worldSurface > worldSurfaceHigh)
						worldSurfaceHigh = worldSurface;

					if (rockLayer < rockLayerLow)
						rockLayerLow = rockLayer;

					if (rockLayer > rockLayerHigh)
						rockLayerHigh = rockLayer;

					if (num701 <= 0) {
						num700 = genRand.Next(0, 5);
						num701 = genRand.Next(5, 40);
						if (num700 == 0)
							num701 *= (int)((double)genRand.Next(5, 30) * 0.2);
					}

					num701--;
					// randomness??
					// flatish near bigger middle
					if ((double)num702 > (double)Main.maxTilesX * 0.43 && (double)num702 < (double)Main.maxTilesX * 0.57 && num700 >= 3)
						if(!Main.setting.BypassSpawnAreaFlatness)
							num700 = genRand.Next(3);

					// flat near middle
					if ((double)num702 > (double)Main.maxTilesX * 0.47 && (double)num702 < (double)Main.maxTilesX * 0.53)
						if(!Main.setting.BypassSpawnAreaFlatness)
							num700 = 0;

					if (num700 == 0) { // +/- 1: 1/7th chance
						while (genRand.Next(0, 7) == 0) {
							worldSurface += genRand.Next(-1, 2);
						}
					}
					else if (num700 == 1) { // 1/4 chance -1(up) 1/10 chance down
						while (genRand.Next(0, 4) == 0) {
							worldSurface -= 1.0;
						}

						while (genRand.Next(0, 10) == 0) {
							worldSurface += 1.0;
						}
					}
					
					else if (num700 == 2) {
						// 1/10 chance -1(up) 1/4 chance down
						while (genRand.Next(0, 4) == 0) {
							worldSurface += 1.0;
						}

						while (genRand.Next(0, 10) == 0) {
							worldSurface -= 1.0;
						}
					}
					else if (num700 == 3) {
						//  1/2 chance -1(up) 1/6 chance down
						while (genRand.Next(0, 2) == 0) {
							worldSurface -= 1.0;
						}

						while (genRand.Next(0, 6) == 0) {
							worldSurface += 1.0;
						}
					}
					else if (num700 == 4) {
						// 1/5 chance -1(up) 1/2 chance down
						while (genRand.Next(0, 2) == 0) {
							worldSurface += 1.0;
						}

						while (genRand.Next(0, 5) == 0) {
							worldSurface -= 1.0;
						}
					}
					
					worldSurface = oldWorldSurface + ((worldSurface - oldWorldSurface) * Main.setting.SurfaceTerrainHeightMultiplier);
					double a = worldSurface - Math.Truncate(worldSurface);
					if (worldSurface < (double)Main.maxTilesY * Main.setting.SurfaceTerrainHeightMax) { // 0.17 prevent surface from going to high
						worldSurface = (double)Main.maxTilesY * Main.setting.SurfaceTerrainHeightMax;
						num701 = 0;
					}
					else if (worldSurface > (double)Main.maxTilesY * Main.setting.SurfaceTerrainHeightMin) { // 0.3 prevent surface from going too deep
						worldSurface = (double)Main.maxTilesY * Main.setting.SurfaceTerrainHeightMin;
						num701 = 0;
					}

					if ((num702 < 275 || num702 > Main.maxTilesX - 275) && worldSurface > (double)Main.maxTilesY * (Main.setting.SurfaceTerrainHeightMin - .05)) { // .25 prevent ocean from being too deep
						worldSurface = (double)Main.maxTilesY * (Main.setting.SurfaceTerrainHeightMin - .05);
						num701 = 1;
					}
					oldWorldSurface = worldSurface + a;

					while (genRand.Next(0, 3) == 0) {
						rockLayer += genRand.Next(-2, 3);
					}

					if (rockLayer < worldSurface + (double)Main.maxTilesY * 0.05)
						rockLayer += 1.0;

					if (rockLayer > worldSurface + (double)Main.maxTilesY * 0.35)
						rockLayer -= 1.0;

					for (int num703 = 0; (double)num703 < worldSurface; num703++) {
						// sky
						Main.tile[num702, num703].active(active: false);
						Main.tile[num702, num703].frameX = -1;
						Main.tile[num702, num703].frameY = -1;
					}

					for (int num704 = (int)worldSurface; num704 < Main.maxTilesY; num704++) {
						if ((double)num704 < rockLayer) {
							Main.tile[num702, num704].active(active: true);
							Main.tile[num702, num704].type = 0;
							Main.tile[num702, num704].frameX = -1;
							Main.tile[num702, num704].frameY = -1;
						}
						else {
							Main.tile[num702, num704].active(active: true);
							Main.tile[num702, num704].type = 1;
							Main.tile[num702, num704].frameX = -1;
							Main.tile[num702, num704].frameY = -1;
						}
					}
				}

				Main.worldSurface = worldSurfaceHigh + 25.0;
				Main.rockLayer = rockLayerHigh;
				double num705 = (int)((Main.rockLayer - Main.worldSurface) / 6.0) * 6;
				Main.rockLayer = Main.worldSurface + num705;
				waterLine = (int)(Main.rockLayer + (double)Main.maxTilesY) / 2;
				waterLine += genRand.Next(-100, 20);
				lavaLine = waterLine + genRand.Next(50, 80);
				// TODO, lava world, set lavaline to real high
			});

			AddGenerationPass("Tunnels", delegate {
				for (int num695 = 0; num695 < (int)((double)Main.maxTilesX * 0.0015 * Main.setting.SurfaceHorizontalTunnelsMultiplier); num695++) {
					int[] array = new int[10];
					int[] array2 = new int[10];
					int num696 = genRand.Next(450, Main.maxTilesX - 450);
					while ((float)num696 > (float)Main.maxTilesX * 0.45f && (float)num696 < (float)Main.maxTilesX * 0.55f) {
						num696 = genRand.Next(0, Main.maxTilesX);
					}

					int num697 = 0;
					for (int num698 = 0; num698 < 10; num698++) {
						for (num696 %= Main.maxTilesX; !Main.tile[num696, num697].active(); num697++) {
						}

						array[num698] = num696;
						array2[num698] = num697 - genRand.Next(11, 16);
						num696 += genRand.Next(5, 11);
					}

					for (int num699 = 0; num699 < 10; num699++) {
						TileRunner(array[num699], array2[num699], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, -2f, -0.3f);
						TileRunner(array[num699], array2[num699], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, 2f, -0.3f);
					}
				}
			});

			AddGenerationPass("Sand", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[1].Value;
				int num682 = genRand.Next((int)((double)Main.maxTilesX * 0.0008), (int)((double)Main.maxTilesX * 0.0025));
				num682 += 2;
				num682 = (int)(num682 * Main.setting.SandMultiplier);
				PyrX = new int[num682];
				PyrY = new int[num682];
				for (int num683 = 0; num683 < num682; num683++) {
					int num684 = genRand.Next(Main.maxTilesX);
					while ((float)num684 > (float)Main.maxTilesX * 0.4f && (float)num684 < (float)Main.maxTilesX * 0.6f) {
						num684 = genRand.Next(Main.maxTilesX);
					}

					int num685 = genRand.Next(35, 90);
					if (num683 == 1) {
						float num686 = Main.maxTilesX / 4200f;
						num685 += (int)((float)genRand.Next(20, 40) * num686);
					}

					if (genRand.Next(3) == 0)
						num685 *= 2;

					if (num683 == 1)
						num685 *= 2;

					int num687 = num684 - num685;
					num685 = genRand.Next(35, 90);
					if (genRand.Next(3) == 0)
						num685 *= 2;

					if (num683 == 1)
						num685 *= 2;

					int num688 = num684 + num685;
					if (num687 < 0)
						num687 = 0;

					if (num688 > Main.maxTilesX)
						num688 = Main.maxTilesX;

					switch (num683) {
						case 0:
							num687 = 0;
							num688 = genRand.Next(260, 300);
							if (dungeonSide == 1)
								num688 += 40;
							break;
						case 2:
							num687 = Main.maxTilesX - genRand.Next(260, 300);
							num688 = Main.maxTilesX;
							if (dungeonSide == -1)
								num687 -= 40;
							break;
					}

					int num689 = genRand.Next(50, 100);
					for (int num690 = num687; num690 < num688; num690++) {
						if (genRand.Next(2) == 0) {
							num689 += genRand.Next(-1, 2);
							if (num689 < 50)
								num689 = 50;

							if (num689 > 100)
								num689 = 100;
						}

						for (int num691 = 0; (double)num691 < Main.worldSurface; num691++) {
							if (Main.tile[num690, num691].active()) {
								if (Main.setting.IsPyramid == 2 || Main.setting.IsPyramid == 0) {
									if (num690 == (num687 + num688) / 2 && genRand.Next(6) == 0) {
										PyrX[numPyr] = num690;
										PyrY[numPyr] = num691;
										numPyr++;
									}
								}
								else if (Main.setting.IsPyramid == 1 && num690 == (num687 + num688) / 2) {
									PyrX[numPyr] = num690;
									PyrY[numPyr] = num691;
									numPyr++;
								}

								int num692 = num689;
								if (num690 - num687 < num692)
									num692 = num690 - num687;

								if (num688 - num690 < num692)
									num692 = num688 - num690;

								num692 += genRand.Next(5);
								for (int num693 = num691; num693 < num691 + num692; num693++) {
									if (num690 > num687 + genRand.Next(5) && num690 < num688 - genRand.Next(5))
										Main.tile[num690, num693].type = 53;
								}

								break;
							}
						}
					}
				}

				for (int num694 = 0; num694 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-06 * Main.setting.SandMultiplier); num694++) {
					// TODO sand ammount  TileID.Sand
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(15, 70), genRand.Next(20, 130), 53);
				}
			});

			AddGenerationPass("Mount Caves", delegate (GenerationProgress progress) {
				numMCaves = 0;
				progress.Message = Lang.gen[2].Value;
				for (int num675 = 0; num675 < (int)(((double)Main.maxTilesX * 0.0008) * (Main.setting.MountCaveMult)); num675++) {
					int num676 = 0;
					bool flag47 = false;
					bool flag48 = false;
					double GBMnum1 = (Main.setting.MountCaveArea * 0.25);
					int num677 = genRand.Next((int)((double)Main.maxTilesX * (0.5 - GBMnum1)), (int)((double)Main.maxTilesX * (0.5 + GBMnum1)));
					//int num677 = genRand.Next((int)((GBMnum1) - GBMnum1 * 0.5 * Main.setting.MountCaveArea), (int)((GBMnum1) - GBMnum1 * 0.5 * Main.setting.MountCaveArea));
					while (!flag48) {
						flag48 = true;
						while (num677 > Main.maxTilesX / 2 - 100 * Main.setting.MountCaveArea && num677 < Main.maxTilesX / 2 + 100 * Main.setting.MountCaveArea) {
							num677 = genRand.Next((int)((double)Main.maxTilesX * (0.5 - GBMnum1)), (int)((double)Main.maxTilesX * (0.5 + GBMnum1)));
							//num677 = genRand.Next((int)((GBMnum1) - GBMnum1 * 0.5 * Main.setting.MountCaveArea), (int)((GBMnum1) - GBMnum1 * 0.5 * Main.setting.MountCaveArea));
						}

						for (int num678 = 0; num678 < numMCaves; num678++) {
							if (num677 > mCaveX[num678] - 50 && num677 < mCaveX[num678] + 50) {
								num676++;
								flag48 = false;
								break;
							}
						}

						if (num676 >= 200) {
							flag47 = true;
							break;
						}
					}

					if (!flag47) {
						for (int num679 = 0; (double)num679 < Main.worldSurface; num679++) {
							if (Main.tile[num677, num679].active()) {
								for (int num680 = num677 - 50; num680 < num677 + 50; num680++) {
									for (int num681 = num679 - 25; num681 < num679 + 25; num681++) {
										if (num681 >= 0)
											if (Main.tile[num680, num681].active() && (Main.tile[num680, num681].type == 53 || Main.tile[num680, num681].type == 151 || Main.tile[num680, num681].type == 274))
												flag47 = true;
									}
								}

								if (!flag47) {
									Mountinater(num677, num679);
									mCaveX[numMCaves] = num677;
									mCaveY[numMCaves] = num679;
									numMCaves++;
									break;
								}
							}
						}
					}
				}
			});

			AddGenerationPass("Dirt Wall Backgrounds", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[3].Value;
				for (int num673 = 1; num673 < Main.maxTilesX - 1; num673++) {
					byte wall = 2;
					float value20 = (float)num673 / (float)Main.maxTilesX;
					progress.Set(value20);
					bool flag46 = false;
					howFar += genRand.Next(-1, 2);
					if (howFar < 0)
						howFar = 0;

					if (howFar > 10)
						howFar = 10;

					for (int num674 = 0; (double)num674 < Main.worldSurface + 10.0 && !((double)num674 > Main.worldSurface + (double)howFar); num674++) {
						if (Main.tile[num673, num674].active())
							wall = (byte)((Main.tile[num673, num674].type != 147) ? 2 : 40);

						if (flag46 && Main.tile[num673, num674].wall != 64)
							Main.tile[num673, num674].wall = wall;

						if (Main.tile[num673, num674].active() && Main.tile[num673 - 1, num674].active() && Main.tile[num673 + 1, num674].active() && Main.tile[num673, num674 + 1].active() && Main.tile[num673 - 1, num674 + 1].active() && Main.tile[num673 + 1, num674 + 1].active())
							flag46 = true;
					}
				}
			});

			AddGenerationPass("Rocks In Dirt", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[4].Value;
				for (int num668 = 0; num668 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num668++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow + 1), genRand.Next(4, 15), genRand.Next(5, 40), 1);
				}

				for (int num669 = 0; num669 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num669++) {
					int num670 = genRand.Next(0, Main.maxTilesX);
					int num671 = genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh + 1);
					if (!Main.tile[num670, num671 - 10].active())
						num671 = genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh + 1);

					TileRunner(num670, num671, genRand.Next(4, 10), genRand.Next(5, 30), 1);
				}

				for (int num672 = 0; num672 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0045); num672++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh + 1), genRand.Next(2, 7), genRand.Next(2, 23), 1);
				}
			});

			AddGenerationPass("Dirt In Rocks", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[5].Value;
				for (int num667 = 0; num667 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.005); num667++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 0);
				}
			});

			AddGenerationPass("Clay", delegate (GenerationProgress progress) {
				// TODO clay spawn
				if  (Main.setting.ClayMult <= 0) return;
				progress.Message = Lang.gen[6].Value;
				for (int num661 = 0; num661 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05 * Main.setting.ClayMult); num661++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow), genRand.Next(4, 14), genRand.Next(10, 50), 40);
				}

				for (int num662 = 0; num662 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 5E-05 * Main.setting.ClayMult); num662++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh + 1), genRand.Next(8, 14), genRand.Next(15, 45), 40);
				}

				for (int num663 = 0; num663 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05 * Main.setting.ClayMult); num663++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh + 1), genRand.Next(8, 15), genRand.Next(5, 50), 40);
				}

				for (int num664 = 5; num664 < Main.maxTilesX - 5; num664++) {
					for (int num665 = 1; (double)num665 < Main.worldSurface - 1.0; num665++) {
						if (Main.tile[num664, num665].active()) {
							for (int num666 = num665; num666 < num665 + 5; num666++) {
								if (Main.tile[num664, num666].type == 40)
									Main.tile[num664, num666].type = 0;
							}

							break;
						}
					}
				}
			});

			int i2;
			AddGenerationPass("Small Holes", delegate (GenerationProgress progress) {
				i2 = 0;
				progress.Message = Lang.gen[7].Value;
				if (Main.setting.DeepCaveMult <= 0) return;
				for (int num660 = 0; num660 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015 * Main.setting.DeepCaveMult); num660++) {
					float value19 = (float)((double)num660 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015 * Main.setting.DeepCaveMult));
					progress.Set(value19);
					int type9 = -1;
					if (genRand.Next(5) == 0)
						type9 = -2;

					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, Main.maxTilesY), genRand.Next(2, 5), genRand.Next(2, 20), type9);
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, Main.maxTilesY), genRand.Next(8, 15), genRand.Next(7, 30), type9);
				}
			});

			AddGenerationPass("Dirt Layer Caves", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[8].Value;
				if (Main.setting.SurfaceCaveMult <= 0) return;
				for (int num659 = 0; num659 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05 * Main.setting.SurfaceCaveMult); num659++) {
					float value18 = (float)((double)num659 / ((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05 * Main.setting.SurfaceCaveMult));
					progress.Set(value18);
					if (rockLayerHigh <= (double)Main.maxTilesY) {
						int type8 = -1;
						if (genRand.Next(6) == 0)
							type8 = -2;

						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceLow, (int)rockLayerHigh + 1), genRand.Next(5, 15), genRand.Next(30, 200), type8);
					}
				}
			});

			AddGenerationPass("Rock Layer Caves", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[9].Value;
				if (Main.setting.DeepCaveMult <= 0) return;
				for (int num658 = 0; num658 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013 * Main.setting.DeepCaveMult); num658++) {
					float value17 = (float)((double)num658 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013 * Main.setting.DeepCaveMult));
					progress.Set(value17);
					if (rockLayerHigh <= (double)Main.maxTilesY) {
						int type7 = -1;
						if (genRand.Next(10) == 0)
							type7 = -2;

						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerHigh, Main.maxTilesY), genRand.Next(6, 20), genRand.Next(50, 300), type7);
					}
				}
			});

			AddGenerationPass("Surface Caves", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[10].Value;
				if (Main.setting.SurfaceCaveMult <= 0) return;
				for (int num648 = 0; num648 < (int)((double)Main.maxTilesX * 0.002 * Main.setting.SurfaceCaveMult); num648++) {
					i2 = genRand.Next(0, Main.maxTilesX);
					while ((float)i2 > (float)Main.maxTilesX * 0.45f && (float)i2 < (float)Main.maxTilesX * 0.55f) {
						i2 = genRand.Next(0, Main.maxTilesX);
					}

					for (int num649 = 0; (double)num649 < worldSurfaceHigh; num649++) {
						if (Main.tile[i2, num649].active()) {
							TileRunner(i2, num649, genRand.Next(3, 6), genRand.Next(5, 50), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 1f);
							break;
						}
					}
				}

				for (int num650 = 0; num650 < (int)((double)Main.maxTilesX * 0.0007); num650++) {
					i2 = genRand.Next(0, Main.maxTilesX);
					while ((float)i2 > (float)Main.maxTilesX * 0.43f && (float)i2 < (float)Main.maxTilesX * 0.57f) {
						i2 = genRand.Next(0, Main.maxTilesX);
					}

					for (int num651 = 0; (double)num651 < worldSurfaceHigh; num651++) {
						if (Main.tile[i2, num651].active()) {
							TileRunner(i2, num651, genRand.Next(10, 15), genRand.Next(50, 130), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 2f);
							break;
						}
					}
				}

				for (int num652 = 0; num652 < (int)((double)Main.maxTilesX * 0.0003); num652++) {
					i2 = genRand.Next(0, Main.maxTilesX);
					while ((float)i2 > (float)Main.maxTilesX * 0.4f && (float)i2 < (float)Main.maxTilesX * 0.6f) {
						i2 = genRand.Next(0, Main.maxTilesX);
					}

					for (int num653 = 0; (double)num653 < worldSurfaceHigh; num653++) {
						if (Main.tile[i2, num653].active()) {
							TileRunner(i2, num653, genRand.Next(12, 25), genRand.Next(150, 500), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 4f);
							TileRunner(i2, num653, genRand.Next(8, 17), genRand.Next(60, 200), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 2f);
							TileRunner(i2, num653, genRand.Next(5, 13), genRand.Next(40, 170), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 2f);
							break;
						}
					}
				}

				for (int num654 = 0; num654 < (int)((double)Main.maxTilesX * 0.0004); num654++) {
					i2 = genRand.Next(0, Main.maxTilesX);
					while ((float)i2 > (float)Main.maxTilesX * 0.4f && (float)i2 < (float)Main.maxTilesX * 0.6f) {
						i2 = genRand.Next(0, Main.maxTilesX);
					}

					for (int num655 = 0; (double)num655 < worldSurfaceHigh; num655++) {
						if (Main.tile[i2, num655].active()) {
							TileRunner(i2, num655, genRand.Next(7, 12), genRand.Next(150, 250), -1, addTile: false, 0f, 1f, noYChange: true);
							break;
						}
					}
				}

				float num656 = Main.maxTilesX / 4200f;
				for (int num657 = 0; (float)num657 < 5f * num656; num657++) {
					try {
						if (Main.maxTilesY > 1000)
							Caverer(genRand.Next(100, Main.maxTilesX - 100), genRand.Next((int)Main.rockLayer, Main.maxTilesY - 400));
						else
							Caverer(genRand.Next(100, Main.maxTilesX - 100), genRand.Next((int)Main.rockLayer, Main.maxTilesY - 100));
					}
					catch {
					}
				}
			});

			AddGenerationPass("Slush Check", delegate (GenerationProgress progress) {
				if (Main.setting.NoSnow) return;
				progress.Message = Lang.gen[56].Value;
				snowTop = (int)Main.worldSurface;
				int num639 = genRand.Next(Main.maxTilesX);
				if (dungeonSide == 1) {
					while ((float)num639 < (float)Main.maxTilesX * 0.55f || (float)num639 > (float)Main.maxTilesX * 0.7f) {
						num639 = genRand.Next(Main.maxTilesX);
					}
				}
				else {
					while ((float)num639 < (float)Main.maxTilesX * 0.3f || (float)num639 > (float)Main.maxTilesX * 0.45f) {
						num639 = genRand.Next(Main.maxTilesX);
					}
				}

				int num640 = genRand.Next(50, 90);
				float num641 = Main.maxTilesX / 4200f;
				num640 += (int)((float)genRand.Next(20, 40) * num641);
				num640 += (int)((float)genRand.Next(20, 40) * num641);
				int num642 = (int)((num639 - num640) / (Main.setting.IceBiomeWidth));
				if (num642 > (num639 - num640))
				{
					num642 = num639 - num640;
				}
				num640 = genRand.Next(50, 90);
				num640 += (int)((float)genRand.Next(20, 40) * num641);
				num640 += (int)((float)genRand.Next(20, 40) * num641);
				int num643 = num639 + num640;
				if (num642 < 0)
					num642 = 0;

				if (num643 > Main.maxTilesX)
					num643 = Main.maxTilesX;

				int num644 = 10;
				int Ybase = WorldGen.lavaLine - 140;
				if (Main.setting.IceBiomeDepth == 2)
				{
					Ybase = WorldGen.lastMaxTilesY - 220;
				}
				if (Main.setting.IceBiomeDepth == 0) {
					Ybase = (int)Main.worldSurface + (int)(WorldGen.lastMaxTilesY / 24);
				}
				for (int num645 = 0; num645 <= Ybase; num645++) {
					num642 += (int)(genRand.Next(-4, 4) * Main.setting.IceBiomeWidth);
					num643 += (int)(genRand.Next(-3, 5) * Main.setting.IceBiomeWidth);
					num642 = Utils.Clamp(num642, 0, Main.maxTilesX);
					num643 = Utils.Clamp(num643, 0, Main.maxTilesX);
					snowMinX[num645] = num642;
					snowMaxX[num645] = num643;
					for (int num646 = num642; num646 < num643; num646++) {
						if (num645 < lavaLine - 140) {
							if (Main.tile[num646, num645].wall == 2)
								Main.tile[num646, num645].wall = 40;

							switch (Main.tile[num646, num645].type) {
								case 0:
								case 2:
								case 23:
								case 40:
								case 53:
									Main.tile[num646, num645].type = 147;
									break;
								case 1:
									Main.tile[num646, num645].type = 161;
									break;
							}
						}
						else {
							num644 += genRand.Next(-3, 4);
							if (genRand.Next(3) == 0) {
								num644 += genRand.Next(-4, 5);
								if (genRand.Next(3) == 0)
									num644 += genRand.Next(-6, 7);
							}

							if (num644 < 0)
								num644 = genRand.Next(3);
							else if (num644 > 50)
								num644 = 50 - genRand.Next(3);

							for (int num647 = num645; num647 < num645 + num644; num647++) {
								if (Main.tile[num646, num647].wall == 2)
									Main.tile[num646, num647].wall = 40;

								switch (Main.tile[num646, num647].type) {
									case 0:
									case 2:
									case 23:
									case 40:
									case 53:
										Main.tile[num646, num647].type = 147;
										break;
									case 1:
										Main.tile[num646, num647].type = 161;
										break;
								}
							}
						}
					}

					if (snowBottom < num645)
						snowBottom = num645;
				}
			});

			AddGenerationPass("Grass", delegate {
				for (int num636 = 0; num636 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.002 * Main.setting.grassMult); num636++) {
					int num637 = genRand.Next(1, Main.maxTilesX - 1);
					int num638 = genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh);
					if (num638 >= Main.maxTilesY)
						num638 = Main.maxTilesY - 2;

					if (Main.tile[num637 - 1, num638].active() && Main.tile[num637 - 1, num638].type == 0 && Main.tile[num637 + 1, num638].active() && Main.tile[num637 + 1, num638].type == 0 && Main.tile[num637, num638 - 1].active() && Main.tile[num637, num638 - 1].type == 0 && Main.tile[num637, num638 + 1].active() && Main.tile[num637, num638 + 1].type == 0) {
						Main.tile[num637, num638].active(active: true);
						Main.tile[num637, num638].type = 2;
					}

					num637 = genRand.Next(1, Main.maxTilesX - 1);
					num638 = genRand.Next(0, (int)worldSurfaceLow);
					if (num638 >= Main.maxTilesY)
						num638 = Main.maxTilesY - 2;

					if (Main.tile[num637 - 1, num638].active() && Main.tile[num637 - 1, num638].type == 0 && Main.tile[num637 + 1, num638].active() && Main.tile[num637 + 1, num638].type == 0 && Main.tile[num637, num638 - 1].active() && Main.tile[num637, num638 - 1].type == 0 && Main.tile[num637, num638 + 1].active() && Main.tile[num637, num638 + 1].type == 0) {
						Main.tile[num637, num638].active(active: true);
						Main.tile[num637, num638].type = 2;
					}
				}
			});

			AddGenerationPass("Jungle", delegate (GenerationProgress progress) {
				if (Main.setting.NoJungle) return;
				progress.Message = Lang.gen[11].Value;
				float num616 = Main.maxTilesX / 4200f;
				num616 *= 1.5f * Main.setting.JungleScale;
				int num617 = 0;
				float yStrength = (Main.maxTilesY / 4200f) * 3.5f * 1.5f; // num616 is xStrength
				float num618 = (float)genRand.Next(15, 30) * 0.01f;
				if (dungeonSide == -1) {
					num618 = 1f - num618;
					num617 = (int)((float)Main.maxTilesX * num618);
				}
				else {
					num617 = (int)((float)Main.maxTilesX * num618);
				}

				int num619 = (int)((double)Main.maxTilesY + Main.rockLayer) / 2;
				num617 += genRand.Next((int)(-100f * num616), (int)(101f * num616));
				num619 += genRand.Next((int)(-100f * yStrength), (int)(101f * yStrength));
				int num620 = num617;
				int num621 = num619;
				TileRunner(num617, num619, genRand.Next((int)(250f * num616), (int)(500f * num616)), genRand.Next(50, 150), 59, addTile: false, dungeonSide * 3);
				for (int num622 = 0; (float)num622 < 6f * num616 / Main.setting.JungleScale; num622++) { // TODO: Is this logic correct?
					TileRunner(num617 + genRand.Next(-(int)(125f * num616), (int)(125f * num616)), num619 + genRand.Next(-(int)(125f * yStrength), (int)(125f * yStrength)), genRand.Next(3, 7), genRand.Next(3, 8), genRand.Next(63, 65));
				}

				mudWall = true;
				progress.Set(0.15f);
				num617 += genRand.Next((int)(-250f * num616), (int)(251f * num616));
				num619 += genRand.Next((int)(-150f * yStrength), (int)(151f * yStrength));
				int num623 = num617;
				int num624 = num619;
				int num625 = num617;
				int num626 = num619;
				TileRunner(num617, num619, genRand.Next((int)(250f * num616), (int)(500f * num616)), genRand.Next(50, 150), 59);
				mudWall = false;
				for (int num627 = 0; (float)num627 < 6f * num616 / Main.setting.JungleScale; num627++) {
					TileRunner(num617 + genRand.Next(-(int)(125f * num616), (int)(125f * num616)), num619 + genRand.Next(-(int)(125f * yStrength), (int)(125f * yStrength)), genRand.Next(3, 7), genRand.Next(3, 8), genRand.Next(65, 67));
				}

				mudWall = true;
				progress.Set(0.3f);
				num617 += genRand.Next((int)(-400f * num616), (int)(401f * num616));
				num619 += genRand.Next((int)(-150f * yStrength), (int)(151f * yStrength));
				int num628 = num617;
				int num629 = num619;
				TileRunner(num617, num619, genRand.Next((int)(250f * num616), (int)(500f * num616)), genRand.Next(50, 150), 59, addTile: false, dungeonSide * -3);
				mudWall = false;
				for (int num630 = 0; (float)num630 < 6f * num616/ Main.setting.JungleScale; num630++) {
					TileRunner(num617 + genRand.Next(-(int)(125f * num616), (int)(125f * num616)), num619 + genRand.Next(-(int)(125f * yStrength), (int)(125f * yStrength)), genRand.Next(3, 7), genRand.Next(3, 8), genRand.Next(67, 69));
				}

				mudWall = true;
				progress.Set(0.45f);
				num617 = (num620 + num623 + num628) / 3;
				num619 = (num621 + num624 + num629) / 3;
				TileRunner(num617, num619, genRand.Next((int)(400f * num616), (int)(600f * num616)), 10000, 59, addTile: false, 0f, -20f, noYChange: true);
				JungleRunner(num617, num619);
				progress.Set(0.6f);
				mudWall = false;
				for (int num631 = 0; num631 < Main.maxTilesX / 4; num631++) {
					num617 = genRand.Next(20, Main.maxTilesX - 20);
					num619 = genRand.Next((int)worldSurface + 10, Main.maxTilesY - 200);
					while (Main.tile[num617, num619].wall != 64 && Main.tile[num617, num619].wall != 15) {
						num617 = genRand.Next(20, Main.maxTilesX - 20);
						num619 = genRand.Next((int)worldSurface + 10, Main.maxTilesY - 200);
					}

					MudWallRunner(num617, num619);
				}

				num617 = num625;
				num619 = num626;
				for (int num632 = 0; (float)num632 <= 20f * num616 / Main.setting.JungleScale; num632++) {
					progress.Set((60f + (float)num632 / num616) * 0.01f);
					num617 += genRand.Next((int)(-5f * num616), (int)(6f * num616));
					num619 += genRand.Next((int)(-5f * yStrength), (int)(6f * yStrength));
					TileRunner(num617, num619, genRand.Next(40, 100), genRand.Next(300, 500), 59);
				}

				for (int num633 = 0; (float)num633 <= 10f * num616 / Main.setting.JungleScale; num633++) {
					progress.Set((80f + (float)num633 / num616 * 2f / Main.setting.JungleScale) * 0.01f);
					num617 = num625 + genRand.Next((int)(-600f * num616), (int)(600f * num616));
					num619 = num626 + genRand.Next((int)(-200f * yStrength), (int)(200f * yStrength));
					while (num617 < 1 || num617 >= Main.maxTilesX - 1 || num619 < 1 || num619 >= Main.maxTilesY - 1 || Main.tile[num617, num619].type != 59) {
						num617 = num625 + genRand.Next((int)(-600f * num616), (int)(600f * num616));
						num619 = num626 + genRand.Next((int)(-200f * yStrength), (int)(200f * yStrength));
					}

					for (int num634 = 0; (float)num634 < 8f * num616 / Main.setting.JungleScale; num634++) {
						num617 += genRand.Next(-30, 31);
						num619 += genRand.Next(-30, 31);
						int type5 = -1;
						if (genRand.Next(7) == 0)
							type5 = -2;

						TileRunner(num617, num619, genRand.Next(10, 20), genRand.Next(30, 70), type5);
					}
				}

				for (int num635 = 0; (float)num635 <= 300f * num616 / Main.setting.JungleScale; num635++) {
					num617 = num625 + genRand.Next((int)(-600f * num616), (int)(600f * num616));
					num619 = num626 + genRand.Next((int)(-200f * yStrength), (int)(200f * yStrength));
					while (num617 < 1 || num617 >= Main.maxTilesX - 1 || num619 < 1 || num619 >= Main.maxTilesY - 1 || Main.tile[num617, num619].type != 59) {
						num617 = num625 + genRand.Next((int)(-600f * num616), (int)(600f * num616));
						num619 = num626 + genRand.Next((int)(-200f * yStrength), (int)(200f * yStrength));
					}

					TileRunner(num617, num619, genRand.Next(4, 10), genRand.Next(5, 30), 1);
					if (genRand.Next(4) == 0) {
						int type6 = genRand.Next(63, 69);
						TileRunner(num617 + genRand.Next(-1, 2), num619 + genRand.Next(-1, 2), genRand.Next(3, 7), genRand.Next(4, 8), type6);
					}
				}
			});

			AddGenerationPass("Marble", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[80].Value;
				float num611 = (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f;
				int num612 = (int)((float)genRand.Next(10, 15) * num611 * Main.setting.MarbleCaveMultiplier);
				float num613 = (float)(Main.maxTilesX - 160) / (float)num612;
				int num614 = 0;
				while (num614 < num612) {
					float num615 = (float)num614 / (float)num612;
					progress.Set(num615);
					if (Biomes<MarbleBiome>.Place(RandomRectanglePoint((int)(num615 * (float)(Main.maxTilesX - 160)) + 80, (int)rockLayer + 20, (int)num613, Main.maxTilesY - ((int)rockLayer + 40) - 200), structures))
						num614++;
				}
			});

			AddGenerationPass("Granite", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[81].Value;
				float num606 = (float)Main.maxTilesX / 4200f;
				int num607 = (int)((float)genRand.Next(8, 14) * num606 * Main.setting.GraniteCaveMultiplier);
				float num608 = (float)(Main.maxTilesX - 200) / (float)num607;
				int num609 = 0;
				while (num609 < num607) {
					float num610 = (float)num609 / (float)num607;
					progress.Set(num610);
					if (Biomes<GraniteBiome>.Place(RandomRectanglePoint((int)(num610 * (float)(Main.maxTilesX - 200)) + 100, (int)rockLayer + 20, (int)num608, Main.maxTilesY - ((int)rockLayer + 40) - 200), structures))
						num609++;
				}
			});

			AddGenerationPass("Mud Caves To Grass", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[77].Value;
				for (int num601 = 0; num601 < Main.maxTilesX; num601++) {
					for (int num602 = 0; num602 < Main.maxTilesY; num602++) {
						if (Main.tile[num601, num602].active()) {
							grassSpread = 0;
							SpreadGrass(num601, num602, 59, 60, repeat: true, 0);
							int GrassID = 60;
							if (Main.setting.SwapShroomJungle)
							{
								GrassID = 70;
							}
							WorldGen.SpreadGrass(num601, num602, 59, GrassID, repeat: true, 0);
						}

						progress.Set(0.2f * ((float)(num601 * Main.maxTilesY + num602) / (float)(Main.maxTilesX * Main.maxTilesY)));
					}
				}

				for (int num603 = 10; num603 < Main.maxTilesX - 10; num603++) {
					for (int num604 = 10; num604 < Main.maxTilesY - 10; num604++) {
						if (Main.tile[num603, num604].active() && tileCounter(num603, num604) < tileCounterMax)
							tileCounterKill();

						float num605 = (float)((num603 - 10) * (Main.maxTilesY - 20) + (num604 - 10)) / (float)((Main.maxTilesX - 20) * (Main.maxTilesY - 20));
						progress.Set(0.2f + num605 * 0.8f);
					}
				}
			});

			AddGenerationPass("Full Desert", delegate (GenerationProgress progress) {
				if (Main.setting.NoAnthill) return;
				progress.Message = Lang.gen[78].Value;
				int num597 = dungeonSide;
				int num598 = Main.maxTilesX / 2;
				int num599 = genRand.Next(num598) / 8;
				num599 += num598 / 8;
				int x12 = num598 + num599 * -num597;
				int num600 = 0;
				while (!Biomes<DesertBiome>.Place(new Point(x12, (int)worldSurface), structures)) {
					num599 = genRand.Next(num598) / 2;
					num599 += num598 / 8;
					x12 = num598 + num599 * -num597;
					if (++num600 > 1000) {
						num597 *= -1;
						num600 = 0;
					}
				}
			});
			// TODO Floating Island
			
			AddGenerationPass("Floating Islands", delegate (GenerationProgress progress) {
				//NIH = numIslandHouses;
				numIslandHouses = 0;
				houseCount = 0;
				//fihSX = fihX;
				//fihSY = fihY;
				//fihST = fihT;
				//fihX = new int[1000];
				//fihY = new int[1000];
				//fihT = new int[1000];
				//skyLake2 = skyLake;
				//skyLake = new bool[1000];
				progress.Message = Lang.gen[12].Value;
				for (int num591 = 0; num591 < (int)((double)Main.maxTilesX * 0.0008 * Main.setting.SkyIslandMultiplier) + skyLakes; num591++) {
					int num592 = 1000 * (int)Math.Floor(Main.setting.SkyIslandMultiplier);
					int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
					while (--num592 > 0) {
						bool flag45 = true;
						while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
							num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						}

						for (int num594 = 0; num594 < numIslandHouses; num594++) {
							if (num593 > fihX[num594] - 180 && num593 < fihX[num594] + 180) {
								flag45 = false;
								break;
							}
						}

						if (flag45) {
							flag45 = false;
							int num595 = 0;
							for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
								if (Main.tile[num593, num596].active()) {
									num595 = num596;
									flag45 = true;
									break;
								}
							}

							if (flag45) {
								int val = genRand.Next(90, num595 - 100);
								val = Math.Min(val, (int)worldSurfaceLow - 50);
								if (val < 30) continue;
								if (num591 < skyLakes) {
									skyLake[numIslandHouses] = true;
									CloudLake(num593, val);
								}
								else {
									try { WorldGen.CloudIsland(num593, val); } catch { }
								}

								fihX[numIslandHouses] = num593;
								fihY[numIslandHouses] = val;
								fihT[numIslandHouses] = 0;
								numIslandHouses++;
							}
						}
					}
				}
			//});

			//AddGenerationPass("Special Islands A", delegate (GenerationProgress progress) {
				//numIslandHouses = 0;
				//houseCount = 0;
				//int SnowCount = 0;
				progress.Message = "Sending Special Islands Into Orbit";
				if (Math.Floor(Main.setting.SnowIslands) > 0) {
					for (int num591 = 0; num591 < Math.Floor(Main.setting.SnowIslands); num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SnowIsland(num593, val); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(1 / 7);
				if (Math.Floor(Main.setting.SandIslands) > 0) {
					for (int num591 = 0; num591 < Math.Floor(Main.setting.SandIslands); num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 180 && num593 < fihX[num594] + 180) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SandIsland(num593, val); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(2 / 7);
				if (Math.Floor(Main.setting.JungleIslands) > 0) {
					for (int num591 = 0; num591 < Math.Floor(Main.setting.JungleIslands); num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SpecialIsland(num593, val, 59, 196, 1, 189, true, 60); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(3 / 7);
				if (Math.Floor(Main.setting.MushroomIslands) > 0) {
					for (int num591 = 0; num591 < Math.Floor(Main.setting.MushroomIslands); num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SpecialIsland(num593, val, 59, 196, 1, 189, true, 70); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(4 / 7);
				if (Math.Floor(Main.setting.RainIslands) > 0) {
					for (int num591 = 0; num591 < Math.Floor(Main.setting.RainIslands); num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SpecialIsland(num593, val, 0, 189, 1, 196, false, 70); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(5 / 7);
				if (Math.Floor(Main.setting.Snow2Islands) > 0) {
					for (int num591 = 0; num591 < Math.Floor(Main.setting.Snow2Islands); num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SpecialIsland(num593, val, 147, 189, 1, 460, false, 70); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(6 / 7);
				if (Math.Floor(Main.setting.UnderworldIslands) > 0) {
					for (int num591 = 0; num591 < Math.Floor(Main.setting.UnderworldIslands); num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SpecialIsland(num593, val, 57, 58, 2, 189, false, 70, 25); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 1;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(6 / 7);
				if (0 > 0) {
					for (int num591 = 0; num591 < 2; num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SpecialIsland(num593, val, 189, 196, 1, 189, false, 70, 0); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				progress.Set(6 / 7);
				if (0 > 0) {
					for (int num591 = 0; num591 < 2; num591++) {
						int num592 = 1000;
						int num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (--num592 > 0) {
							bool flag45 = true;
							while (num593 > Main.maxTilesX / 2 - 80 && num593 < Main.maxTilesX / 2 + 80) {
								num593 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}

							for (int num594 = 0; num594 < numIslandHouses; num594++) {
								if (num593 > fihX[num594] - 120 && num593 < fihX[num594] + 120) {
									flag45 = false;
									break;
								}
							}

							if (flag45) {
								flag45 = false;
								int num595 = 0;
								for (int num596 = 200; (double)num596 < Main.worldSurface; num596++) {
									if (Main.tile[num593, num596].active()) {
										num595 = num596;
										flag45 = true;
										break;
									}
								}

								if (flag45) {
									int val = genRand.Next(90, num595 - 100);
									val = Math.Min(val, (int)worldSurfaceLow - 50);
									if (val < 30) continue;
									//if (SnowCount < Math.Floor(Main.setting.SnowIslands)) {
									try { WorldGen.SpecialIsland(num593, val, 189, 189, 5, 189, false, 70, 0); } catch { }
									//}

									fihX[numIslandHouses] = num593;
									fihY[numIslandHouses] = val;
									fihT[numIslandHouses] = 0;
									numIslandHouses++;
								}
							}
						}
					}
				}
				//int P2 = 0; this is for something i wanted to do, i might make this into a setting eventually
				//for (int Pos = 0; Pos < 999; Pos++) {
				//	if (fihX[Pos] == 0) {
						//if (P2 == 0) {
							//P2 = Pos;
						//}
						//fihX[Pos] = fihSX[Pos - P2];
						//fihY[Pos] = fihSY[Pos - P2];
						//fihT[Pos] = fihST[Pos - P2];
						//skyLake[Pos] = skyLake2[Pos - P2];
					//}
				//}
				//numIslandHouses = numIslandHouses + NIH;
			});

			AddGenerationPass("Mushroom Patches", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[13].Value;
				for (int num575 = 0; num575 < Main.maxTilesX / 500 * Main.setting.MushroomBiomeMultiplier; num575++) {
					int num576 = 0;
					bool flag43 = true;
					while (flag43) {
						int num577 = genRand.Next((int)((double)Main.maxTilesX * 0.3), (int)((double)Main.maxTilesX * 0.7));
						int num578 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						if (Main.maxTilesY < 1000) num578 = WorldGen.genRand.Next((int)Main.rockLayer, Main.maxTilesY - 100);
						flag43 = false;
						int num579 = 60;
						for (int num580 = num577 - num579; num580 < num577 + num579; num580 += 3) {
							for (int num581 = num578 - num579; num581 < num578 + num579; num581 += 3) {
								if (Main.tile[num580, num581].type == 147 || Main.tile[num580, num581].type == 161 || Main.tile[num580, num581].type == 162) {
									flag43 = true;
									break;
								}

								if (UndergroundDesertLocation.Contains(new Point(num580, num581))) {
									flag43 = true;
									break;
								}
							}
						}

						if (!flag43)
							ShroomPatch(num577, num578);

						num576++;
						if (num576 > 100)
							break;
					}
				}

				for (int num582 = 0; num582 < Main.maxTilesX; num582++) {
					for (int num583 = (int)Main.worldSurface; num583 < Main.maxTilesY; num583++) {
						if (Main.tile[num582, num583].active()) {
							grassSpread = 0;
							int GrassID = 70;
							if (Main.setting.SwapShroomJungle) {
								GrassID = 60;
							}
							SpreadGrass(num582, num583, 59, GrassID, repeat: false, 0);
							if (Main.tile[num582, num583].type == 70 && genRand.Next(20) == 0) {
								int num584 = (genRand.Next(5) != 0) ? 1 : 2;
								int num585 = genRand.Next(2, 6);
								int num586 = num583 - num585;
								bool flag44 = true;
								for (int num587 = num582 - num584; num587 <= num582 + num584; num587++) {
									if (Main.tile[num587, num586].active())
										flag44 = false;

									if (Main.tileBrick[Main.tile[num587, num586 - 1].type])
										flag44 = false;

									if (Main.tileBrick[Main.tile[num587, num586 + 1].type])
										flag44 = false;
								}

								if (Main.tile[num582 - num584 - 1, num586].type == 190)
									flag44 = false;

								if (Main.tile[num582 + num584 + 1, num586].type == 190)
									flag44 = false;

								for (int num588 = num586; num588 < num583; num588++) {
									if (Main.tile[num582, num588].active())
										flag44 = false;

									if (Main.tileBrick[Main.tile[num582 - 1, num588].type])
										flag44 = false;

									if (Main.tileBrick[Main.tile[num582 + 1, num588].type])
										flag44 = false;
								}

								if (flag44) {
									for (int num589 = num582 - num584; num589 <= num582 + num584; num589++) {
										PlaceTile(num589, num586, 190, mute: true, forced: true);
									}

									for (int num590 = num586; num590 < num583; num590++) {
										PlaceTile(num582, num590, 190, mute: true, forced: true);
									}
								}
							}
						}
					}
				}
			});

			AddGenerationPass("Mud To Dirt", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[14].Value;
				for (int num574 = 0; num574 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.001); num574++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 59);
				}
			});

			AddGenerationPass("Silt", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[15].Value;
				for (int num572 = 0; num572 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0001 * Main.setting.SiltMultiplier); num572++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerHigh, Main.maxTilesY), genRand.Next(5, 12), genRand.Next(15, 50), 123);
				}

				for (int num573 = 0; num573 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0005 * Main.setting.SiltMultiplier); num573++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerHigh, Main.maxTilesY), genRand.Next(2, 5), genRand.Next(2, 5), 123);
				}
			});

			AddGenerationPass("Shinies", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[16].Value;
				for (int k = 0; k < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 6E-05 * Main.setting.PercCopp); k++)
					{
						if (Main.setting.IsCopper == 3) copper = WorldGen.genRand.NextBool() ? 7 : 166;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), copper);
				}

				for (int l = 0; l < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05 * Main.setting.PercCopp); l++)
					{
						if (Main.setting.IsCopper == 3) copper = WorldGen.genRand.NextBool() ? 7 : 166;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), copper);
				}

				for (int m = 0; m < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002 * Main.setting.PercCopp); m++)
					{
						if (Main.setting.IsCopper == 3) copper = WorldGen.genRand.NextBool() ? 7 : 166;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), copper);
				}

				for (int n = 0; n < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05 * Main.setting.PercIron); n++)
					{
						if (Main.setting.IsIron == 3) iron = WorldGen.genRand.NextBool() ? 6 : 167;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), iron);
				}

				for (int num = 0; num < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05 * Main.setting.PercIron); num++)
					{
						if (Main.setting.IsIron == 3) iron = WorldGen.genRand.NextBool() ? 6 : 167;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), iron);
				}

				for (int num2 = 0; num2 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002 * Main.setting.PercIron); num2++)
					{
						if (Main.setting.IsIron == 3) iron = WorldGen.genRand.NextBool() ? 6 : 167;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), iron);
				}

				for (int num3 = 0; num3 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05 * Main.setting.PercSilv); num3++)
					{
						if (Main.setting.IsSilver == 3) silver = WorldGen.genRand.NextBool() ? 9 : 168;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), silver);
				}

				for (int num4 = 0; num4 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015 * Main.setting.PercSilv); num4++)
					{
						if (Main.setting.IsSilver == 3) silver = WorldGen.genRand.NextBool() ? 9 : 168;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), silver);
				}

				for (int num5 = 0; num5 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017 * Main.setting.PercSilv); num5++)
					{
						if (Main.setting.IsSilver == 3) silver = WorldGen.genRand.NextBool() ? 9 : 168;
					STileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), silver);
				}

				for (int num6 = 0; num6 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012 * Main.setting.PercGold); num6++)
					{
						if (Main.setting.IsGold == 3) gold = WorldGen.genRand.NextBool() ? 8 : 169;
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 8), genRand.Next(4, 8), gold);
				}

				for (int num7 = 0; num7 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012 * Main.setting.PercGold); num7++)
					{
						if (Main.setting.IsGold == 3) gold = WorldGen.genRand.NextBool() ? 8 : 169;
					STileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), gold);
				}

				if ((WorldGen.crimson || Main.setting.IsCorruption == 3) && Main.setting.IsCorruption != 5)
					{
						for (int num8 = 0; num8 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05 * Main.setting.PercDemonite); num8++) {
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(2, 4), genRand.Next(3, 6), 204);
					}
				}
				if ((!WorldGen.crimson || Main.setting.IsCorruption == 4) && Main.setting.IsCorruption != 5) {
					for (int num9 = 0; num9 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05 * Main.setting.PercDemonite); num9++) {
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(2, 4), genRand.Next(3, 6), 22);
					}
				}
			});

			AddGenerationPass("Webs", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[17].Value;
				if (Main.setting.WebMult <= 0) return;
				for (int num555 = 0; num555 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0006 * Main.setting.WebMult); num555++) {
					int num556 = genRand.Next(20, Main.maxTilesX - 20);
					int num557 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY - 20);
					if (num555 < numMCaves) {
						num556 = mCaveX[num555];
						num557 = mCaveY[num555];
					}

					if (!Main.tile[num556, num557].active() && ((double)num557 > Main.worldSurface || Main.tile[num556, num557].wall > 0)) {
						while (!Main.tile[num556, num557].active() && num557 > (int)worldSurfaceLow) {
							num557--;
						}

						num557++;
						int num558 = 1;
						if (genRand.Next(2) == 0)
							num558 = -1;

						for (; !Main.tile[num556, num557].active() && num556 > 10 && num556 < Main.maxTilesX - 10; num556 += num558) {
						}

						num556 -= num558;
						if ((double)num557 > Main.worldSurface || Main.tile[num556, num557].wall > 0)
							TileRunner(num556, num557, genRand.Next(4, 11), genRand.Next(2, 4), 51, addTile: true, num558, -1f, noYChange: false, overRide: false);
					}
				}
			});

			AddGenerationPass("Underworld", delegate (GenerationProgress progress) {
				if (Main.setting.NoUnderworld) return;
				progress.Message = Lang.gen[18].Value;
				progress.Set(0f);
				int num540 = Main.maxTilesY - genRand.Next(150, 190);
				for (int num541 = 0; num541 < Main.maxTilesX; num541++) {
					num540 += genRand.Next(-3, 4);
					if (num540 < Main.maxTilesY - 190)
						num540 = Main.maxTilesY - 190;

					if (num540 > Main.maxTilesY - 160)
						num540 = Main.maxTilesY - 160;

					for (int num542 = num540 - 20 - genRand.Next(3); num542 < Main.maxTilesY; num542++) {
						if (num542 >= num540) {
							Main.tile[num541, num542].active(active: false);
							Main.tile[num541, num542].lava(lava: false);
							Main.tile[num541, num542].liquid = 0;
						}
						else {
							Main.tile[num541, num542].type = 57;
						}
					}
				}

				int num543 = Main.maxTilesY - genRand.Next(40, 70);
				for (int num544 = 10; num544 < Main.maxTilesX - 10; num544++) {
					num543 += genRand.Next(-10, 11);
					if (num543 > Main.maxTilesY - 60)
						num543 = Main.maxTilesY - 60;

					if (num543 < Main.maxTilesY - 100)
						num543 = Main.maxTilesY - 120;

					for (int num545 = num543; num545 < Main.maxTilesY - 10; num545++) {
						if (!Main.tile[num544, num545].active()) {
							Main.tile[num544, num545].lava(lava: true);
							Main.tile[num544, num545].liquid = byte.MaxValue;
						}
					}
				}

				for (int num546 = 0; num546 < Main.maxTilesX; num546++) {
					if (genRand.Next(50) == 0) {
						int num547 = Main.maxTilesY - 65;
						while (!Main.tile[num546, num547].active() && num547 > Main.maxTilesY - 135) {
							num547--;
						}

						TileRunner(genRand.Next(0, Main.maxTilesX), num547 + genRand.Next(20, 50), genRand.Next(15, 20), 1000, 57, addTile: true, 0f, genRand.Next(1, 3), noYChange: true);
					}
				}

				Liquid.QuickWater(-2);
				for (int num548 = 0; num548 < Main.maxTilesX; num548++) {
					float num549 = (float)num548 / (float)(Main.maxTilesX - 1);
					progress.Set(num549 / 2f + 0.5f);
					if (genRand.Next(13) == 0) {
						int num550 = Main.maxTilesY - 65;
						while ((Main.tile[num548, num550].liquid > 0 || Main.tile[num548, num550].active()) && num550 > Main.maxTilesY - 140) {
							num550--;
						}

						TileRunner(num548, num550 - genRand.Next(2, 5), genRand.Next(5, 30), 1000, 57, addTile: true, 0f, genRand.Next(1, 3), noYChange: true);
						float num551 = genRand.Next(1, 3);
						if (genRand.Next(3) == 0)
							num551 *= 0.5f;

						if (genRand.Next(2) == 0)
							TileRunner(num548, num550 - genRand.Next(2, 5), (int)((float)genRand.Next(5, 15) * num551), (int)((float)genRand.Next(10, 15) * num551), 57, addTile: true, 1f, 0.3f);

						if (genRand.Next(2) == 0) {
							num551 = genRand.Next(1, 3);
							TileRunner(num548, num550 - genRand.Next(2, 5), (int)((float)genRand.Next(5, 15) * num551), (int)((float)genRand.Next(10, 15) * num551), 57, addTile: true, -1f, 0.3f);
						}

						TileRunner(num548 + genRand.Next(-10, 10), num550 + genRand.Next(-10, 10), genRand.Next(5, 15), genRand.Next(5, 10), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						if (genRand.Next(3) == 0)
							TileRunner(num548 + genRand.Next(-10, 10), num550 + genRand.Next(-10, 10), genRand.Next(10, 30), genRand.Next(10, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));

						if (genRand.Next(5) == 0)
							TileRunner(num548 + genRand.Next(-15, 15), num550 + genRand.Next(-15, 10), genRand.Next(15, 30), genRand.Next(5, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
					}
				}

				for (int num552 = 0; num552 < Main.maxTilesX; num552++) {
					TileRunner(genRand.Next(20, Main.maxTilesX - 20), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(2, 7), genRand.Next(2, 7), -2);
				}

				for (int num553 = 0; num553 < Main.maxTilesX; num553++) {
					if (!Main.tile[num553, Main.maxTilesY - 145].active()) {
						Main.tile[num553, Main.maxTilesY - 145].liquid = byte.MaxValue;
						Main.tile[num553, Main.maxTilesY - 145].lava(lava: true);
					}

					if (!Main.tile[num553, Main.maxTilesY - 144].active()) {
						Main.tile[num553, Main.maxTilesY - 144].liquid = byte.MaxValue;
						Main.tile[num553, Main.maxTilesY - 144].lava(lava: true);
					}
				}

				for (int num554 = 0; num554 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008 * Main.setting.PercHellstone); num554++) {
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(Main.maxTilesY - 140, Main.maxTilesY), genRand.Next(2, 7), genRand.Next(3, 7), 58);
				}

				if (Main.setting.UnderworldHouseMult > 0)
				AddHellHouses();
			});

			AddGenerationPass("Lakes", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[19].Value;
				int num536 = genRand.Next(2, (int)((double)Main.maxTilesX * 0.005 * Main.setting.LakeMultiplier));
				for (int num537 = 0; num537 < num536; num537++) {
					float value16 = (float)num537 / (float)num536;
					progress.Set(value16);
					int num538 = genRand.Next(300, Main.maxTilesX - 300);
					while (num538 > Main.maxTilesX / 2 - 100 && num538 < Main.maxTilesX / 2 + 100) {
						num538 = genRand.Next(300, Main.maxTilesX - 300);
						if (Main.maxTilesX <= 600) num538 = genRand.Next(0, Main.maxTilesX);
					}

					int num539;
					for (num539 = (int)worldSurfaceLow - 20; !Main.tile[num538, num539].active(); num539++) {
					}

					Lakinater(num538, num539);
				}
			});

			AddGenerationPass("Dungeon", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[58].Value;
				int num535 = 0;
				if (dungeonSide == -1) {
					num535 = genRand.Next((int)((double)Main.maxTilesX * 0.05), (int)((double)Main.maxTilesX * 0.2));
					dungeonSide = -1;
				}
				else {
					num535 = genRand.Next((int)((double)Main.maxTilesX * 0.8), (int)((double)Main.maxTilesX * 0.95));
					dungeonSide = 1;
				}

				int y9 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + genRand.Next(-200, 200);
				if (!InWorldY(y9, 0)) 
					y9 = (int)((Main.worldSurface + Main.rockLayer) / 2.0);
				if (!Main.setting.NoDungeon) {
					MakeDungeon(num535, y9, progress);
				}
				if (Main.setting.DoubleDungeon == true) {
					if (dungeonSide == 1)
						num535 = WorldGen.genRand.Next((int)((double)Main.maxTilesX * 0.05), (int)((double)Main.maxTilesX * 0.2));
					else
						num535 = WorldGen.genRand.Next((int)((double)Main.maxTilesX * 0.8), (int)((double)Main.maxTilesX * 0.95));
					y9 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + WorldGen.genRand.Next(-200, 200);
					if (!InWorldY(y9, 0)) 
						y9 = (int)((Main.worldSurface + Main.rockLayer) / 2.0);
					MakeDungeon(num535, y9, progress);
				}
			});

			AddGenerationPass("Corruption", delegate (GenerationProgress progress) {
				if ((crimson || Main.setting.IsCorruption == 3) && Main.setting.IsCorruption != 5) {
					progress.Message = Lang.gen[72].Value;
					for (int num487 = 0; (double)num487 < (double)Main.maxTilesX * 0.00045 * Main.setting.CrimsonMultiplier; num487++) {
						float value14 = (float)((double)num487 / ((double)Main.maxTilesX * 0.00045 * Main.setting.CrimsonMultiplier));
						progress.Set(value14);
						bool flag38 = false;
						int num488 = 0;
						int num489 = 0;
						int num490 = 0;
						while (!flag38) {
							int num491 = 0;
							flag38 = true;
							int num492 = Main.maxTilesX / 2;
							int num493 = 200;
							if (dungeonSide < 0) {
								num488 = WorldGen.genRand.Next(600, Main.maxTilesX - 320);
								if (Main.maxTilesY < 1000) num488 = WorldGen.genRand.Next(100, Main.maxTilesX - 50);
							} else {
								num488 = WorldGen.genRand.Next(320, Main.maxTilesX - 600);
								if (Main.maxTilesY < 1000) num488 = WorldGen.genRand.Next(50, Main.maxTilesX - 100);
							}
							// I don't like this ugly diff...
							if (Main.setting.CrimsonCorruptionAvoidJungle)
							{
								if (dungeonSide == -1) // dungeon on left side, so place on left side
								{
									if (num488 > Main.maxTilesX / 2) {
										flag38 = false;
										continue;
									}
								} else {
									if (num488 < Main.maxTilesX / 2)
									{
										flag38 = false;
										continue;
									}
								}
							}
							if (Main.setting.CrimsonCorruptionAvoidEachOther)
							{
								if (crimsonSide == -1) // Crimson on left
								{
									if (num488 > Main.maxTilesX / 2)
									{
										flag38 = false;
										continue;
									}
								}
								else if (crimsonSide == 1)
								{
									if (num488 < Main.maxTilesX / 2)
									{
										flag38 = false;
										continue;
									}
								}
							}
							num489 = num488 - WorldGen.genRand.Next(200) - 100;
							num490 = num488 + WorldGen.genRand.Next(200) + 100;
							if (num489 < 285) {
								num489 = 285;
							}
							if (num490 > Main.maxTilesX - 285) {
								num490 = Main.maxTilesX - 285;
							}
							if (dungeonSide < 0 && num489 < 400) {
								num489 = 400;
							}
							else if (dungeonSide > 0 && num489 > Main.maxTilesX - 400) {
								num489 = Main.maxTilesX - 400;
							}
							if (Main.maxTilesY < 1000)
							{
								num489 = num488 - WorldGen.genRand.Next(50) - 50;
								num490 = num488 + WorldGen.genRand.Next(50) + 50;
								if (num489 < 50)
								{
									num489 = 50;
								}
								if (num490 > Main.maxTilesX - 50)
								{
									num490 = Main.maxTilesX - 50;
								}
								if (dungeonSide < 0 && num489 < 50)
								{
									num489 = 50;
								}
								else if (dungeonSide > 0 && num489 > Main.maxTilesX - 50)
								{
									num489 = Main.maxTilesX - 50;
								}
								num493 = 50;
							}
							if (num488 > num492 - num493 && num488 < num492 + num493)
								flag38 = false;

							if (num489 > num492 - num493 && num489 < num492 + num493)
								flag38 = false;

							if (num490 > num492 - num493 && num490 < num492 + num493)
								flag38 = false;

							if (num488 > UndergroundDesertLocation.X && num488 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
								flag38 = false;

							if (num489 > UndergroundDesertLocation.X && num489 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
								flag38 = false;

							if (num490 > UndergroundDesertLocation.X && num490 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
								flag38 = false;

							for (int num494 = num489; num494 < num490; num494++) {
								for (int num495 = 0; num495 < (int)Main.worldSurface; num495 += 5) {
									if (Main.tile[num494, num495].active() && Main.tileDungeon[Main.tile[num494, num495].type]) {
										flag38 = false;
										break;
									}

									if (!flag38)
										break;
								}
							}

							if (num491 < 200 && JungleX > num489 && JungleX < num490) {
								num491++;
								flag38 = false;
							}
						}

						CrimStart(num488, (int)worldSurfaceLow - 10);
						for (int num496 = num489; num496 < num490; num496++) {
							for (int num497 = (int)worldSurfaceLow; (double)num497 < Main.worldSurface - 1.0; num497++) {
								if (Main.tile[num496, num497].active()) {
									int num498 = num497 + genRand.Next(10, 14);
									for (int num499 = num497; num499 < num498; num499++) {
										if ((Main.tile[num497, num499].type == 59 || Main.tile[num497, num499].type == 60 || Main.tile[num497, num499].type == 70) && num497 >= num488 + WorldGen.genRand.Next(5) && num497 < num490 - WorldGen.genRand.Next(5))
											Main.tile[num496, num499].type = 0;
									}

									break;
								}
							}
						}

						double num500 = Main.worldSurface + 40.0;
						for (int num501 = num489; num501 < num490; num501++) {
							num500 += (double)genRand.Next(-2, 3);
							if (num500 < Main.worldSurface + 30.0)
								num500 = Main.worldSurface + 30.0;

							if (num500 > Main.worldSurface + 50.0)
								num500 = Main.worldSurface + 50.0;

							i2 = num501;
							bool flag39 = false;
							for (int num502 = (int)worldSurfaceLow; (double)num502 < num500; num502++) {
								if (Main.tile[i2, num502].active()) {
									if (Main.tile[i2, num502].type == 53 && i2 >= num489 + genRand.Next(5) && i2 <= num490 - genRand.Next(5))
										Main.tile[i2, num502].type = 234;

									if (Main.tile[i2, num502].type == 0 && (double)num502 < Main.worldSurface - 1.0 && !flag39) {
										grassSpread = 0;
										SpreadGrass(i2, num502, 0, 199, repeat: true, 0);
									}

									flag39 = true;
									if (Main.tile[i2, num502].wall == 216)
										Main.tile[i2, num502].wall = 218;
									else if (Main.tile[i2, num502].wall == 187)
										Main.tile[i2, num502].wall = 221;

									if (Main.tile[i2, num502].type == 1) {
										if (i2 >= num489 + genRand.Next(5) && i2 <= num490 - genRand.Next(5))
											Main.tile[i2, num502].type = 203;
									}
									else if (Main.tile[i2, num502].type == 2) {
										Main.tile[i2, num502].type = 199;
									}
									else if (Main.tile[i2, num502].type == 161) {
										Main.tile[i2, num502].type = 200;
									}
									else if (Main.tile[i2, num502].type == 396) {
										Main.tile[i2, num502].type = 401;
									}
									else if (Main.tile[i2, num502].type == 397) {
										Main.tile[i2, num502].type = 399;
									}
								}
							}
						}

						int num503 = genRand.Next(10, 15);
						for (int num504 = 0; num504 < num503; num504++) {
							int num505 = 0;
							bool flag40 = false;
							int num506 = 0;
							while (!flag40) {
								num505++;
								int num507 = genRand.Next(num489 - num506, num490 + num506);
								int num508 = genRand.Next((int)(Main.worldSurface - (double)(num506 / 2)), (int)(Main.worldSurface + 100.0 + (double)num506));
								if (num505 > 100) {
									num506++;
									num505 = 0;
								}

								if (!Main.tile[num507, num508].active()) {
									for (; !Main.tile[num507, num508].active(); num508++) {
									}

									num508--;
								}
								else {
									while (Main.tile[num507, num508].active() && (double)num508 > Main.worldSurface) {
										num508--;
									}
								}

								if (num506 > 10 || (Main.tile[num507, num508 + 1].active() && Main.tile[num507, num508 + 1].type == 203)) {
									Place3x2(num507, num508, 26, 1);
									if (Main.tile[num507, num508].type == 26)
										flag40 = true;
								}

								if (num506 > 100)
									flag40 = true;
							}
						}
					}
				}
				if ((!WorldGen.crimson || Main.setting.IsCorruption == 4) && Main.setting.IsCorruption != 5) {
					// Making the world evil -- corruption
 					progress.Message = Lang.gen[20].Value;
					for (int num509 = 0; (double)num509 < (double)Main.maxTilesX * 0.00045 * Main.setting.CorruptionMultiplier; num509++) {
						float value15 = (float)((double)num509 / ((double)Main.maxTilesX * 0.00045 * Main.setting.CorruptionMultiplier));
						progress.Set(value15);
						bool flag41 = false;
						int num510 = 0;
						int num511 = 0;
						int num512 = 0;
						while (!flag41) {
							int num513 = 0;
							flag41 = true;
							int num514 = Main.maxTilesX / 2;
							int num515 = 200;
							num510 = genRand.Next(320, Main.maxTilesX - 320);
							num511 = num510 - genRand.Next(200) - 100;
							num512 = num510 + genRand.Next(200) + 100;
							if (Main.maxTilesX <= 640)
							{
								num510 = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
								num511 = num510 - WorldGen.genRand.Next(50) - 50;
								num512 = num510 + WorldGen.genRand.Next(50) + 50;
								num515 = 50;
							}
							if (Main.setting.CrimsonCorruptionAvoidJungle)
							{
								if (dungeonSide == -1) // dungeon on left side, so place on left side
								{
									if (num510 > Main.maxTilesX / 2)
									{
										flag41 = false;
										continue;
									}
								}
								else
								{
									if (num510 < Main.maxTilesX / 2)
									{
										flag41 = false;
										continue;
									}
								}
							}
							if (Main.setting.CrimsonCorruptionAvoidEachOther)
							{
								if (crimsonSide == -1) // Crimson on left
								{
									if (num510 < Main.maxTilesX / 2)
									{
										flag41 = false;
										continue;
									}
								}
								else if (crimsonSide == 1)
								{
									if (num510 > Main.maxTilesX / 2)
									{
										flag41 = false;
										continue;
									}
								}
							}
							if (num511 < 285)
								num511 = 285;

							if (num512 > Main.maxTilesX - 285)
								num512 = Main.maxTilesX - 285;

							if (Main.maxTilesX < 1000)
								num512 = Utils.Clamp(num512, 50, Main.maxTilesX - 50);

							if (num510 > num514 - num515 && num510 < num514 + num515)
								flag41 = false;

							if (num511 > num514 - num515 && num511 < num514 + num515)
								flag41 = false;

							if (num512 > num514 - num515 && num512 < num514 + num515)
								flag41 = false;

							if (num510 > UndergroundDesertLocation.X && num510 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
								flag41 = false;

							if (num511 > UndergroundDesertLocation.X && num511 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
								flag41 = false;

							if (num512 > UndergroundDesertLocation.X && num512 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
								flag41 = false;

							for (int num516 = num511; num516 < num512; num516++) {
								for (int num517 = 0; num517 < (int)Main.worldSurface; num517 += 5) {
									if (Main.tile[num516, num517].active() && Main.tileDungeon[Main.tile[num516, num517].type]) {
										flag41 = false;
										break;
									}

									if (!flag41)
										break;
								}
							}

							if (num513 < 200 && JungleX > num511 && JungleX < num512) {
								num513++;
								flag41 = false;
							}
						}

						int num518 = 0;
						for (int num519 = num511; num519 < num512; num519++) {
							if (num518 > 0)
								num518--;

							if (num519 == num510 || num518 == 0) {
								for (int num520 = (int)worldSurfaceLow; (double)num520 < Main.worldSurface - 1.0; num520++) {
									if (Main.tile[num519, num520].active() || Main.tile[num519, num520].wall > 0) {
										if (num519 == num510) {
											num518 = 20;
											ChasmRunner(num519, num520, genRand.Next(150) + 150, makeOrb: true);
										}
										else if (genRand.Next(35) == 0 && num518 == 0) {
											num518 = 30;
											bool makeOrb = true;
											ChasmRunner(num519, num520, genRand.Next(50) + 50, makeOrb);
										}

										break;
									}
								}
							}

							for (int num521 = (int)worldSurfaceLow; (double)num521 < Main.worldSurface - 1.0; num521++) {
								if (Main.tile[num519, num521].active()) {
									int num522 = num521 + genRand.Next(10, 14);
									for (int num523 = num521; num523 < num522; num523++) {
										if ((Main.tile[num519, num523].type == 59 || Main.tile[num519, num523].type == 60) && num519 >= num511 + genRand.Next(5) && num519 < num512 - genRand.Next(5))
											Main.tile[num519, num523].type = 0;
									}

									break;
								}
							}
						}

						double num524 = Main.worldSurface + 40.0;
						for (int num525 = num511; num525 < num512; num525++) {
							num524 += (double)genRand.Next(-2, 3);
							if (num524 < Main.worldSurface + 30.0)
								num524 = Main.worldSurface + 30.0;

							if (num524 > Main.worldSurface + 50.0)
								num524 = Main.worldSurface + 50.0;

							i2 = num525;
							bool flag42 = false;
							for (int num526 = (int)worldSurfaceLow; (double)num526 < num524; num526++) {
								if (Main.tile[i2, num526].active()) {
									if (Main.tile[i2, num526].type == 53 && i2 >= num511 + genRand.Next(5) && i2 <= num512 - genRand.Next(5))
										Main.tile[i2, num526].type = 112;

									if (Main.tile[i2, num526].type == 0 && (double)num526 < Main.worldSurface - 1.0 && !flag42) {
										grassSpread = 0;
										SpreadGrass(i2, num526, 0, 23, repeat: true, 0);
									}

									flag42 = true;
									if (Main.tile[i2, num526].type == 1 && i2 >= num511 + genRand.Next(5) && i2 <= num512 - genRand.Next(5))
										Main.tile[i2, num526].type = 25;

									if (Main.tile[i2, num526].wall == 216)
										Main.tile[i2, num526].wall = 217;
									else if (Main.tile[i2, num526].wall == 187)
										Main.tile[i2, num526].wall = 220;

									if (Main.tile[i2, num526].type == 2)
										Main.tile[i2, num526].type = 23;

									if (Main.tile[i2, num526].type == 161)
										Main.tile[i2, num526].type = 163;
									else if (Main.tile[i2, num526].type == 396)
										Main.tile[i2, num526].type = 400;
									else if (Main.tile[i2, num526].type == 397)
										Main.tile[i2, num526].type = 398;
								}
							}
						}

						for (int num527 = num511; num527 < num512; num527++) {
							for (int num528 = 0; num528 < Main.maxTilesY - 50; num528++) {
								if (Main.tile[num527, num528].active() && Main.tile[num527, num528].type == 31 && Main.tile[num527, num528].frameX < 36) {
									int num529 = num527 - 13;
									int num530 = num527 + 13;
									int num531 = num528 - 13;
									int num532 = num528 + 13;
									for (int num533 = num529; num533 < num530; num533++) {
										if (num533 > 10 && num533 < Main.maxTilesX - 10) {
											for (int num534 = num531; num534 < num532; num534++) {
												if (Math.Abs(num533 - num527) + Math.Abs(num534 - num528) < 9 + genRand.Next(11) && genRand.Next(3) != 0 && Main.tile[num533, num534].type != 31) {
													Main.tile[num533, num534].active(active: true);
													Main.tile[num533, num534].type = 25;
													if (Math.Abs(num533 - num527) <= 1 && Math.Abs(num534 - num528) <= 1)
														Main.tile[num533, num534].active(active: false);
												}

												if (Main.tile[num533, num534].type != 31 && Math.Abs(num533 - num527) <= 2 + genRand.Next(3) && Math.Abs(num534 - num528) <= 2 + genRand.Next(3))
													Main.tile[num533, num534].active(active: false);
											}
										}
									}
								}
							}
						}
					}
				}
			});

			AddGenerationPass("Slush", delegate {
				for (int num482 = snowTop; num482 < snowBottom; num482++) {
					for (int num483 = snowMinX[num482]; num483 < snowMaxX[num482]; num483++) {
						switch (Main.tile[num483, num482].type) {
							case 123:
								Main.tile[num483, num482].type = 224;
								break;
							case 59: {
									bool flag37 = true;
									int num484 = 3;
									for (int num485 = num483 - num484; num485 <= num483 + num484; num485++) {
										for (int num486 = num482 - num484; num486 <= num482 + num484; num486++) {
											if (InWorld(num485, num486) && (Main.tile[num485, num486].type == 60 || Main.tile[num485, num486].type == 70 || Main.tile[num485, num486].type == 71 || Main.tile[num485, num486].type == 72)) {
												flag37 = false;
												break;
											}
										}
									}

									if (flag37)
										Main.tile[num483, num482].type = 224;

									break;
								}
							case 1:
								Main.tile[num483, num482].type = 161;
								break;
						}
					}
				}
			});

			AddGenerationPass("Mud Caves To Grass", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[21].Value;
				for (int num481 = 0; num481 < numMCaves; num481++) {
					int i3 = mCaveX[num481];
					int j2 = mCaveY[num481];
					CaveOpenater(i3, j2);
					Cavinator(i3, j2, genRand.Next(40, 50));
				}
			});

			AddGenerationPass("Beaches", delegate (GenerationProgress progress) {
				if (Main.setting.NoBeach) return;
				int num462 = 0;
				int num463 = 0;
				int num464 = 20;
				int num465 = Main.maxTilesX - 20;
				progress.Message = Lang.gen[22].Value;
				double N5 = Math.Sqrt(Main.setting.BeachDepthMultiplier);
				for (int num466 = 0; num466 < 2; num466++) {
					int num467 = 0;
					int num468 = 0;
					if (num466 == 0) {
						num467 = 0;
						num468 = genRand.Next(125, 200) + 50;
						num468 = (int)(num468 * Main.setting.BeachSizeMultiplier);
						if (dungeonSide == 1)
							num468 = 275;
							num468 = (int)(num468 * Main.setting.BeachSizeMultiplier);
						int num469 = 0;
						float num470 = 1f;
						int num471;
						for (num471 = 0; !Main.tile[num468 - 1, num471].active(); num471++) {
						}

						num462 = num471;
						num471 += genRand.Next(1, 5);
						for (int num472 = num468 - 1; num472 >= num467; num472--) {
							num469++;
							if (num469 < 3)
								num470 += (float)genRand.Next(10, 20) * 0.2f;
							else if (num469 < 6)
								num470 += (float)genRand.Next(10, 20) * 0.15f;
							else if (num469 < 9)
								num470 += (float)genRand.Next(10, 20) * 0.1f;
							else if (num469 < 15)
								num470 += (float)genRand.Next(10, 20) * 0.07f;
							else if (num469 < 50)
								num470 += (float)genRand.Next(10, 20) * 0.05f;
							else if (num469 < 75)
								num470 += (float)genRand.Next(10, 20) * 0.04f;
							else if (num469 < 100)
								num470 += (float)genRand.Next(10, 20) * 0.03f;
							else if (num469 < 125)
								num470 += (float)genRand.Next(10, 20) * 0.02f;
							else if (num469 < 150)
								num470 += (float)genRand.Next(10, 20) * 0.01f;
							else if (num469 < 175)
								num470 += (float)genRand.Next(10, 20) * 0.005f;
							else if (num469 < 200)
								num470 += (float)genRand.Next(10, 20) * 0.001f;
							else if (num469 < 230)
								num470 += (float)genRand.Next(10, 20) * 0.01f;
							else if (num469 < 235)
								num470 += (float)genRand.Next(10, 20) * 0.05f;
							else if (num469 < 240)
								num470 += (float)genRand.Next(10, 20) * 0.1f;
							else if (num469 < 245)
								num470 += (float)genRand.Next(10, 20) * 0.05f;
							else if (num469 < 255)
								num470 += (float)genRand.Next(10, 20) * 0.01f;

							if (num469 == 235)
								num465 = num472;

							if (num469 == 235)
								num464 = num472;
							int num473 = genRand.Next(15, 20);
							for (int num474 = 0; (float)num474 < ((float)num471 + num470 + (float)num473) * N5; num474++) {
								if ((float)num474 < ((float)num471 + num470 * 0.75f - 3f) * N5) {
									Main.tile[num472, num474].active(active: false);
									if (num474 > num471)
										Main.tile[num472, num474].liquid = byte.MaxValue;
									else if (num474 == num471)
										Main.tile[num472, num474].liquid = 127;
								}
								else if (num474 > num471 * N5) {
									Main.tile[num472, num474].type = 53;
									Main.tile[num472, num474].active(active: true);
								}

								Main.tile[num472, num474].wall = 0;
							}
						}
					}
					else {
						num467 = Main.maxTilesX - (int)((WorldGen.genRand.Next(125, 200) - 50) * Main.setting.BeachSizeMultiplier);
						num468 = Main.maxTilesX;
						if (dungeonSide == -1)
							num467 = Main.maxTilesX - (int)(275 * Main.setting.BeachSizeMultiplier);

						float num475 = 1f;
						int num476 = 0;
						int num477;
						for (num477 = 0; !Main.tile[num467, num477].active(); num477++) {
						}

						num463 = num477;
						num477 += genRand.Next(1, 5);
						for (int num478 = num467; num478 < num468; num478++) {
							num476++;
							if (num476 < 3)
								num475 += (float)genRand.Next(10, 20) * 0.2f;
							else if (num476 < 6)
								num475 += (float)genRand.Next(10, 20) * 0.15f;
							else if (num476 < 9)
								num475 += (float)genRand.Next(10, 20) * 0.1f;
							else if (num476 < 15)
								num475 += (float)genRand.Next(10, 20) * 0.07f;
							else if (num476 < 50)
								num475 += (float)genRand.Next(10, 20) * 0.05f;
							else if (num476 < 75)
								num475 += (float)genRand.Next(10, 20) * 0.04f;
							else if (num476 < 100)
								num475 += (float)genRand.Next(10, 20) * 0.03f;
							else if (num476 < 125)
								num475 += (float)genRand.Next(10, 20) * 0.02f;
							else if (num476 < 150)
								num475 += (float)genRand.Next(10, 20) * 0.01f;
							else if (num476 < 175)
								num475 += (float)genRand.Next(10, 20) * 0.005f;
							else if (num476 < 200)
								num475 += (float)genRand.Next(10, 20) * 0.001f;
							else if (num476 < 230)
								num475 += (float)genRand.Next(10, 20) * 0.01f;
							else if (num476 < 235)
								num475 += (float)genRand.Next(10, 20) * 0.05f;
							else if (num476 < 240)
								num475 += (float)genRand.Next(10, 20) * 0.1f;
							else if (num476 < 245)
								num475 += (float)genRand.Next(10, 20) * 0.05f;
							else if (num476 < 255)
								num475 += (float)genRand.Next(10, 20) * 0.01f;

							if (num476 == 235)
								num465 = num478;

							int num479 = genRand.Next(15, 20);
							for (int num480 = 0; (float)num480 < ((float)num477 + num475 + (float)num479) * (float)N5; num480++) {
								if ((float)num480 < ((float)num477 + num475 * 0.75f - 3f) * N5 && (double)num480 < (Main.worldSurface - 2.0) * N5) {
									Main.tile[num478, num480].active(active: false);
									if (num480 > num477)
										Main.tile[num478, num480].liquid = byte.MaxValue;
									else if (num480 == num477)
										Main.tile[num478, num480].liquid = 127;
								}
								else if (num480 > num477 * N5) {
									Main.tile[num478, num480].type = 53;
									Main.tile[num478, num480].active(active: true);
								}

								Main.tile[num478, num480].wall = 0;
							}
						}
					}
				}

				for (; !Main.tile[num464, num462].active(); num462++) {
				}

				num462++;
				for (; !Main.tile[num465, num463].active(); num463++) {
				}

				num463++;
			});

			AddGenerationPass("Gems", delegate (GenerationProgress progress) {
				// TODO non-gemcave gems?
				progress.Message = Lang.gen[23].Value;
				for (int num449 = 63; num449 <= 68; num449++) {
					float num450 = 0f;
					switch (num449) {
						case 67:
							num450 = (float)Main.maxTilesX * 0.5f;
							break;
						case 66:
							num450 = (float)Main.maxTilesX * 0.45f;
							break;
						case 63:
							num450 = (float)Main.maxTilesX * 0.3f;
							break;
						case 65:
							num450 = (float)Main.maxTilesX * 0.25f;
							break;
						case 64:
							num450 = (float)Main.maxTilesX * 0.1f;
							break;
						case 68:
							num450 = (float)Main.maxTilesX * 0.05f;
							break;
					}

					num450 *= 0.2f;
					num450 *= Main.setting.GemMultiplier;
					for (int num451 = 0; (float)num451 < num450; num451++) {
						int num452 = genRand.Next(0, Main.maxTilesX);
						int num453 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
						while (Main.tile[num452, num453].type != 1) {
							num452 = genRand.Next(0, Main.maxTilesX);
							num453 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
						}

						TileRunner(num452, num453, genRand.Next(2, 6), genRand.Next(3, 7), num449);
					}
				}

				for (int num454 = 0; num454 < 2; num454++) {
					int num455 = 1;
					int num456 = 5;
					int num457 = Main.maxTilesX - 5;
					if (num454 == 1) {
						num455 = -1;
						num456 = Main.maxTilesX - 5;
						num457 = 5;
					}

					for (int num458 = num456; num458 != num457; num458 += num455) {
						for (int num459 = 10; num459 < Main.maxTilesY - 10; num459++) {
							if (Main.tile[num458, num459].active() && Main.tile[num458, num459 + 1].active() && Main.tileSand[Main.tile[num458, num459].type] && Main.tileSand[Main.tile[num458, num459 + 1].type]) {
								ushort type4 = Main.tile[num458, num459].type;
								int num460 = num458 + num455;
								int num461 = num459 + 1;
								if (!Main.tile[num460, num459].active() && !Main.tile[num460, num459 + 1].active()) {
									for (; !Main.tile[num460, num461].active(); num461++) {
									}

									num461--;
									Main.tile[num458, num459].active(active: false);
									Main.tile[num460, num461].active(active: true);
									Main.tile[num460, num461].type = type4;
								}
							}
						}
					}
				}
			});

			AddGenerationPass("Gravitating Sand", delegate (GenerationProgress progress) {
				if (Main.setting.NoGravitate == true) return;
				progress.Message = Lang.gen[24].Value;
				for (int num445 = 0; num445 < Main.maxTilesX; num445++) {
					float value13 = (float)num445 / (float)(Main.maxTilesX - 1);
					progress.Set(value13);
					bool flag36 = false;
					int num446 = 0;
					for (int num447 = Main.maxTilesY - 1; num447 > 0; num447--) {
						if (SolidOrSlopedTile(num445, num447)) {
							ushort type3 = Main.tile[num445, num447].type;
							if (flag36 && num447 < (int)Main.worldSurface && num447 != num446 - 1 && TileID.Sets.Falling[type3]) {
								for (int num448 = num447; num448 < num446; num448++) {
									Main.tile[num445, num448].type = type3;
									Main.tile[num445, num448].active(active: true);
								}
							}

							flag36 = true;
							num446 = num447;
						}
					}
				}
			});

			AddGenerationPass("Clean Up Dirt", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[25].Value;
				for (int num439 = 3; num439 < Main.maxTilesX - 3; num439++) {
					float num440 = (float)num439 / (float)Main.maxTilesX;
					progress.Set(0.5f * num440);
					bool flag34 = true;
					for (int num441 = 0; (double)num441 < Main.worldSurface; num441++) {
						if (flag34) {
							if (Main.tile[num439, num441].wall == 2 || Main.tile[num439, num441].wall == 40 || Main.tile[num439, num441].wall == 64)
								Main.tile[num439, num441].wall = 0;

							if (Main.tile[num439, num441].type != 53 && Main.tile[num439, num441].type != 112 && Main.tile[num439, num441].type != 234) {
								if (Main.tile[num439 - 1, num441].wall == 2 || Main.tile[num439 - 1, num441].wall == 40 || Main.tile[num439 - 1, num441].wall == 40)
									Main.tile[num439 - 1, num441].wall = 0;

								if ((Main.tile[num439 - 2, num441].wall == 2 || Main.tile[num439 - 2, num441].wall == 40 || Main.tile[num439 - 2, num441].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num439 - 2, num441].wall = 0;

								if ((Main.tile[num439 - 3, num441].wall == 2 || Main.tile[num439 - 3, num441].wall == 40 || Main.tile[num439 - 3, num441].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num439 - 3, num441].wall = 0;

								if (Main.tile[num439 + 1, num441].wall == 2 || Main.tile[num439 + 1, num441].wall == 40 || Main.tile[num439 + 1, num441].wall == 40)
									Main.tile[num439 + 1, num441].wall = 0;

								if ((Main.tile[num439 + 2, num441].wall == 2 || Main.tile[num439 + 2, num441].wall == 40 || Main.tile[num439 + 2, num441].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num439 + 2, num441].wall = 0;

								if ((Main.tile[num439 + 3, num441].wall == 2 || Main.tile[num439 + 3, num441].wall == 40 || Main.tile[num439 + 3, num441].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num439 + 3, num441].wall = 0;

								if (Main.tile[num439, num441].active())
									flag34 = false;
							}
						}
						else if (Main.tile[num439, num441].wall == 0 && Main.tile[num439, num441 + 1].wall == 0 && Main.tile[num439, num441 + 2].wall == 0 && Main.tile[num439, num441 + 3].wall == 0 && Main.tile[num439, num441 + 4].wall == 0 && Main.tile[num439 - 1, num441].wall == 0 && Main.tile[num439 + 1, num441].wall == 0 && Main.tile[num439 - 2, num441].wall == 0 && Main.tile[num439 + 2, num441].wall == 0 && !Main.tile[num439, num441].active() && !Main.tile[num439, num441 + 1].active() && !Main.tile[num439, num441 + 2].active() && !Main.tile[num439, num441 + 3].active()) {
							flag34 = true;
						}
					}
				}

				for (int num442 = Main.maxTilesX - 5; num442 >= 5; num442--) {
					float num443 = (float)num442 / (float)Main.maxTilesX;
					progress.Set(1f - 0.5f * num443);
					bool flag35 = true;
					for (int num444 = 0; (double)num444 < Main.worldSurface; num444++) {
						if (flag35) {
							if (Main.tile[num442, num444].wall == 2 || Main.tile[num442, num444].wall == 40 || Main.tile[num442, num444].wall == 64)
								Main.tile[num442, num444].wall = 0;

							if (Main.tile[num442, num444].type != 53) {
								if (Main.tile[num442 - 1, num444].wall == 2 || Main.tile[num442 - 1, num444].wall == 40 || Main.tile[num442 - 1, num444].wall == 40)
									Main.tile[num442 - 1, num444].wall = 0;

								if ((Main.tile[num442 - 2, num444].wall == 2 || Main.tile[num442 - 2, num444].wall == 40 || Main.tile[num442 - 2, num444].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num442 - 2, num444].wall = 0;

								if ((Main.tile[num442 - 3, num444].wall == 2 || Main.tile[num442 - 3, num444].wall == 40 || Main.tile[num442 - 3, num444].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num442 - 3, num444].wall = 0;

								if (Main.tile[num442 + 1, num444].wall == 2 || Main.tile[num442 + 1, num444].wall == 40 || Main.tile[num442 + 1, num444].wall == 40)
									Main.tile[num442 + 1, num444].wall = 0;

								if ((Main.tile[num442 + 2, num444].wall == 2 || Main.tile[num442 + 2, num444].wall == 40 || Main.tile[num442 + 2, num444].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num442 + 2, num444].wall = 0;

								if ((Main.tile[num442 + 3, num444].wall == 2 || Main.tile[num442 + 3, num444].wall == 40 || Main.tile[num442 + 3, num444].wall == 40) && genRand.Next(2) == 0)
									Main.tile[num442 + 3, num444].wall = 0;

								if (Main.tile[num442, num444].active())
									flag35 = false;
							}
						}
						else if (Main.tile[num442, num444].wall == 0 && Main.tile[num442, num444 + 1].wall == 0 && Main.tile[num442, num444 + 2].wall == 0 && Main.tile[num442, num444 + 3].wall == 0 && Main.tile[num442, num444 + 4].wall == 0 && Main.tile[num442 - 1, num444].wall == 0 && Main.tile[num442 + 1, num444].wall == 0 && Main.tile[num442 - 2, num444].wall == 0 && Main.tile[num442 + 2, num444].wall == 0 && !Main.tile[num442, num444].active() && !Main.tile[num442, num444 + 1].active() && !Main.tile[num442, num444 + 2].active() && !Main.tile[num442, num444 + 3].active()) {
							flag35 = true;
						}
					}
				}
			});

			AddGenerationPass("Pyramids", delegate {
				for (int num433 = 0; num433 < numPyr; num433++) {
					int num434 = PyrX[num433];
					int num435 = PyrY[num433];
					if (num434 > 300 && num434 < Main.maxTilesX - 300 && (dungeonSide >= 0 || !((double)num434 < (double)dungeonX + (double)Main.maxTilesX * 0.15)) && (dungeonSide <= 0 || !((double)num434 > (double)dungeonX - (double)Main.maxTilesX * 0.15))) {
						for (; !Main.tile[num434, num435].active() && (double)num435 < Main.worldSurface; num435++) {
						}

						if ((double)num435 < Main.worldSurface && Main.tile[num434, num435].type == 53) {
							int num436 = Main.maxTilesX;
							for (int num437 = 0; num437 < num433; num437++) {
								int num438 = Math.Abs(num434 - PyrX[num437]);
								if (num438 < num436)
									num436 = num438;
							}

							if (num436 >= 250) {
								num435--;
								Pyramid(num434, num435);
								if (Main.setting.IsPyramid != 0)
								{
									WorldGen.Pyramid(num434, num435);
								}
							}
						}
					}
				}

				if (Main.setting.IsPyramid == 1 && WorldGen.numPyramids <= 0)
				{
					for (int k = 0; k < numPyr; k++)
					{
						int num = PyrX[k];
						int num2 = PyrY[k];
						if (num > 300 && num < Main.maxTilesX - 300 && (dungeonSide >= 0 || (double)num >= (double)WorldGen.dungeonX + (double)Main.maxTilesX * 0.15))
						{
							if (dungeonSide <= 0 || (double)num <= (double)WorldGen.dungeonX - (double)Main.maxTilesX * 0.15)
							{
								while (!Main.tile[num, num2].active() && (double)num2 < Main.worldSurface)
								{
									num2++;
								}
								if ((double)num2 < Main.worldSurface && Main.tile[num, num2].type == 53)
								{
									int num3 = Main.maxTilesX;
									for (int l = 0; l < k; l++)
									{
										int num4 = Math.Abs(num - PyrX[l]);
										if (num4 < num3)
										{
											num3 = num4;
										}
									}
									if (num3 >= 250)
									{
										num2--;
										if (Main.setting.IsPyramid != 0)
										{
											WorldGen.Pyramid(num, num2);
											break;
										}
									}
								}
							}
						}
					}
				}
			});

			AddGenerationPass("Dirt Rock Wall Runner", delegate {
				for (int num430 = 0; num430 < Main.maxTilesX; num430++) {
					int num431 = genRand.Next(10, Main.maxTilesX - 10);
					int num432 = genRand.Next(10, (int)Main.worldSurface);
					if (Main.tile[num431, num432].wall == 2)
						DirtyRockRunner(num431, num432);
				}
			});

			AddGenerationPass("Living Trees", delegate {
				float num422 = Main.maxTilesX / 4200 * Main.setting.GiantTreeMult;
				int num423 = genRand.Next(0, (int)(3f * num422));
				if (Main.setting.IsGiantTree == 1)
					{
						// TODO, slider for Living Trees.
						num423 = 1 + (int)(3f * num422);
					}
				for (int num424 = 0; num424 < num423; num424++) {
					bool flag32 = false;
					int num425 = 0;
					while (!flag32) {
						num425++;
						if (num425 > 1000)
							flag32 = true;

						int num426 = genRand.Next(300, Main.maxTilesX - 300);
						if (num426 <= Main.maxTilesX / 2 - 100 || num426 >= Main.maxTilesX / 2 + 100) {
							int num427;
							for (num427 = 0; !Main.tile[num426, num427].active() && (double)num427 < Main.worldSurface; num427++) {
							}

							if (Main.tile[num426, num427].type == 0) {
								num427--;
								if (num427 > 150) {
									bool flag33 = true;
									for (int num428 = num426 - 50; num428 < num426 + 50; num428++) {
										for (int num429 = num427 - 50; num429 < num427 + 50; num429++) {
											if (Main.tile[num428, num429].active()) {
												int type2 = Main.tile[num428, num429].type;
												if (type2 == 41 || type2 == 43 || type2 == 44 || type2 == 189 || type2 == 196)
													flag33 = false;
											}
										}
									}

									if (flag33 && Main.setting.IsGiantTree != 0)
										flag32 = GrowLivingTree(num426, num427);
								}
							}
						}
					}
				}

				Main.tileSolid[192] = false;
			});

			AddGenerationPass("Wood Tree Walls", delegate {
				for (int num418 = 25; num418 < Main.maxTilesX - 25; num418++) {
					for (int num419 = 25; (double)num419 < Main.worldSurface; num419++) {
						if (Main.tile[num418, num419].type == 191 || Main.tile[num418, num419 - 1].type == 191 || Main.tile[num418 - 1, num419].type == 191 || Main.tile[num418 + 1, num419].type == 191 || Main.tile[num418, num419 + 1].type == 191) {
							bool flag31 = true;
							for (int num420 = num418 - 1; num420 <= num418 + 1; num420++) {
								for (int num421 = num419 - 1; num421 <= num419 + 1; num421++) {
									if (num420 != num418 && num421 != num419 && Main.tile[num420, num421].type != 191 && Main.tile[num420, num421].wall != 78)
										flag31 = false;
								}
							}

							if (flag31)
								Main.tile[num418, num419].wall = 78;
						}
					}
				}
			});

			AddGenerationPass("Altars", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[26].Value;
				int num413 = (int)((float)(Main.maxTilesX * Main.maxTilesY) * 2E-05f);
				for (int num414 = 0; num414 < num413; num414++) {
					progress.Set((float)num414 / (float)num413);
					for (int num415 = 0; num415 < 10000; num415++) {
						int num416 = genRand.Next(1, Main.maxTilesX - 3);
						int num417 = (int)(worldSurfaceHigh + 20.0);
						int style2 = crimson ? 1 : 0;
						if (Main.setting.IsCorruption == 3 || Main.setting.IsCorruption == 4)
						{
							style2 = WorldGen.genRand.Next(2); // TODO Fix altars to be correct maybe?
						}
						if (!Main.setting.NoAltar)
						{
							WorldGen.Place3x2(num416, num417, 26, style2);
							if (Main.tile[num416, num417].type == 26)
							{
								break;
							}
						}
					}
				}
			});

			AddGenerationPass("Wet Jungle", delegate {
				for (int num411 = 0; num411 < Main.maxTilesX; num411++) {
					i2 = num411;
					for (int num412 = (int)worldSurfaceLow; (double)num412 < Main.worldSurface - 1.0; num412++) {
						if (Main.tile[i2, num412].active()) {
							if (Main.tile[i2, num412].type == 60) {
								Main.tile[i2, num412 - 1].liquid = byte.MaxValue;
								Main.tile[i2, num412 - 2].liquid = byte.MaxValue;
							}

							break;
						}
					}
				}
			});

			AddGenerationPass("Remove Water From Sand", delegate {
				for (int num408 = 400; num408 < Main.maxTilesX - 400; num408++) {
					i2 = num408;
					for (int num409 = (int)worldSurfaceLow; (double)num409 < Main.worldSurface - 1.0; num409++) {
						if (Main.tile[i2, num409].active()) {
							ushort type = Main.tile[i2, num409].type;
							if (type == 53 || type == 396 || type == 397 || type == 404 || type == 407) {
								int num410 = num409;
								while ((double)num410 > worldSurfaceLow) {
									num410--;
									Main.tile[i2, num410].liquid = 0;
								}
							}

							break;
						}
					}
				}

				Main.tileSolid[192] = true;
			});

			AddGenerationPass("Jungle Temple", delegate (GenerationProgress progress) {
				if (Main.setting.NoJungle) return;
				//if (Main.setting.) -- i will return to this idea -greenbiridmusic
				//for (int tottemples = 0, tottemples < Main.setting., tottemples++ )
				progress.Message = Lang.gen[70].Value;
				bool flag30 = true;
				while (flag30) {
					int num406 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 500);
					if (Main.maxTilesY < 1000) num406 = WorldGen.genRand.Next((int)Main.rockLayer, Main.maxTilesY - 200);
					int num407 = (dungeonSide >= 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.4)) : genRand.Next((int)((double)Main.maxTilesX * 0.6), (int)((double)Main.maxTilesX * 0.85));
					if (Main.tile[num407, num406].active() && Main.tile[num407, num406].type == 60) {
						flag30 = false;
												if (!Main.setting.NoTemple)
						{
							makeTemple(num407, num406);
						}
					}
				}
			});

			AddGenerationPass("Hives", delegate (GenerationProgress progress) {
				if (Main.setting.NoHive || Main.setting.NoJungle) return;
				// TODO Hives Ammount
				progress.Message = Lang.gen[71].Value;
				float num397 = Main.maxTilesX / 4200f;
				float num398 = 1 + genRand.Next((int)(5f * num397), (int)(8f * num397));
				num398 *= Main.setting.HiveMultiplier;
				int num399 = 10000;
				while (num398 > 0f && num399 > 0) {
					num399--;
					Point origin2 = RandomWorldPoint((int)(Main.worldSurface + Main.rockLayer) >> 1, 20, 300, 20);
					if (Biomes<HiveBiome>.Place(origin2, structures)) {
						num398 -= 1f;
						int num400 = genRand.Next(5);
						int num401 = 0;
						int num402 = 10000;
						while (num401 < num400 && num402 > 0) {
							float num403 = genRand.NextFloat() * 60f + 30f;
							float num404 = genRand.NextFloat() * ((float)Math.PI * 2f);
							int num405 = (int)(Math.Cos(num404) * (double)num403) + origin2.X;
							int y8 = (int)(Math.Sin(num404) * (double)num403) + origin2.Y;
							num402--;
							if (num405 > 50 && num405 < Main.maxTilesX - 50 && Biomes<HoneyPatchBiome>.Place(num405, y8, structures))
								num401++;
						}
					}
				}
			});

			AddGenerationPass("Jungle Chests", delegate {
				int num371 = genRand.Next(40, Main.maxTilesX - 40);
				int num372 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
				if (Main.maxTilesY < 1000) num372 = WorldGen.genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 100);
				float num373 = genRand.Next(7, 12);
				num373 *= ((float)Main.maxTilesX / 4200);
				num373 *= Main.setting.JungleShrineMultiplier;
				for (int num374 = 0; (float)num374 < num373; num374++) {
					bool flag28 = true;
					while (flag28) {
						num371 = genRand.Next(40, Main.maxTilesX / 2 - 40);
						if (dungeonSide < 0)
							num371 += Main.maxTilesX / 2;

						num372 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
						if (Main.tile[num371, num372].type == 60) {
							int num375 = 30;
							flag28 = false;
							for (int num376 = num371 - num375; num376 < num371 + num375; num376 += 3) {
								for (int num377 = num372 - num375; num377 < num372 + num375; num377 += 3) {
									if (Main.tile[num376, num377].active() && (Main.tile[num376, num377].type == 225 || Main.tile[num376, num377].type == 229 || Main.tile[num376, num377].type == 226 || Main.tile[num376, num377].type == 119 || Main.tile[num376, num377].type == 120))
										flag28 = false;

									if (Main.tile[num376, num377].wall == 86 || Main.tile[num376, num377].wall == 87)
										flag28 = false;
								}
							}
						}

						if (!flag28) {
							int num378 = genRand.Next(2, 4);
							int num379 = genRand.Next(2, 4);
							int num380 = 0;
							if (Main.setting.ShrineType == 6)
								{
									jungleHut = (ushort)WorldGen.genRand.Next(5);
									if (jungleHut == 0)
									{
										jungleHut = 119;
									}
									else if (jungleHut == 1)
									{
										jungleHut = 120;
									}
									else if (jungleHut == 2)
									{
										jungleHut = 158;
									}
									else if (jungleHut == 3)
									{
										jungleHut = 175;
									}
									else if (jungleHut == 4)
									{
										jungleHut = 45;
									}
								}
							if (jungleHut == 119)
								num380 = 23;
							else if (jungleHut == 120)
								num380 = 24;
							else if (jungleHut == 158)
								num380 = 42;
							else if (jungleHut == 175)
								num380 = 45;
							else if (jungleHut == 45)
								num380 = 10;

							for (int num381 = num371 - num378 - 1; num381 <= num371 + num378 + 1; num381++) {
								for (int num382 = num372 - num379 - 1; num382 <= num372 + num379 + 1; num382++) {
									Main.tile[num381, num382].active(active: true);
									Main.tile[num381, num382].type = jungleHut;
									Main.tile[num381, num382].liquid = 0;
									Main.tile[num381, num382].lava(lava: false);
								}
							}

							for (int num383 = num371 - num378; num383 <= num371 + num378; num383++) {
								for (int num384 = num372 - num379; num384 <= num372 + num379; num384++) {
									Main.tile[num383, num384].active(active: false);
									Main.tile[num383, num384].wall = (byte)num380;
								}
							}

							bool flag29 = false;
							int num385 = 0;
							while (!flag29 && num385 < 100) {
								num385++;
								int num386 = genRand.Next(num371 - num378, num371 + num378 + 1);
								int num387 = genRand.Next(num372 - num379, num372 + num379 - 2);
								PlaceTile(num386, num387, 4, mute: true, forced: false, -1, 3);
								if (TileLoader.IsTorch(Main.tile[num386, num387].type))
									flag29 = true;
							}

							for (int num388 = num371 - num378 - 1; num388 <= num371 + num378 + 1; num388++) {
								for (int num389 = num372 + num379 - 2; num389 <= num372 + num379; num389++) {
									Main.tile[num388, num389].active(active: false);
								}
							}

							for (int num390 = num371 - num378 - 1; num390 <= num371 + num378 + 1; num390++) {
								for (int num391 = num372 + num379 - 2; num391 <= num372 + num379 - 1; num391++) {
									Main.tile[num390, num391].active(active: false);
								}
							}

							for (int num392 = num371 - num378 - 1; num392 <= num371 + num378 + 1; num392++) {
								int num393 = 4;
								int num394 = num372 + num379 + 2;
								while (!Main.tile[num392, num394].active() && num394 < Main.maxTilesY && num393 > 0) {
									Main.tile[num392, num394].active(active: true);
									Main.tile[num392, num394].type = 59;
									num394++;
									num393--;
								}
							}

							num378 -= genRand.Next(1, 3);
							int num395 = num372 - num379 - 2;
							while (num378 > -1) {
								for (int num396 = num371 - num378 - 1; num396 <= num371 + num378 + 1; num396++) {
									Main.tile[num396, num395].active(active: true);
									Main.tile[num396, num395].type = jungleHut;
								}

								num378 -= genRand.Next(1, 3);
								num395--;
							}

							JChestX[numJChests] = num371;
							JChestY[numJChests] = num372;
							numJChests++;
						}
					}
				}

				Main.tileSolid[137] = false;
			});

			AddGenerationPass("Smooth World", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[60].Value;
				for (int num367 = 20; num367 < Main.maxTilesX - 20; num367++) {
					float value12 = (float)num367 / (float)Main.maxTilesX;
					progress.Set(value12);
					for (int num368 = 20; num368 < Main.maxTilesY - 20; num368++) {
						if (Main.tile[num367, num368].type != 48 && Main.tile[num367, num368].type != 137 && Main.tile[num367, num368].type != 232 && Main.tile[num367, num368].type != 191 && Main.tile[num367, num368].type != 151 && Main.tile[num367, num368].type != 274) {
							if (!Main.tile[num367, num368 - 1].active()) {
								if (SolidTile(num367, num368) && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num367, num368].type]) {
									if (!Main.tile[num367 - 1, num368].halfBrick() && !Main.tile[num367 + 1, num368].halfBrick() && Main.tile[num367 - 1, num368].slope() == 0 && Main.tile[num367 + 1, num368].slope() == 0) {
										if (SolidTile(num367, num368 + 1)) {
											if (!SolidTile(num367 - 1, num368) && !Main.tile[num367 - 1, num368 + 1].halfBrick() && SolidTile(num367 - 1, num368 + 1) && SolidTile(num367 + 1, num368) && !Main.tile[num367 + 1, num368 - 1].active()) {
												if (genRand.Next(2) == 0)
													SlopeTile(num367, num368, 2);
												else
													PoundTile(num367, num368);
											}
											else if (!SolidTile(num367 + 1, num368) && !Main.tile[num367 + 1, num368 + 1].halfBrick() && SolidTile(num367 + 1, num368 + 1) && SolidTile(num367 - 1, num368) && !Main.tile[num367 - 1, num368 - 1].active()) {
												if (genRand.Next(2) == 0)
													SlopeTile(num367, num368, 1);
												else
													PoundTile(num367, num368);
											}
											else if (SolidTile(num367 + 1, num368 + 1) && SolidTile(num367 - 1, num368 + 1) && !Main.tile[num367 + 1, num368].active() && !Main.tile[num367 - 1, num368].active()) {
												PoundTile(num367, num368);
											}

											if (SolidTile(num367, num368)) {
												if (SolidTile(num367 - 1, num368) && SolidTile(num367 + 1, num368 + 2) && !Main.tile[num367 + 1, num368].active() && !Main.tile[num367 + 1, num368 + 1].active() && !Main.tile[num367 - 1, num368 - 1].active()) {
													KillTile(num367, num368);
												}
												else if (SolidTile(num367 + 1, num368) && SolidTile(num367 - 1, num368 + 2) && !Main.tile[num367 - 1, num368].active() && !Main.tile[num367 - 1, num368 + 1].active() && !Main.tile[num367 + 1, num368 - 1].active()) {
													KillTile(num367, num368);
												}
												else if (!Main.tile[num367 - 1, num368 + 1].active() && !Main.tile[num367 - 1, num368].active() && SolidTile(num367 + 1, num368) && SolidTile(num367, num368 + 2)) {
													if (genRand.Next(5) == 0)
														KillTile(num367, num368);
													else if (genRand.Next(5) == 0)
														PoundTile(num367, num368);
													else
														SlopeTile(num367, num368, 2);
												}
												else if (!Main.tile[num367 + 1, num368 + 1].active() && !Main.tile[num367 + 1, num368].active() && SolidTile(num367 - 1, num368) && SolidTile(num367, num368 + 2)) {
													if (genRand.Next(5) == 0)
														KillTile(num367, num368);
													else if (genRand.Next(5) == 0)
														PoundTile(num367, num368);
													else
														SlopeTile(num367, num368, 1);
												}
											}
										}

										if (SolidTile(num367, num368) && !Main.tile[num367 - 1, num368].active() && !Main.tile[num367 + 1, num368].active())
											KillTile(num367, num368);
									}
								}
								else if (!Main.tile[num367, num368].active() && Main.tile[num367, num368 + 1].type != 151 && Main.tile[num367, num368 + 1].type != 274) {
									if (Main.tile[num367 + 1, num368].type != 190 && Main.tile[num367 + 1, num368].type != 48 && Main.tile[num367 + 1, num368].type != 232 && SolidTile(num367 - 1, num368 + 1) && SolidTile(num367 + 1, num368) && !Main.tile[num367 - 1, num368].active() && !Main.tile[num367 + 1, num368 - 1].active()) {
										PlaceTile(num367, num368, Main.tile[num367, num368 + 1].type);
										if (genRand.Next(2) == 0)
											SlopeTile(num367, num368, 2);
										else
											PoundTile(num367, num368);
									}

									if (Main.tile[num367 - 1, num368].type != 190 && Main.tile[num367 - 1, num368].type != 48 && Main.tile[num367 - 1, num368].type != 232 && SolidTile(num367 + 1, num368 + 1) && SolidTile(num367 - 1, num368) && !Main.tile[num367 + 1, num368].active() && !Main.tile[num367 - 1, num368 - 1].active()) {
										PlaceTile(num367, num368, Main.tile[num367, num368 + 1].type);
										if (genRand.Next(2) == 0)
											SlopeTile(num367, num368, 1);
										else
											PoundTile(num367, num368);
									}
								}
							}
							else if (!Main.tile[num367, num368 + 1].active() && genRand.Next(2) == 0 && SolidTile(num367, num368) && !Main.tile[num367 - 1, num368].halfBrick() && !Main.tile[num367 + 1, num368].halfBrick() && Main.tile[num367 - 1, num368].slope() == 0 && Main.tile[num367 + 1, num368].slope() == 0 && SolidTile(num367, num368 - 1)) {
								if (SolidTile(num367 - 1, num368) && !SolidTile(num367 + 1, num368) && SolidTile(num367 - 1, num368 - 1))
									SlopeTile(num367, num368, 3);
								else if (SolidTile(num367 + 1, num368) && !SolidTile(num367 - 1, num368) && SolidTile(num367 + 1, num368 - 1))
									SlopeTile(num367, num368, 4);
							}

							if (TileID.Sets.Conversion.Sand[Main.tile[num367, num368].type])
								Tile.SmoothSlope(num367, num368, applyToNeighbors: false);
						}
					}
				}

				for (int num369 = 20; num369 < Main.maxTilesX - 20; num369++) {
					for (int num370 = 20; num370 < Main.maxTilesY - 20; num370++) {
						if (genRand.Next(2) == 0 && !Main.tile[num369, num370 - 1].active() && Main.tile[num369, num370].type != 137 && Main.tile[num369, num370].type != 48 && Main.tile[num369, num370].type != 232 && Main.tile[num369, num370].type != 191 && Main.tile[num369, num370].type != 151 && Main.tile[num369, num370].type != 274 && Main.tile[num369, num370].type != 75 && Main.tile[num369, num370].type != 76 && SolidTile(num369, num370) && Main.tile[num369 - 1, num370].type != 137 && Main.tile[num369 + 1, num370].type != 137) {
							if (SolidTile(num369, num370 + 1) && SolidTile(num369 + 1, num370) && !Main.tile[num369 - 1, num370].active())
								SlopeTile(num369, num370, 2);

							if (SolidTile(num369, num370 + 1) && SolidTile(num369 - 1, num370) && !Main.tile[num369 + 1, num370].active())
								SlopeTile(num369, num370, 1);
						}

						if (Main.tile[num369, num370].slope() == 1 && !SolidTile(num369 - 1, num370)) {
							SlopeTile(num369, num370);
							PoundTile(num369, num370);
						}

						if (Main.tile[num369, num370].slope() == 2 && !SolidTile(num369 + 1, num370)) {
							SlopeTile(num369, num370);
							PoundTile(num369, num370);
						}
					}
				}

				Main.tileSolid[137] = true;
				Main.tileSolid[190] = false;
				Main.tileSolid[192] = false;
			});

			AddGenerationPass("Settle Liquids", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[27].Value;
				Liquid.QuickWater(3);
				WaterCheck();
				int num362 = 0;
				Liquid.quickSettle = true;
				while (num362 < 10) {
					int num363 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num362++;
					float num364 = 0f;
					while (Liquid.numLiquid > 0) {
						float num365 = (float)(num363 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (float)num363;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num363)
							num363 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;

						if (num365 > num364)
							num364 = num365;
						else
							num365 = num364;

						if (num362 == 1)
							progress.Set(num365 / 3f + 0.33f);

						int num366 = 10;
						if (num362 > num366)
							num366 = num362;

						Liquid.UpdateLiquid();
					}

					WaterCheck();
					progress.Set((float)num362 * 0.1f / 3f + 0.66f);
				}

				Liquid.quickSettle = false;
				Main.tileSolid[190] = true;
			});

			AddGenerationPass("Waterfalls", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[69].Value;
				for (int num353 = 20; num353 < Main.maxTilesX - 20; num353++) {
					float num354 = (float)num353 / (float)Main.maxTilesX;
					progress.Set(num354 * 0.5f);
					for (int num355 = 20; num355 < Main.maxTilesY - 20; num355++) {
						if (SolidTile(num353, num355) && !Main.tile[num353 - 1, num355].active() && SolidTile(num353, num355 + 1) && !Main.tile[num353 + 1, num355].active() && (Main.tile[num353 - 1, num355].liquid > 0 || Main.tile[num353 + 1, num355].liquid > 0)) {
							bool flag27 = true;
							int num356 = genRand.Next(8, 20);
							int num357 = genRand.Next(8, 20);
							num356 = num355 - num356;
							num357 += num355;
							for (int num358 = num356; num358 <= num357; num358++) {
								if (Main.tile[num353, num358].halfBrick())
									flag27 = false;
							}

							if ((Main.tile[num353, num355].type == 75 || Main.tile[num353, num355].type == 76) && genRand.Next(10) != 0)
								flag27 = false;

							if (flag27)
								PoundTile(num353, num355);
						}
					}
				}

				for (int num359 = 20; num359 < Main.maxTilesX - 20; num359++) {
					float num360 = (float)num359 / (float)Main.maxTilesX;
					progress.Set(num360 * 0.5f + 0.5f);
					for (int num361 = 20; num361 < Main.maxTilesY - 20; num361++) {
						if (Main.tile[num359, num361].type != 48 && Main.tile[num359, num361].type != 232 && SolidTile(num359, num361) && SolidTile(num359, num361 + 1)) {
							if (!SolidTile(num359 + 1, num361) && Main.tile[num359 - 1, num361].halfBrick() && Main.tile[num359 - 2, num361].liquid > 0)
								PoundTile(num359, num361);

							if (!SolidTile(num359 - 1, num361) && Main.tile[num359 + 1, num361].halfBrick() && Main.tile[num359 + 2, num361].liquid > 0)
								PoundTile(num359, num361);
						}
					}
				}
			});

			AddGenerationPass("Ice", delegate {
				for (int num351 = 10; num351 < Main.maxTilesX - 10; num351++) {
					for (int num352 = (int)Main.worldSurface; num352 < Main.maxTilesY - 100; num352++) {
						if (Main.tile[num351, num352].liquid > 0 && !Main.tile[num351, num352].lava())
							MakeWateryIceThing(num351, num352);
					}
				}

				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
			});

			AddGenerationPass("Wall Variety", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[79].Value;
				float num348 = (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f;
				int num349 = (int)(300f * num348);
				int num350 = num349;
				ShapeData shapeData = new ShapeData();
				bool foundInvalidTile = default(bool);
				while (num349 > 0) {
					progress.Set(1f - (float)num349 / (float)num350);
					Point point = RandomWorldPoint((int)worldSurface, 2, 190, 2);
					Tile tile4 = Main.tile[point.X, point.Y];
					Tile tile5 = Main.tile[point.X, point.Y - 1];
					byte b = 0;
					if (tile4.type == 59 || tile4.type == 60)
						b = (byte)(204 + genRand.Next(4));
					else if (tile4.type == 1 && tile5.wall == 0)
						b = (((double)point.Y < rockLayer) ? ((byte)(196 + genRand.Next(4))) : ((point.Y >= lavaLine) ? ((byte)(208 + genRand.Next(4))) : ((byte)(212 + genRand.Next(4)))));

					if (tile4.active() && b != 0 && !tile5.active()) {
						foundInvalidTile = false;
						bool flag26 = WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 60, 147, 161, 396, 397), new Actions.Custom(delegate {
							foundInvalidTile = true;
							return true;
						})))));

						if (shapeData.Count > 50 && flag26 && !foundInvalidTile) {
							WorldUtils.Gen(new Point(point.X, point.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), new Actions.PlaceWall(b));
							num349--;
						}

						shapeData.Clear();
					}
				}
			});

			AddGenerationPass("Traps", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[34].Value;
				for (int num344 = 0; num344 < (int)((double)Main.maxTilesX * 0.05 * Main.setting.TrapMultiplier); num344++) {
					float value11 = (float)((double)num344 / ((double)Main.maxTilesX * 0.05 * Main.setting.TrapMultiplier));
					progress.Set(value11);
					//int Attempts = 0;
					for (int num345 = 0; num345 < 1150; num345++) {
						int num346 = genRand.Next(200, Main.maxTilesX - 200);
						int num347 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
						//Attempts += 1;
						if (Main.tile[num346, num347].wall == 0 && placeTrap(num346, num347))
							break;
					}
				}
				progress.Message = "Placing more traps: Dart";
					for (int k = 0; k < (int)((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalDartTrapMultiplier); k++)
					{
						float value = (float)((double)k / ((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalDartTrapMultiplier));
						progress.Set(value);
						//int Attempts = 0;
						for (int l = 0; l < 1000; l++)
						{
							int num = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
							int num2 = WorldGen.genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
							//Attempts += 1;
							if (Main.tile[num, num2].wall == 0 && WorldGen.placeTrap(num, num2, 0))
							{
								break;
							}
						}
					}
					progress.Message = "Placing more traps: Boulder";
					for (int k = 0; k < (int)((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalBoulderTrapMultiplier); k++)
					{
						float value = (float)((double)k / ((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalBoulderTrapMultiplier));
						progress.Set(value);
						//int Attempts = 0;
						for (int l = 0; l < 1000; l++)
						{
							int num = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
							int num2 = WorldGen.genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
							//Attempts += 1;
							if (Main.tile[num, num2].wall == 0 && WorldGen.placeTrap(num, num2, 1))
							{
								break;
							}
						}
					}
					progress.Message = "Placing more traps: Explosive";
					for (int k = 0; k < (int)((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalExplosiveTrapMultiplier); k++)
					{
						float value = (float)((double)k / ((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalExplosiveTrapMultiplier));
						progress.Set(value);
						//int Attempts = 0;
						for (int l = 0; l < 10000; l++)
						{
							int num = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
							int num2 = WorldGen.genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
							//Attempts += 1;
							if (Main.tile[num, num2].wall == 0 && WorldGen.placeTrap(num, num2, 2))
							{
								break;
							}
						}
					}
					progress.Message = "Placing more traps: Geyser";
					for (int k = 0; k < (int)((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalGeyserTrapMultiplier); k++)
					{
						float value = (float)((double)k / ((double)Main.maxTilesX * 0.05 * Main.setting.AdditionalGeyserTrapMultiplier));
						progress.Set(value);
						//int Attempts = 0;
						for (int l = 0; l < 10000; l++)
						{
							int num = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
							int num2 = WorldGen.genRand.Next(WorldGen.lavaLine + 30, Main.maxTilesY - 300);
							//Attempts += 1;
							if (Main.tile[num, num2].wall == 0 && WorldGen.placeTrap(num, num2, 3))//) || Attempts > 10000)
							{
								break;
							}
						}
					}
					Tile.WireTypeOverride = -1;
			});

			AddGenerationPass("Life Crystals", delegate (GenerationProgress progress) {
				dub2 = Main.maxTilesX / 4200;
				progress.Message = Lang.gen[28].Value;
				for (int num342 = 0; num342 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05 * Main.setting.CrystalHeartMultiplier); num342++) {
					float value10 = (float)((double)num342 / ((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05 * Main.setting.CrystalHeartMultiplier));
					progress.Set(value10);
					bool flag25 = false;
					int num343 = 0;
					while (!flag25) {
						if (AddLifeCrystal(genRand.Next(40, Main.maxTilesX - 40), genRand.Next((int)(worldSurfaceHigh + 20.0), Main.maxTilesY - 300))) {
							flag25 = true;
						}
						else {
							num343++;
							if (num343 >= 10000)
								flag25 = true;
						}
					}
				}

				Main.tileSolid[225] = false;
			});

			AddGenerationPass("Statues", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[29].Value;
				int num336 = 0;
				int num337 = (int)((float)(statueList.Length * 2) * dub2 * Main.setting.StatueMultiplier);
				for (int num338 = 0; num338 < num337; num338++) {
					if (num336 >= statueList.Length)
						num336 = 0;

					int x11 = statueList[num336].X;
					int y7 = statueList[num336].Y;
					float value9 = num338 / num337;
					progress.Set(value9);
					bool flag24 = false;
					int num339 = 0;
					while (!flag24) {
						int num340 = genRand.Next(20, Main.maxTilesX - 20);
						int num341;
						for (num341 = genRand.Next((int)(worldSurfaceHigh + 20.0), Main.maxTilesY - 300); !Main.tile[num340, num341].active(); num341++) {
						}

						num341--;
						PlaceTile(num340, num341, x11, mute: true, forced: true, -1, y7);
						if (Main.tile[num340, num341].active() && Main.tile[num340, num341].type == x11) {
							flag24 = true;
							if (StatuesWithTraps.Contains(num336))
								PlaceStatueTrap(num340, num341);

							num336++;
						}
						else {
							num339++;
							if (num339 >= 10000)
								flag24 = true;
						}
					}
				}
			});

			AddGenerationPass("Buried Chests", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[30].Value;
				Main.tileSolid[226] = true;
				Main.tileSolid[162] = true;
				Main.tileSolid[225] = true;
				// Remove shadow chests from here
				for (int num327 = 0; num327 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 1.6E-05 * Main.setting.UndergroundCabinMultiplier); num327++) {
					float value8 = (float)((double)num327 / ((double)(Main.maxTilesX * Main.maxTilesY) * 1.6E-05 * Main.setting.UndergroundCabinMultiplier));
					progress.Set(value8);
					bool flag23 = false;
					int num328 = 0;
					while (!flag23) {
						// number of shadow chests
						float num329 = genRand.Next((int)(5f * dub2), (int)(8f * dub2 + 1f));
						int num330 = genRand.Next(20, Main.maxTilesX - 20);
						int num331 = genRand.Next((int)(worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
						if ((float)num327 <= num329)
							num331 = genRand.Next(Main.maxTilesY - 200, Main.maxTilesY - 50);

						int num332 = 0;
						while (Main.wallDungeon[Main.tile[num330, num331].wall]) {
							num332++;
							num330 = genRand.Next(1, Main.maxTilesX);
							num331 = genRand.Next((int)(worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
							if (num332 < 1000 && (float)num327 <= num329)
								num331 = genRand.Next(Main.maxTilesY - 200, Main.maxTilesY - 50);
						}

						if ((float)num327 > num329) {
							for (int num333 = 10; num333 > 0; num333--) {
								int x10 = genRand.Next(80, Main.maxTilesX - 80);
								int y6 = genRand.Next((int)(worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
								if (Biomes<CaveHouseBiome>.Place(x10, y6, structures)) {
									flag23 = true;
									break;
								}
							}
						}
						else /* if (AddBuriedChest(num330, num331)) */ {
							flag23 = true;
						}

						num328++;
						if (num328 >= 1000)
							flag23 = true;
					}
				}

				// Shadow only
					float numberShadowChests = (float)WorldGen.genRand.Next((int)(5f * dub2 * Main.setting.ShadowChestMultiplier), (int)(8f * dub2 * Main.setting.ShadowChestMultiplier + 1f)); // number of shadow chests
					for (int k = 0; k < numberShadowChests; k++)
					{
						bool flag2 = false;
						int num = 0;
						while (!flag2)
						{
							int num3 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
							int num4 = WorldGen.genRand.Next(Main.maxTilesY - 200, Main.maxTilesY - 50);
							while (Main.wallDungeon[(int)Main.tile[num3, num4].wall])
							{
								num3 = WorldGen.genRand.Next(1, Main.maxTilesX);
								num4 = WorldGen.genRand.Next(Main.maxTilesY - 200, Main.maxTilesY - 50);
							}
							if (WorldGen.AddBuriedChest(num3, num4, 0, false, -1))
							{
								flag2 = true;
							}
							num++;
							if (num >= 1000)
							{
								flag2 = true;
							}
						}
					}
					int num334 = (int)(Main.setting.UndergroundCabinMultiplier * 2f * (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f);
				int num335 = 1000;
				while (num335 >= 0 && num334 >= 0) {
					if (Biomes<CaveHouseBiome>.Place(RandomRectanglePoint(UndergroundDesertLocation), structures))
						num334--;

					num335--;
				}

				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
				Main.tileSolid[225] = false;
			});

			AddGenerationPass("Surface Chests", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[31].Value;
				for (int num323 = 0; num323 < (int)((double)Main.maxTilesX * 0.005 * Main.setting.SurfaceChestMultiplier); num323++) {
					float value7 = (float)((double)num323 / ((double)Main.maxTilesX * 0.005 * Main.setting.SurfaceChestMultiplier));
					progress.Set(value7);
					bool flag21 = false;
					int num324 = 0;
					while (!flag21) {
						int num325 = genRand.Next(300, Main.maxTilesX - 300);
						int num326 = genRand.Next((int)worldSurfaceLow, (int)Main.worldSurface);
						bool flag22 = false;
						if (Main.tile[num325, num326].wall == 2 && !Main.tile[num325, num326].active())
							flag22 = true;

						if (flag22 && AddBuriedChest(num325, num326, 0, notNearOtherChests: true)) {
							flag21 = true;
						}
						else {
							num324++;
							if (num324 >= 2000)
								flag21 = true;
						}
					}
				}
			});

			AddGenerationPass("Jungle Chests Placement", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[32].Value;
				for (int num318 = 0; num318 < numJChests; num318++) {
					float value6 = num318 / numJChests;
					progress.Set(value6);
					int nextJungleChestItem = GetNextJungleChestItem();
					if (!AddBuriedChest(JChestX[num318] + genRand.Next(2), JChestY[num318], nextJungleChestItem, notNearOtherChests: false, 10)) {
						for (int num319 = JChestX[num318] - 1; num319 <= JChestX[num318] + 1; num319++) {
							for (int num320 = JChestY[num318]; num320 <= JChestY[num318] + 2; num320++) {
								KillTile(num319, num320);
							}
						}

						for (int num321 = JChestX[num318] - 1; num321 <= JChestX[num318] + 1; num321++) {
							for (int num322 = JChestY[num318]; num322 <= JChestY[num318] + 3; num322++) {
								if (num322 < Main.maxTilesY) {
									Main.tile[num321, num322].slope(0);
									Main.tile[num321, num322].halfBrick(halfBrick: false);
								}
							}
						}

						AddBuriedChest(JChestX[num318], JChestY[num318], nextJungleChestItem, notNearOtherChests: false, 10);
					}
				}
			});

			AddGenerationPass("Water Chests", delegate (GenerationProgress progress) {
				if (Main.setting.NoChest) return;
				progress.Message = Lang.gen[33].Value;
				int num311 = 0;
				for (int num312 = 0; (float)num312 < 9f * dub2 * Main.setting.WaterChestMultiplier; num312++) {
					float value5 = (float)num312 / (9f * dub2 * Main.setting.WaterChestMultiplier);
					progress.Set(value5);
					int num313 = 0;
					num311++;
					if (genRand.Next(15) == 0) {
						num313 = 863;
					}
					else {
						switch (num311) {
							case 1:
								num313 = 186;
								break;
							case 2:
								num313 = 277;
								break;
							default:
								num313 = 187;
								num311 = 0;
								break;
						}
					}

					bool flag20 = false;
					int Attempts = 0;
					while (!flag20 && Attempts < 10000) {
						int num314 = genRand.Next(1, Main.maxTilesX);
						int num315 = genRand.Next(1, Main.maxTilesY - 200);
						//Attempts = 0;
						//int Attempts = 0;
						while ((Main.tile[num314, num315].liquid < 200 || Main.tile[num314, num315].lava()) && Attempts < 10000) {
							num314 = genRand.Next(1, Main.maxTilesX);
							num315 = genRand.Next(1, Main.maxTilesY - 200);
							Attempts += 1;
						}
						if (Attempts < 10000) {
							flag20 = AddBuriedChest(num314, num315, num313, notNearOtherChests: false, 17);
						}
						//Attempts += 1;
					}

					flag20 = false;
					Attempts = 0;
					while (!flag20 && Attempts < 40000) {
						int num316 = genRand.Next(1, Main.maxTilesX);
						int num317 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 200);
						//Attempts = 0;
						//int Attempts = 0;
						while ((Main.tile[num316, num317].liquid < 200 || Main.tile[num316, num317].lava()) && Attempts < 40000) {
							num316 = genRand.Next(1, Main.maxTilesX);
							num317 = genRand.Next(1, Main.maxTilesY - 200);
							Attempts += 1;
						}
						if (Attempts < 40000) {
							flag20 = AddBuriedChest(num316, num317, num313, notNearOtherChests: false, 17);
						}
					}
				}
			});

			AddGenerationPass("Spider Caves", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[64].Value;
				maxTileCount = 3500;
				for (int num308 = 0; num308 < (int)((double)Main.maxTilesX * 0.005 * Main.setting.SpiderCaveMultiplier); num308++) {
					float value4 = (float)((double)num308 / ((double)Main.maxTilesX * 0.005 * Main.setting.SpiderCaveMultiplier));
					progress.Set(value4);
					int num309 = 0;
					int x9 = genRand.Next(200, Main.maxTilesX - 200);
					int y5 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
					int num310 = countTiles(x9, y5, jungle: false, lavaOk: true);
					while ((num310 >= 3500 || num310 < 500) && num309 < 500) {
						num309++;
						x9 = genRand.Next(200, Main.maxTilesX - 200);
						y5 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						num310 = countTiles(x9, y5, jungle: false, lavaOk: true);
					}

					if (num309 < 500)
						Spread.Spider(x9, y5);
				}

				Main.tileSolid[162] = true;
			});

			AddGenerationPass("Gem Caves", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[64].Value;
				maxTileCount = (int)(300 * Main.setting.GemCaveSizeMultiplier);
				WorldGen.countX = new int[WorldGen.maxTileCount];
				WorldGen.countY = new int[WorldGen.maxTileCount];
				for (int num305 = 0; num305 < (int)((double)Main.maxTilesX * 0.003 * Main.setting.GemCaveMultiplier); num305++) {
					float value3 = (float)((double)num305 / ((double)Main.maxTilesX * 0.003 * Main.setting.GemCaveMultiplier));
					progress.Set(value3);
					int num306 = 0;
					int x8 = genRand.Next(200, Main.maxTilesX - 200);
					int y4 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
					int num307 = countTiles(x8, y4);
					while ((num307 >= (int)(300 * Main.setting.GemCaveSizeMultiplier) || num307 < 50 || lavaCount > 0 || iceCount > 0 || rockCount == 0) && num306 < 1000) {
						num306++;
						x8 = genRand.Next(200, Main.maxTilesX - 200);
						y4 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						num307 = countTiles(x8, y4);
					}

					if (num306 < 1000)
						gemCave(x8, y4);
				}
				WorldGen.countX = new int[3500];
				WorldGen.countY = new int[3500];
			});

			AddGenerationPass("Moss", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[61].Value;
				randMoss();
				maxTileCount = 2500;
				for (int num285 = 0; num285 < (int)((double)Main.maxTilesX * 0.01); num285++) {
					float value2 = (float)((double)num285 / ((double)Main.maxTilesX * 0.01));
					progress.Set(value2);
					int num286 = 0;
					int x7 = genRand.Next(200, Main.maxTilesX - 200);
					int y3 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, waterLine);
					int num287 = countTiles(x7, y3);
					while ((num287 >= 2500 || num287 < 10 || lavaCount > 0 || iceCount > 0 || rockCount == 0) && num286 < 1000) {
						num286++;
						x7 = genRand.Next(200, Main.maxTilesX - 200);
						y3 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						num287 = countTiles(x7, y3);
					}

					if (num286 < 1000) {
						setMoss(x7, y3);
						Spread.Moss(x7, y3);
					}
				}

				for (int num288 = 0; num288 < Main.maxTilesX; num288++) {
					int num289 = genRand.Next(50, Main.maxTilesX - 50);
					int num290 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, lavaLine);
					if (Main.tile[num289, num290].type == 1) {
						setMoss(num289, num290);
						Main.tile[num289, num290].type = mossTile;
					}
				}

				float num291 = (float)Main.maxTilesX * 0.05f;
				while (num291 > 0f) {
					int num292 = genRand.Next(50, Main.maxTilesX - 50);
					int num293 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, lavaLine);
					if (Main.tile[num292, num293].type == 1 && (!Main.tile[num292 - 1, num293].active() || !Main.tile[num292 + 1, num293].active() || !Main.tile[num292, num293 - 1].active() || !Main.tile[num292, num293 + 1].active())) {
						setMoss(num292, num293);
						Main.tile[num292, num293].type = mossTile;
						num291 -= 1f;
					}
				}

				num291 = (float)Main.maxTilesX * 0.065f;
				while (num291 > 0f) {
					int num294 = genRand.Next(50, Main.maxTilesX - 50);
					int num295 = genRand.Next(waterLine, Main.maxTilesY - 200);
					if (Main.tile[num294, num295].type == 1 && (!Main.tile[num294 - 1, num295].active() || !Main.tile[num294 + 1, num295].active() || !Main.tile[num294, num295 - 1].active() || !Main.tile[num294, num295 + 1].active())) {
						int num296 = 25;
						int num297 = 0;
						for (int num298 = num294 - num296; num298 < num294 + num296; num298++) {
							for (int num299 = num295 - num296; num299 < num295 + num296; num299++) {
								if (Main.tile[num298, num299].liquid > 0 && Main.tile[num298, num299].lava())
									num297++;
							}
						}

						if (num297 > 20) {
							Main.tile[num294, num295].type = 381;
							num291 -= 1f;
						}
						else {
							num291 -= 0.002f;
						}
					}
				}

				for (int num300 = 0; num300 < Main.maxTilesX; num300++) {
					for (int num301 = 0; num301 < Main.maxTilesY; num301++) {
						if (Main.tile[num300, num301].active() && Main.tileMoss[Main.tile[num300, num301].type]) {
							for (int num302 = 0; num302 < 4; num302++) {
								int num303 = num300;
								int num304 = num301;
								if (num302 == 0)
									num303--;

								if (num302 == 1)
									num303++;

								if (num302 == 2)
									num304--;

								if (num302 == 3)
									num304++;

								try {
									grassSpread = 0;
									SpreadGrass(num303, num304, 1, Main.tile[num300, num301].type, repeat: true, 0);
								}
								catch {
									grassSpread = 0;
									SpreadGrass(num303, num304, 1, Main.tile[num300, num301].type, repeat: false, 0);
								}
							}
						}
					}
				}
			});

			AddGenerationPass("Temple", delegate {
				Main.tileSolid[162] = false;
				Main.tileSolid[226] = true;
				templePart2();
				Main.tileSolid[232] = false;
			});

			AddGenerationPass("Ice Walls", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[63].Value;
				maxTileCount = 1500;
				for (int num274 = 0; num274 < (int)((double)Main.maxTilesX * 0.04); num274++) {
					float num275 = (float)((double)num274 / ((double)Main.maxTilesX * 0.04));
					progress.Set(num275 * 0.66f);
					int num276 = 0;
					int x6 = genRand.Next(200, Main.maxTilesX - 200);
					int y2 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
					int num277 = countTiles(x6, y2, jungle: false, lavaOk: true);
					while ((num277 >= 1500 || num277 < 10) && num276 < 500) {
						num276++;
						x6 = genRand.Next(200, Main.maxTilesX - 200);
						y2 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
						num277 = countTiles(x6, y2, jungle: false, lavaOk: true);
					}

					if (num276 < 500) {
						int num278 = genRand.Next(2);
						if (iceCount > 0) {
							switch (num278) {
								case 0:
									num278 = 40;
									break;
								case 1:
									num278 = 71;
									break;
							}
						}
						else if (lavaCount > 0) {
							num278 = 79;
						}
						else {
							num278 = genRand.Next(4);
							switch (num278) {
								case 0:
									num278 = 59;
									break;
								case 1:
									num278 = 61;
									break;
								case 2:
									num278 = 170;
									break;
								case 3:
									num278 = 171;
									break;
							}
						}

						Spread.Wall(x6, y2, num278);
					}
				}

				maxTileCount = 1500;
				for (int num279 = 0; num279 < (int)((double)Main.maxTilesX * 0.02); num279++) {
					float num280 = (float)((double)num279 / ((double)Main.maxTilesX * 0.02));
					progress.Set(num280 * 0.34f + 0.66f);
					int num281 = 0;
					int num282 = genRand.Next(200, Main.maxTilesX - 200);
					int num283 = genRand.Next((int)Main.worldSurface, lavaLine);
					int num284 = 0;
					if (Main.tile[num282, num283].wall == 64)
						num284 = countTiles(num282, num283, jungle: true);

					while ((num284 >= 1500 || num284 < 10) && num281 < 1000) {
						num281++;
						num282 = genRand.Next(200, Main.maxTilesX - 200);
						num283 = genRand.Next((int)Main.worldSurface, lavaLine);
						if (!Main.wallHouse[Main.tile[num282, num283].wall])
							num284 = ((Main.tile[num282, num283].wall == 64) ? countTiles(num282, num283, jungle: true) : 0);
					}

					if (num281 < 1000)
						Spread.Wall2(num282, num283, 15);
				}
			});

			AddGenerationPass("Jungle Trees", delegate {
				for (int num272 = 0; num272 < Main.maxTilesX; num272++) {
					for (int num273 = (int)Main.worldSurface - 1; num273 < Main.maxTilesY - 350; num273++) {
						if (genRand.Next(10) == 0 && !Main.setting.NoTree)
							GrowUndergroundTree(num272, num273);
					}
				}
			});

			AddGenerationPass("Floating Island Houses", delegate {
				for (int num271 = 0; num271 < numIslandHouses; num271++) {
					if (!skyLake[num271])
						IslandHouse(fihX[num271], fihY[num271], fihT[num271]);
				}
			});

			AddGenerationPass("Quick Cleanup", delegate {
				Main.tileSolid[137] = false;
				Main.tileSolid[130] = false;
				for (int num269 = 20; num269 < Main.maxTilesX - 20; num269++) {
					for (int num270 = 20; num270 < Main.maxTilesY - 20; num270++) {
						if (Main.tile[num269, num270].type != 19 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num269, num270].type]) {
							if (Main.tile[num269, num270].topSlope() || Main.tile[num269, num270].halfBrick()) {
								if (!SolidTile(num269, num270 + 1))
									Main.tile[num269, num270].active(active: false);

								if (Main.tile[num269 + 1, num270].type == 137 || Main.tile[num269 - 1, num270].type == 137)
									Main.tile[num269, num270].active(active: false);
							}
							else if (Main.tile[num269, num270].bottomSlope()) {
								if (!SolidTile(num269, num270 - 1))
									Main.tile[num269, num270].active(active: false);

								if (Main.tile[num269 + 1, num270].type == 137 || Main.tile[num269 - 1, num270].type == 137)
									Main.tile[num269, num270].active(active: false);
							}
						}
					}
				}
			});

			AddGenerationPass("Pots", delegate (GenerationProgress progress) {
				Main.tileSolid[137] = true;
				Main.tileSolid[130] = true;
				progress.Message = Lang.gen[35].Value;
				for (int num262 = 0; num262 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008 * Main.setting.PotsMultiplier); num262++) {
					float num263 = (float)((double)num262 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008 * Main.setting.PotsMultiplier));
					progress.Set(num263);
					bool flag18 = false;
					int num264 = 0;
					while (!flag18) {
						int num265 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY - 10);
						if ((double)num263 > 0.93)
							num265 = Main.maxTilesY - 150;
						else if ((double)num263 > 0.75)
							num265 = (int)worldSurfaceLow;

						int num266 = genRand.Next(1, Main.maxTilesX);
						bool flag19 = false;
						for (int num267 = num265; num267 < Main.maxTilesY; num267++) {
							if (!flag19) {
								if (Main.tile[num266, num267].active() && Main.tileSolid[Main.tile[num266, num267].type] && !Main.tile[num266, num267 - 1].lava())
									flag19 = true;
							}
							else {
								int style = genRand.Next(0, 4);
								int num268 = 0;
								if (num267 < Main.maxTilesY - 5)
									num268 = Main.tile[num266, num267 + 1].type;

								if (num268 == 147 || num268 == 161 || num268 == 162)
									style = genRand.Next(4, 7);

								if (num268 == 60)
									style = genRand.Next(7, 10);

								if (Main.wallDungeon[Main.tile[num266, num267].wall])
									style = genRand.Next(10, 13);

								if (num268 == 41 || num268 == 43 || num268 == 44)
									style = genRand.Next(10, 13);

								if (num268 == 22 || num268 == 23 || num268 == 25)
									style = genRand.Next(16, 19);

								if (num268 == 199 || num268 == 203 || num268 == 204 || num268 == 200)
									style = genRand.Next(22, 25);

								if (num268 == 367)
									style = genRand.Next(31, 34);

								if (num268 == 226)
									style = genRand.Next(28, 31);

								if (num267 > Main.maxTilesY - 200)
									style = genRand.Next(13, 16);

								if (PlacePot(num266, num267, 28, style)) {
									flag18 = true;
									break;
								}

								num264++;
								if (num264 >= 10000) {
									flag18 = true;
									break;
								}
							}
						}
					}
				}
			});

			AddGenerationPass("Hellforge", delegate (GenerationProgress progress) {
				if (Main.setting.NoUnderworld) return;
				progress.Message = Lang.gen[36].Value;
				for (int num258 = 0; num258 < Main.maxTilesX / 200; num258++) {
					float value = num258 / (Main.maxTilesX / 200);
					progress.Set(value);
					bool flag17 = false;
					int num259 = 0;
					while (!flag17) {
						int num260 = genRand.Next(1, Main.maxTilesX);
						int num261 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 5);
						try {
							if (Main.tile[num260, num261].wall == 13 || Main.tile[num260, num261].wall == 14) {
								for (; !Main.tile[num260, num261].active(); num261++) {
								}

								num261--;
								PlaceTile(num260, num261, 77);
								if (Main.tile[num260, num261].type == 77) {
									flag17 = true;
								}
								else {
									num259++;
									if (num259 >= 10000)
										flag17 = true;
								}
							}
						}
						catch {
						}
					}
				}
			});

			AddGenerationPass("Spreading Grass", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[37].Value;
				for (int num256 = 0; num256 < Main.maxTilesX; num256++) {
					i2 = num256;
					bool flag16 = true;
					for (int num257 = 0; (double)num257 < Main.worldSurface - 1.0; num257++) {
						if (Main.tile[i2, num257].active()) {
							if (flag16 && Main.tile[i2, num257].type == 0) {
								try {
									grassSpread = 0;
									SpreadGrass(i2, num257, 0, 2, repeat: true, 0);
								}
								catch {
									grassSpread = 0;
									SpreadGrass(i2, num257, 0, 2, repeat: false, 0);
								}
							}

							if ((double)num257 > worldSurfaceHigh)
								break;

							flag16 = false;
						}
						else if (Main.tile[i2, num257].wall == 0) {
							flag16 = true;
						}
					}
				}
			});

			AddGenerationPass("Piles", delegate {
				Main.tileSolid[190] = false;
				Main.tileSolid[196] = false;
				Main.tileSolid[189] = false;
				Main.tileSolid[202] = false;
				for (int num205 = 0; (double)num205 < (double)Main.maxTilesX * 0.06; num205++) {
					bool flag9 = false;
					while (!flag9) {
						int num206 = genRand.Next(25, Main.maxTilesX - 25);
						int num207 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
						if (!Main.tile[num206, num207].active()) {
							int num208 = 186;
							for (; !Main.tile[num206, num207 + 1].active() && num207 < Main.maxTilesY - 5; num207++) {
							}

							int num209 = genRand.Next(22);
							if (num209 >= 16 && num209 <= 22)
								num209 = genRand.Next(22);

							if ((Main.tile[num206, num207 + 1].type == 0 || Main.tile[num206, num207 + 1].type == 1 || Main.tileMoss[Main.tile[num206, num207 + 1].type]) && genRand.Next(5) == 0) {
								num209 = genRand.Next(23, 29);
								num208 = 187;
							}

							if (num207 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num206, num207].wall] || Main.tile[num206, num207 + 1].type == 30 || Main.tile[num206, num207 + 1].type == 19 || Main.tile[num206, num207 + 1].type == 25 || Main.tile[num206, num207 + 1].type == 203) {
								num209 = genRand.Next(7);
								num208 = 186;
							}

							if (Main.tile[num206, num207 + 1].type == 147 || Main.tile[num206, num207 + 1].type == 161 || Main.tile[num206, num207 + 1].type == 162) {
								num209 = genRand.Next(26, 32);
								num208 = 186;
							}

							if (Main.tile[num206, num207 + 1].type == 60) {
								num208 = 187;
								num209 = genRand.Next(6);
							}

							if ((Main.tile[num206, num207 + 1].type == 57 || Main.tile[num206, num207 + 1].type == 58) && genRand.Next(3) < 2) {
								num208 = 187;
								num209 = genRand.Next(6, 9);
							}

							if (Main.tile[num206, num207 + 1].type == 226) {
								num208 = 187;
								num209 = genRand.Next(18, 23);
							}

							if (Main.tile[num206, num207 + 1].type == 70) {
								num209 = genRand.Next(32, 35);
								num208 = 186;
							}

							if (num208 == 186 && num209 >= 7 && num209 <= 15 && genRand.Next(75) == 0) {
								num208 = 187;
								num209 = 17;
							}

							if (Main.wallDungeon[Main.tile[num206, num207].wall] && genRand.Next(3) != 0) {
								flag9 = true;
							}
							else {
								PlaceTile(num206, num207, num208, mute: true, forced: false, -1, num209);
								if (Main.tile[num206, num207].type == 186 || Main.tile[num206, num207].type == 187)
									flag9 = true;

								if (flag9 && num208 == 186 && num209 <= 7) {
									int num210 = genRand.Next(1, 5);
									for (int num211 = 0; num211 < num210; num211++) {
										int num212 = num206 + genRand.Next(-10, 11);
										int num213 = num207 - genRand.Next(5);
										if (!Main.tile[num212, num213].active()) {
											for (; !Main.tile[num212, num213 + 1].active() && num213 < Main.maxTilesY - 5; num213++) {
											}

											int x2 = genRand.Next(12, 36);
											PlaceSmallPile(num212, num213, x2, 0, 185);
										}
									}
								}
							}
						}
					}
				}

				if (Main.setting.NoUnderworld == false) {
					for (int num214 = 0; (double)num214 < (double)Main.maxTilesX * 0.01; num214++) {
						bool flag10 = false;
						while (!flag10) {
							int num215 = genRand.Next(25, Main.maxTilesX - 25);
							int num216 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 10);
							if (!Main.tile[num215, num216].active()) {
								int num217 = 186;
								for (; !Main.tile[num215, num216 + 1].active() && num216 < Main.maxTilesY - 5; num216++) {
								}

								int num218 = genRand.Next(22);
								if (num218 >= 16 && num218 <= 22)
									num218 = genRand.Next(22);

								if (num216 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num215, num216].wall] || Main.tile[num215, num216 + 1].type == 30 || Main.tile[num215, num216 + 1].type == 19)
									num218 = genRand.Next(7);

								if ((Main.tile[num215, num216 + 1].type == 57 || Main.tile[num215, num216 + 1].type == 58) && genRand.Next(3) < 2) {
									num217 = 187;
									num218 = genRand.Next(6, 9);
								}

								if (Main.tile[num215, num216 + 1].type == 147 || Main.tile[num215, num216 + 1].type == 161 || Main.tile[num215, num216 + 1].type == 162)
									num218 = genRand.Next(26, 32);

								PlaceTile(num215, num216, num217, mute: true, forced: false, -1, num218);
								if (Main.tile[num215, num216].type == 186 || Main.tile[num215, num216].type == 187)
									flag10 = true;

								if (flag10 && num217 == 186 && num218 <= 7) {
									int num219 = genRand.Next(1, 5);
									for (int num220 = 0; num220 < num219; num220++) {
										int num221 = num215 + genRand.Next(-10, 11);
										int num222 = num216 - genRand.Next(5);
										if (!Main.tile[num221, num222].active()) {
											for (; !Main.tile[num221, num222 + 1].active() && num222 < Main.maxTilesY - 5; num222++) {
											}

											int x3 = genRand.Next(12, 36);
											PlaceSmallPile(num221, num222, x3, 0, 185);
										}
									}
								}
							}
						}
					}
				}

				for (int num223 = 0; (double)num223 < (double)Main.maxTilesX * 0.003; num223++) {
					bool flag11 = false;
					while (!flag11) {
						int num224 = 186;
						int num225 = genRand.Next(25, Main.maxTilesX - 25);
						int num226 = genRand.Next(10, (int)Main.worldSurface);
						if (!Main.tile[num225, num226].active()) {
							for (; !Main.tile[num225, num226 + 1].active() && num226 < Main.maxTilesY - 5; num226++) {
							}

							int num227 = genRand.Next(7, 13);
							if (num226 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num225, num226].wall] || Main.tile[num225, num226 + 1].type == 30 || Main.tile[num225, num226 + 1].type == 19 || Main.tile[num225, num226 + 1].type == 53 || Main.tile[num225, num226 + 1].type == 25 || Main.tile[num225, num226 + 1].type == 203)
								num227 = -1;

							if (Main.tile[num225, num226 + 1].type == 147 || Main.tile[num225, num226 + 1].type == 161 || Main.tile[num225, num226 + 1].type == 162)
								num227 = genRand.Next(26, 32);

							if (Main.tile[num225, num226 + 1].type == 2 || Main.tile[num225 - 1, num226 + 1].type == 2 || Main.tile[num225 + 1, num226 + 1].type == 2) {
								num224 = 187;
								num227 = genRand.Next(14, 17);
							}

							if (Main.tile[num225, num226 + 1].type == 151 || Main.tile[num225, num226 + 1].type == 274) {
								num224 = 186;
								num227 = genRand.Next(7);
							}

							if (num227 >= 0)
								PlaceTile(num225, num226, num224, mute: true, forced: false, -1, num227);

							if (Main.tile[num225, num226].type == num224)
								flag11 = true;
						}
					}
				}

				for (int num228 = 0; (double)num228 < (double)Main.maxTilesX * 0.0035; num228++) {
					bool flag12 = false;
					while (!flag12) {
						int num229 = genRand.Next(25, Main.maxTilesX - 25);
						int num230 = genRand.Next(10, (int)Main.worldSurface);
						if (!Main.tile[num229, num230].active() && Main.tile[num229, num230].wall > 0) {
							int num231 = 186;
							for (; !Main.tile[num229, num230 + 1].active() && num230 < Main.maxTilesY - 5; num230++) {
							}

							int num232 = genRand.Next(7, 13);
							if (num230 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num229, num230].wall] || Main.tile[num229, num230 + 1].type == 30 || Main.tile[num229, num230 + 1].type == 19)
								num232 = -1;

							if (Main.tile[num229, num230 + 1].type == 25)
								num232 = genRand.Next(7);

							if (Main.tile[num229, num230 + 1].type == 147 || Main.tile[num229, num230 + 1].type == 161 || Main.tile[num229, num230 + 1].type == 162)
								num232 = genRand.Next(26, 32);

							if (Main.tile[num229, num230 + 1].type == 2 || Main.tile[num229 - 1, num230 + 1].type == 2 || Main.tile[num229 + 1, num230 + 1].type == 2) {
								num231 = 187;
								num232 = genRand.Next(14, 17);
							}

							if (Main.tile[num229, num230 + 1].type == 151 || Main.tile[num229, num230 + 1].type == 274) {
								num231 = 186;
								num232 = genRand.Next(7);
							}

							if (num232 >= 0)
								PlaceTile(num229, num230, num231, mute: true, forced: false, -1, num232);

							if (Main.tile[num229, num230].type == num231)
								flag12 = true;

							if (flag12 && num232 <= 7) {
								int num233 = genRand.Next(1, 5);
								for (int num234 = 0; num234 < num233; num234++) {
									int num235 = num229 + genRand.Next(-10, 11);
									int num236 = num230 - genRand.Next(5);
									if (!Main.tile[num235, num236].active()) {
										for (; !Main.tile[num235, num236 + 1].active() && num236 < Main.maxTilesY - 5; num236++) {
										}

										int x4 = genRand.Next(12, 36);
										PlaceSmallPile(num235, num236, x4, 0, 185);
									}
								}
							}
						}
					}
				}

				for (int num237 = 0; (double)num237 < (double)Main.maxTilesX * 0.6; num237++) {
					bool flag13 = false;
					while (!flag13) {
						int num238 = genRand.Next(25, Main.maxTilesX - 25);
						int num239 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						if (Main.tile[num238, num239].wall == 87 && genRand.Next(2) == 0) {
							num238 = genRand.Next(25, Main.maxTilesX - 25);
							num239 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						}

						if (!Main.tile[num238, num239].active()) {
							for (; !Main.tile[num238, num239 + 1].active() && num239 < Main.maxTilesY - 5; num239++) {
							}

							int num240 = genRand.Next(2);
							int num241 = genRand.Next(36);
							if (num241 >= 28 && num241 <= 35)
								num241 = genRand.Next(36);

							if (num240 == 1) {
								num241 = genRand.Next(25);
								if (num241 >= 16 && num241 <= 24)
									num241 = genRand.Next(25);
							}

							if (num239 > Main.maxTilesY - 300) {
								if (num240 == 0)
									num241 = genRand.Next(12, 28);

								if (num240 == 1)
									num241 = genRand.Next(6, 16);
							}

							if (Main.wallDungeon[Main.tile[num238, num239].wall] || Main.tile[num238, num239 + 1].type == 30 || Main.tile[num238, num239 + 1].type == 19 || Main.tile[num238, num239 + 1].type == 25 || Main.tile[num238, num239 + 1].type == 203 || Main.tile[num238, num239].wall == 87) {
								if (num240 == 0 && num241 < 12)
									num241 += 12;

								if (num240 == 1 && num241 < 6)
									num241 += 6;

								if (num240 == 1 && num241 >= 17)
									num241 -= 10;
							}

							if (Main.tile[num238, num239 + 1].type == 147 || Main.tile[num238, num239 + 1].type == 161 || Main.tile[num238, num239 + 1].type == 162) {
								if (num240 == 0 && num241 < 12)
									num241 += 36;

								if (num240 == 1 && num241 >= 20)
									num241 += 6;

								if (num240 == 1 && num241 < 6)
									num241 += 25;
							}

							if (Main.tile[num238, num239 + 1].type == 151 || Main.tile[num238, num239 + 1].type == 274) {
								if (num240 == 0)
									num241 = genRand.Next(12, 28);

								if (num240 == 1)
									num241 = genRand.Next(12, 19);
							}

							flag13 = ((Main.wallDungeon[Main.tile[num238, num239].wall] && genRand.Next(3) != 0) || PlaceSmallPile(num238, num239, num241, num240, 185));
							if (flag13 && num240 == 1 && num241 >= 6 && num241 <= 15) {
								int num242 = genRand.Next(1, 5);
								for (int num243 = 0; num243 < num242; num243++) {
									int num244 = num238 + genRand.Next(-10, 11);
									int num245 = num239 - genRand.Next(5);
									if (!Main.tile[num244, num245].active()) {
										for (; !Main.tile[num244, num245 + 1].active() && num245 < Main.maxTilesY - 5; num245++) {
										}

										int x5 = genRand.Next(12, 36);
										PlaceSmallPile(num244, num245, x5, 0, 185);
									}
								}
							}
						}
					}
				}

				for (int num246 = 0; (float)num246 < (float)Main.maxTilesX * 0.02f; num246++) {
					bool flag14 = false;
					while (!flag14) {
						int num247 = genRand.Next(25, Main.maxTilesX - 25);
						int num248 = genRand.Next(15, (int)Main.worldSurface);
						if (!Main.tile[num247, num248].active()) {
							for (; !Main.tile[num247, num248 + 1].active() && num248 < Main.maxTilesY - 5; num248++) {
							}

							int num249 = genRand.Next(2);
							int num250 = genRand.Next(11);
							if (num249 == 1)
								num250 = genRand.Next(5);

							if (Main.tile[num247, num248 + 1].type == 147 || Main.tile[num247, num248 + 1].type == 161 || Main.tile[num247, num248 + 1].type == 162) {
								if (num249 == 0 && num250 < 12)
									num250 += 36;

								if (num249 == 1 && num250 >= 20)
									num250 += 6;

								if (num249 == 1 && num250 < 6)
									num250 += 25;
							}

							if (Main.tile[num247, num248 + 1].type == 2 && num249 == 1)
								num250 = genRand.Next(38, 41);

							if (Main.tile[num247, num248 + 1].type == 151 || Main.tile[num247, num248 + 1].type == 274) {
								if (num249 == 0)
									num250 = genRand.Next(12, 28);

								if (num249 == 1)
									num250 = genRand.Next(12, 19);
							}

							if (!Main.wallDungeon[Main.tile[num247, num248].wall] && Main.tile[num247, num248 + 1].type != 30 && Main.tile[num247, num248 + 1].type != 19 && Main.tile[num247, num248 + 1].type != 41 && Main.tile[num247, num248 + 1].type != 43 && Main.tile[num247, num248 + 1].type != 44 && Main.tile[num247, num248 + 1].type != 45 && Main.tile[num247, num248 + 1].type != 46 && Main.tile[num247, num248 + 1].type != 47 && Main.tile[num247, num248 + 1].type != 175 && Main.tile[num247, num248 + 1].type != 176 && Main.tile[num247, num248 + 1].type != 177 && Main.tile[num247, num248 + 1].type != 53 && Main.tile[num247, num248 + 1].type != 25 && Main.tile[num247, num248 + 1].type != 203)
								flag14 = PlaceSmallPile(num247, num248, num250, num249, 185);
						}
					}
				}

				for (int num251 = 0; (float)num251 < (float)Main.maxTilesX * 0.15f; num251++) {
					bool flag15 = false;
					while (!flag15) {
						int num252 = genRand.Next(25, Main.maxTilesX - 25);
						int num253 = genRand.Next(15, (int)Main.worldSurface);
						if (!Main.tile[num252, num253].active() && (Main.tile[num252, num253].wall == 2 || Main.tile[num252, num253].wall == 40)) {
							for (; !Main.tile[num252, num253 + 1].active() && num253 < Main.maxTilesY - 5; num253++) {
							}

							int num254 = genRand.Next(2);
							int num255 = genRand.Next(11);
							if (num254 == 1)
								num255 = genRand.Next(5);

							if (Main.tile[num252, num253 + 1].type == 147 || Main.tile[num252, num253 + 1].type == 161 || Main.tile[num252, num253 + 1].type == 162) {
								if (num254 == 0 && num255 < 12)
									num255 += 36;

								if (num254 == 1 && num255 >= 20)
									num255 += 6;

								if (num254 == 1 && num255 < 6)
									num255 += 25;
							}

							if (Main.tile[num252, num253 + 1].type == 2 && num254 == 1)
								num255 = genRand.Next(38, 41);

							if (Main.tile[num252, num253 + 1].type == 151 || Main.tile[num252, num253 + 1].type == 274) {
								if (num254 == 0)
									num255 = genRand.Next(12, 28);

								if (num254 == 1)
									num255 = genRand.Next(12, 19);
							}

							if (!Main.wallDungeon[Main.tile[num252, num253].wall] && Main.tile[num252, num253 + 1].type != 30 && Main.tile[num252, num253 + 1].type != 19 && Main.tile[num252, num253 + 1].type != 41 && Main.tile[num252, num253 + 1].type != 43 && Main.tile[num252, num253 + 1].type != 44 && Main.tile[num252, num253 + 1].type != 45 && Main.tile[num252, num253 + 1].type != 46 && Main.tile[num252, num253 + 1].type != 47 && Main.tile[num252, num253 + 1].type != 175 && Main.tile[num252, num253 + 1].type != 176 && Main.tile[num252, num253 + 1].type != 177 && Main.tile[num252, num253 + 1].type != 25 && Main.tile[num252, num253 + 1].type != 203)
								flag15 = PlaceSmallPile(num252, num253, num255, num254, 185);
						}
					}
				}

				Main.tileSolid[190] = true;
				Main.tileSolid[192] = true;
				Main.tileSolid[196] = true;
				Main.tileSolid[189] = true;
				Main.tileSolid[202] = true;
				Main.tileSolid[225] = true;
			});

			AddGenerationPass("Moss", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[38].Value;
				int num196 = 8;
				int num197 = 400;
				int num198 = 4;
				int num199 = 275;
				for (int num200 = 0; num200 < 3; num200++) {
					int num201;
					int num202;
					bool flag8;
					int maxValue2;
					switch (num200) {
						default:
							num201 = 5;
							num202 = num199;
							flag8 = false;
							maxValue2 = num198;
							break;
						case 1:
							num201 = num197;
							num202 = Main.maxTilesX - num197;
							flag8 = true;
							maxValue2 = num196;
							break;
						case 2:
							num201 = Main.maxTilesX - num199;
							num202 = Main.maxTilesX - 5;
							flag8 = false;
							maxValue2 = num198;
							break;
					}

					for (int num203 = num201; num203 < num202; num203++) {
						if (genRand.Next(maxValue2) == 0) {
							for (int num204 = 0; (double)num204 < Main.worldSurface - 1.0; num204++) {
								Tile tile2 = Main.tile[num203, num204];
								if (tile2.active() && tile2.type == 53) {
									Tile tile3 = Main.tile[num203, num204 - 1];
									if (!tile3.active() && tile3.wall == 0) {
										if (flag8) {
											PlantCactus(num203, num204);
											break;
										}

										if (Main.tile[num203, num204 - 2].liquid == byte.MaxValue && Main.tile[num203, num204 - 3].liquid == byte.MaxValue && Main.tile[num203, num204 - 4].liquid == byte.MaxValue) {
											if (genRand.Next(2) == 0)
												PlaceTile(num203, num204 - 1, 81, mute: true);
											else
												PlaceTile(num203, num204 - 1, 324, mute: true, forced: false, -1, genRand.Next(2));

											break;
										}

										if (Main.tile[num203, num204 - 2].liquid == 0) {
											PlaceTile(num203, num204 - 1, 324, mute: true, forced: false, -1, genRand.Next(2));
											break;
										}
									}
								}
							}
						}
					}
				}
			});

			// TODO Spawn Choices?
			AddGenerationPass("Spawn Point", delegate {
				int num190 = 5;
				bool flag7 = true;
				while (flag7) {
					int num191 = Main.maxTilesX / 2 + genRand.Next(-num190, num190 + 1);
					for (int num192 = 0; num192 < Main.maxTilesY; num192++) {
						if (Main.tile[num191, num192].active()) {
							Main.spawnTileX = num191;
							Main.spawnTileY = num192;
							break;
						}
					}

					flag7 = false;
					num190++;
					if ((double)Main.spawnTileY > Main.worldSurface)
						flag7 = true;

					if (Main.tile[Main.spawnTileX, Main.spawnTileY - 1].liquid > 0)
						flag7 = true;
				}

				int num193 = 10;
				while ((double)Main.spawnTileY > Main.worldSurface) {
					int num194 = genRand.Next(Main.maxTilesX / 2 - num193, Main.maxTilesX / 2 + num193);
					for (int num195 = 0; num195 < Main.maxTilesY; num195++) {
						if (Main.tile[num194, num195].active()) {
							Main.spawnTileX = num194;
							Main.spawnTileY = num195;
							break;
						}
					}

					num193++;
				}
			});

			AddGenerationPass("Grass Wall", delegate {
				maxTileCount = 3500;
				for (int num178 = 50; num178 < Main.maxTilesX - 50; num178++) {
					for (int num179 = 0; (double)num179 < Main.worldSurface - 10.0; num179++) {
						if (genRand.Next(4) == 0) {
							bool flag5 = false;
							int num180 = -1;
							int num181 = -1;
							if (Main.tile[num178, num179].active() && Main.tile[num178, num179].type == 2 && (Main.tile[num178, num179].wall == 2 || Main.tile[num178, num179].wall == 63)) {
								for (int num182 = num178 - 1; num182 <= num178 + 1; num182++) {
									for (int num183 = num179 - 1; num183 <= num179 + 1; num183++) {
										if (Main.tile[num182, num183].wall == 0 && !SolidTile(num182, num183))
											flag5 = true;
									}
								}

								if (flag5) {
									for (int num184 = num178 - 1; num184 <= num178 + 1; num184++) {
										for (int num185 = num179 - 1; num185 <= num179 + 1; num185++) {
											if ((Main.tile[num184, num185].wall == 2 || Main.tile[num184, num185].wall == 15) && !SolidTile(num184, num185)) {
												num180 = num184;
												num181 = num185;
											}
										}
									}
								}
							}

							if (flag5 && num180 > -1 && num181 > -1 && countDirtTiles(num180, num181) < maxTileCount) {
								try {
									Spread.Wall2(num180, num181, 63);
								}
								catch {
								}
							}
						}
					}
				}

				for (int num186 = 5; num186 < Main.maxTilesX - 5; num186++) {
					for (int num187 = 10; (double)num187 < Main.worldSurface - 1.0; num187++) {
						if (Main.tile[num186, num187].wall == 63 && genRand.Next(10) == 0)
							Main.tile[num186, num187].wall = 65;

						if (Main.tile[num186, num187].active() && Main.tile[num186, num187].type == 0) {
							bool flag6 = false;
							for (int num188 = num186 - 1; num188 <= num186 + 1; num188++) {
								for (int num189 = num187 - 1; num189 <= num187 + 1; num189++) {
									if (Main.tile[num186, num187].wall == 63 || Main.tile[num186, num187].wall == 65) {
										flag6 = true;
										break;
									}
								}
							}

							if (flag6)
								SpreadGrass(num186, num187, 0, 2, repeat: true, 0);
						}
					}
				}
			});

			AddGenerationPass("Guide", delegate {
				int num177 = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
				Main.npc[num177].homeTileX = Main.spawnTileX;
				Main.npc[num177].homeTileY = Main.spawnTileY;
				Main.npc[num177].direction = 1;
				Main.npc[num177].homeless = true;
			});

			AddGenerationPass("Sunflowers", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[39].Value;
				for (int num171 = 0; (double)num171 < (double)Main.maxTilesX * 0.002; num171++) {
					int num172 = 0;
					int num173 = 0;
					_ = Main.maxTilesX / 2;
					int num174 = genRand.Next(Main.maxTilesX);
					num172 = num174 - genRand.Next(10) - 7;
					num173 = num174 + genRand.Next(10) + 7;
					if (num172 < 0)
						num172 = 0;

					if (num173 > Main.maxTilesX - 1)
						num173 = Main.maxTilesX - 1;

					for (int num175 = num172; num175 < num173; num175++) {
						for (int num176 = 1; (double)num176 < Main.worldSurface - 1.0; num176++) {
							if (Main.tile[num175, num176].type == 2 && Main.tile[num175, num176].active() && !Main.tile[num175, num176 - 1].active())
								PlaceTile(num175, num176 - 1, 27, mute: true);

							if (Main.tile[num175, num176].active())
								break;
						}
					}
				}
			});

			AddGenerationPass("Planting Trees", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[40].Value;
				for (int num166 = 0; (double)num166 < (double)Main.maxTilesX * 0.003; num166++) {
					int num167 = genRand.Next(50, Main.maxTilesX - 50);
					int num168 = genRand.Next(25, 50);
					for (int num169 = num167 - num168; num169 < num167 + num168; num169++) {
						for (int num170 = 20; (double)num170 < Main.worldSurface && !Main.setting.NoTree; num170++) {
							GrowEpicTree(num169, num170);
						}
					}
				}

				if (!Main.setting.NoTree)
					{
						WorldGen.AddTrees();
					}
			});

			AddGenerationPass("Herbs", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[41].Value;
				for (int num165 = 0; (double)num165 < (double)Main.maxTilesX * 1.7; num165++) {
					PlantAlch();
				}
			});

			AddGenerationPass("Dye Plants", delegate {
				for (int num163 = 0; num163 < Main.maxTilesX; num163++) {
					plantDye(genRand.Next(100, Main.maxTilesX - 100), genRand.Next(100, Main.maxTilesY - 200));
				}

				for (int num164 = 0; num164 < Main.maxTilesX / 8; num164++) {
					plantDye(genRand.Next(100, Main.maxTilesX - 100), genRand.Next(100, Main.maxTilesY - 200), exoticPlant: true);
				}
			});

			AddGenerationPass("Webs And Honey", delegate {
				for (int num154 = 100; num154 < Main.maxTilesX - 100; num154++) {
					for (int num155 = (int)Main.worldSurface; num155 < Main.maxTilesY - 100; num155++) {
						if (Main.tile[num154, num155].wall == 86) {
							if (Main.tile[num154, num155].liquid > 0)
								Main.tile[num154, num155].honey(honey: true);

							if (genRand.Next(3) == 0)
								PlaceTight(num154, num155, 165);
						}

						if (Main.tile[num154, num155].wall == 62) {
							Main.tile[num154, num155].liquid = 0;
							Main.tile[num154, num155].lava(lava: false);
						}

						if (Main.tile[num154, num155].wall == 62 && !Main.tile[num154, num155].active() && genRand.Next(10) != 0) {
							int num156 = genRand.Next(2, 5);
							int num157 = num154 - num156;
							int num158 = num154 + num156;
							int num159 = num155 - num156;
							int num160 = num155 + num156;
							bool flag4 = false;
							for (int num161 = num157; num161 <= num158; num161++) {
								for (int num162 = num159; num162 <= num160; num162++) {
									if (SolidTile(num161, num162)) {
										flag4 = true;
										break;
									}
								}
							}

							if (flag4) {
								PlaceTile(num154, num155, 51, mute: true);
								TileFrame(num154, num155);
							}
						}
					}
				}
			});

			AddGenerationPass("Weeds", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[42].Value;
				if (Main.halloween) {
					for (int num150 = 40; num150 < Main.maxTilesX - 40; num150++) {
						for (int num151 = 50; (double)num151 < Main.worldSurface; num151++) {
							if (Main.tile[num150, num151].active() && Main.tile[num150, num151].type == 2 && genRand.Next(15) == 0) {
								PlacePumpkin(num150, num151 - 1);
								int num152 = genRand.Next(5);
								for (int num153 = 0; num153 < num152; num153++) {
									GrowPumpkin(num150, num151 - 1, 254);
								}
							}
						}
					}
				}

				AddPlants();
			});

			AddGenerationPass("Mud Caves To Grass", delegate {
				for (int num148 = 0; num148 < Main.maxTilesX; num148++) {
					for (int num149 = 0; num149 < Main.maxTilesY; num149++) {
						if (Main.tile[num148, num149].active()) {
							if (num149 >= (int)Main.worldSurface && Main.tile[num148, num149].type == 70 && !Main.tile[num148, num149 - 1].active()) {
								GrowShroom(num148, num149);
								if (!Main.tile[num148, num149 - 1].active())
									PlaceTile(num148, num149 - 1, 71, mute: true);
							}

							if (Main.tile[num148, num149].type == 60 && !Main.tile[num148, num149 - 1].active())
								PlaceTile(num148, num149 - 1, 61, mute: true);
						}
					}
				}
			});

			AddGenerationPass("Jungle Plants", delegate {
				for (int num145 = 0; num145 < Main.maxTilesX * 100; num145++) {
					int num146 = genRand.Next(40, Main.maxTilesX / 2 - 40);
					if (dungeonSide < 0)
						num146 += Main.maxTilesX / 2;

					int num147;
					for (num147 = genRand.Next(Main.maxTilesY - 300); !Main.tile[num146, num147].active() && num147 < Main.maxTilesY - 300; num147++) {
					}

					if (Main.tile[num146, num147].active() && Main.tile[num146, num147].type == 60) {
						num147--;
						PlaceJunglePlant(num146, num147, 233, genRand.Next(8), 0);
						if (Main.tile[num146, num147].type != 233)
							PlaceJunglePlant(num146, num147, 233, genRand.Next(12), 1);
					}
				}
			});

			AddGenerationPass("Vines", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[43].Value;
				for (int num134 = 0; num134 < Main.maxTilesX; num134++) {
					int num135 = 0;
					for (int num136 = 0; (double)num136 < Main.worldSurface; num136++) {
						if (num135 > 0 && !Main.tile[num134, num136].active()) {
							Main.tile[num134, num136].active(active: true);
							Main.tile[num134, num136].type = 52;
							num135--;
						}
						else {
							num135 = 0;
						}

						if (Main.tile[num134, num136].active() && !Main.tile[num134, num136].bottomSlope() && (Main.tile[num134, num136].type == 2 || (Main.tile[num134, num136].type == 192 && genRand.Next(4) == 0)) && genRand.Next(5) < 3)
							num135 = genRand.Next(1, 10);
					}

					num135 = 0;
					for (int num137 = 0; num137 < Main.maxTilesY; num137++) {
						if (num135 > 0 && !Main.tile[num134, num137].active()) {
							Main.tile[num134, num137].active(active: true);
							Main.tile[num134, num137].type = 62;
							num135--;
						}
						else {
							num135 = 0;
						}

						if (Main.tile[num134, num137].active() && Main.tile[num134, num137].type == 60 && !Main.tile[num134, num137].bottomSlope()) {
							if (num134 < Main.maxTilesX - 1 && num137 < Main.maxTilesY - 2 && Main.tile[num134 + 1, num137].active() && Main.tile[num134 + 1, num137].type == 60 && !Main.tile[num134 + 1, num137].bottomSlope() && genRand.Next(40) == 0) {
								bool flag3 = true;
								for (int num138 = num134; num138 < num134 + 2; num138++) {
									for (int num139 = num137 + 1; num139 < num137 + 3; num139++) {
										if (Main.tile[num138, num139].active() && (!Main.tileCut[Main.tile[num138, num139].type] || Main.tile[num138, num139].type == 444)) {
											flag3 = false;
											break;
										}

										if (Main.tile[num138, num139].liquid > 0 || Main.wallHouse[Main.tile[num138, num139].wall]) {
											flag3 = false;
											break;
										}
									}

									if (!flag3)
										break;
								}

								if (flag3 && CountNearBlocksTypes(num134, num137, 20, 1, 444) > 0)
									flag3 = false;

								if (flag3) {
									for (int num140 = num134; num140 < num134 + 2; num140++) {
										for (int num141 = num137 + 1; num141 < num137 + 3; num141++) {
											KillTile(num140, num141);
										}
									}

									for (int num142 = num134; num142 < num134 + 2; num142++) {
										for (int num143 = num137 + 1; num143 < num137 + 3; num143++) {
											Main.tile[num142, num143].active(active: true);
											Main.tile[num142, num143].type = 444;
											Main.tile[num142, num143].frameX = (short)((num142 - num134) * 18);
											Main.tile[num142, num143].frameY = (short)((num143 - num137 - 1) * 18);
										}
									}

									continue;
								}
							}

							if (genRand.Next(5) < 3)
								num135 = genRand.Next(1, 10);
						}
					}

					num135 = 0;
					for (int num144 = 0; num144 < Main.maxTilesY; num144++) {
						if (num135 > 0 && !Main.tile[num134, num144].active()) {
							Main.tile[num134, num144].active(active: true);
							Main.tile[num134, num144].type = 205;
							num135--;
						}
						else {
							num135 = 0;
						}

						if (Main.tile[num134, num144].active() && Main.tile[num134, num144].type == 199 && genRand.Next(5) < 3)
							num135 = genRand.Next(1, 10);
					}
				}
			});

			AddGenerationPass("Flowers", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[44].Value;
				for (int num127 = 0; (double)num127 < (double)Main.maxTilesX * 0.005; num127++) {
					int num128 = genRand.Next(20, Main.maxTilesX - 20);
					int num129 = genRand.Next(5, 15);
					int num130 = genRand.Next(15, 30);
					for (int num131 = 1; (double)num131 < Main.worldSurface - 1.0; num131++) {
						if (Main.tile[num128, num131].active()) {
							for (int num132 = num128 - num129; num132 < num128 + num129; num132++) {
								for (int num133 = num131 - num130; num133 < num131 + num130; num133++) {
									if (num133 > 0) {
										if (Main.tile[num132, num133].type == 3 || Main.tile[num132, num133].type == 24) {
											Main.tile[num132, num133].frameX = (short)(genRand.Next(6, 8) * 18);
											if (Main.tile[num132, num133].type == 3 && genRand.Next(2) == 0)
												Main.tile[num132, num133].frameX = (short)(genRand.Next(9, 11) * 18);
										}
									}
								}
							}

							break;
						}
					}
				}
			});

			AddGenerationPass("Mushrooms", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[45].Value;
				for (int num120 = 0; (double)num120 < (double)Main.maxTilesX * 0.002; num120++) {
					int num121 = genRand.Next(20, Main.maxTilesX - 20);
					int num122 = genRand.Next(4, 10);
					int num123 = genRand.Next(15, 30);
					for (int num124 = 1; (double)num124 < Main.worldSurface - 1.0; num124++) {
						if (Main.tile[num121, num124].active()) {
							for (int num125 = num121 - num122; num125 < num121 + num122; num125++) {
								for (int num126 = num124 - num123; num126 < num124 + num123; num126++) {
									if (Main.tile[num125, num126].type == 3 || Main.tile[num125, num126].type == 24)
										Main.tile[num125, num126].frameX = 144;
									else if (Main.tile[num125, num126].type == 201)
										Main.tile[num125, num126].frameX = 270;
								}
							}

							break;
						}
					}
				}
			});

			AddGenerationPass("Stalac", delegate {
				for (int num117 = 20; num117 < Main.maxTilesX - 20; num117++) {
					for (int num118 = (int)Main.worldSurface; num118 < Main.maxTilesY - 20; num118++) {
						if (!Main.tile[num117, num118].active() && genRand.Next(5) == 0) {
							if ((Main.tile[num117, num118 - 1].type == 1 || Main.tile[num117, num118 - 1].type == 147 || Main.tile[num117, num118 - 1].type == 161 || Main.tile[num117, num118 - 1].type == 25 || Main.tile[num117, num118 - 1].type == 203 || Main.tileStone[Main.tile[num117, num118 - 1].type] || Main.tileMoss[Main.tile[num117, num118 - 1].type]) && !Main.tile[num117, num118].active() && !Main.tile[num117, num118 + 1].active())
								Main.tile[num117, num118 - 1].slope(0);

							if ((Main.tile[num117, num118 + 1].type == 1 || Main.tile[num117, num118 + 1].type == 147 || Main.tile[num117, num118 + 1].type == 161 || Main.tile[num117, num118 + 1].type == 25 || Main.tile[num117, num118 + 1].type == 203 || Main.tileStone[Main.tile[num117, num118 + 1].type] || Main.tileMoss[Main.tile[num117, num118 + 1].type]) && !Main.tile[num117, num118].active() && !Main.tile[num117, num118 - 1].active())
								Main.tile[num117, num118 + 1].slope(0);

							PlaceTight(num117, num118, 165);
						}
					}

					for (int num119 = 5; num119 < (int)Main.worldSurface; num119++) {
						if ((Main.tile[num117, num119 - 1].type == 147 || Main.tile[num117, num119 - 1].type == 161) && genRand.Next(5) == 0) {
							if (!Main.tile[num117, num119].active() && !Main.tile[num117, num119 + 1].active())
								Main.tile[num117, num119 - 1].slope(0);

							PlaceTight(num117, num119, 165);
						}

						if ((Main.tile[num117, num119 - 1].type == 25 || Main.tile[num117, num119 - 1].type == 203) && genRand.Next(5) == 0) {
							if (!Main.tile[num117, num119].active() && !Main.tile[num117, num119 + 1].active())
								Main.tile[num117, num119 - 1].slope(0);

							PlaceTight(num117, num119, 165);
						}

						if ((Main.tile[num117, num119 + 1].type == 25 || Main.tile[num117, num119 + 1].type == 203) && genRand.Next(5) == 0) {
							if (!Main.tile[num117, num119].active() && !Main.tile[num117, num119 - 1].active())
								Main.tile[num117, num119 + 1].slope(0);

							PlaceTight(num117, num119, 165);
						}
					}
				}
			});

			AddGenerationPass("Gems In Ice Biome", delegate {
				for (int num106 = 0; (double)num106 < (double)Main.maxTilesX * 0.25; num106++) {
					int num107 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, lavaLine);
					int num108 = genRand.Next(snowMinX[num107], snowMaxX[num107]);
					if (Main.tile[num108, num107].active() && (Main.tile[num108, num107].type == 147 || Main.tile[num108, num107].type == 161 || Main.tile[num108, num107].type == 162 || Main.tile[num108, num107].type == 224)) {
						int num109 = genRand.Next(1, 4);
						int num110 = genRand.Next(1, 4);
						int num111 = genRand.Next(1, 4);
						int num112 = genRand.Next(1, 4);
						int num113 = genRand.Next(12);
						int num114 = 0;
						num114 = ((num113 >= 3) ? ((num113 < 6) ? 1 : ((num113 < 8) ? 2 : ((num113 < 10) ? 3 : ((num113 >= 11) ? 5 : 4)))) : 0);
						for (int num115 = num108 - num109; num115 < num108 + num110; num115++) {
							for (int num116 = num107 - num111; num116 < num107 + num112; num116++) {
								if (!Main.tile[num115, num116].active())
									PlaceTile(num115, num116, 178, mute: true, forced: false, -1, num114);
							}
						}
					}
				}
			});

			AddGenerationPass("Random Gems", delegate {
				for (int num101 = 0; num101 < Main.maxTilesX; num101++) {
					int num102 = genRand.Next(20, Main.maxTilesX - 20);
					int num103 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 300);
					if (!Main.tile[num102, num103].active() && !Main.tile[num102, num103].lava() && !Main.wallDungeon[Main.tile[num102, num103].wall] && Main.tile[num102, num103].wall != 27) {
						int num104 = genRand.Next(12);
						int num105 = 0;
						num105 = ((num104 >= 3) ? ((num104 < 6) ? 1 : ((num104 < 8) ? 2 : ((num104 < 10) ? 3 : ((num104 >= 11) ? 5 : 4)))) : 0);
						PlaceTile(num102, num103, 178, mute: true, forced: false, -1, num105);
					}
				}
			});

			AddGenerationPass("Moss Grass", delegate {
				for (int num96 = 5; num96 < Main.maxTilesX - 5; num96++) {
					for (int num97 = 5; num97 < Main.maxTilesY - 5; num97++) {
						if (Main.tile[num96, num97].active() && Main.tileMoss[Main.tile[num96, num97].type]) {
							for (int num98 = 0; num98 < 4; num98++) {
								int num99 = num96;
								int num100 = num97;
								if (num98 == 0)
									num99--;

								if (num98 == 1)
									num99++;

								if (num98 == 2)
									num100--;

								if (num98 == 3)
									num100++;

								if (!Main.tile[num99, num100].active())
									PlaceTile(num99, num100, 184, mute: true);
							}
						}
					}
				}
			});

			AddGenerationPass("Muds Walls In Jungle", delegate {
				int num88 = 0;
				int num89 = 0;
				bool flag2 = false;
				for (int num90 = 5; num90 < Main.maxTilesX - 5; num90++) {
					for (int num91 = 0; (double)num91 < Main.worldSurface + 20.0; num91++) {
						if (Main.tile[num90, num91].active() && Main.tile[num90, num91].type == 60) {
							num88 = num90;
							flag2 = true;
							break;
						}
					}

					if (flag2)
						break;
				}

				flag2 = false;
				for (int num92 = Main.maxTilesX - 5; num92 > 5; num92--) {
					for (int num93 = 0; (double)num93 < Main.worldSurface + 20.0; num93++) {
						if (Main.tile[num92, num93].active() && Main.tile[num92, num93].type == 60) {
							num89 = num92;
							flag2 = true;
							break;
						}
					}

					if (flag2)
						break;
				}

				for (int num94 = num88; num94 <= num89; num94++) {
					for (int num95 = 0; (double)num95 < Main.worldSurface + 20.0; num95++) {
						if (((num94 >= num88 + 2 && num94 <= num89 - 2) || genRand.Next(2) != 0) && ((num94 >= num88 + 3 && num94 <= num89 - 3) || genRand.Next(3) != 0) && (Main.tile[num94, num95].wall == 2 || Main.tile[num94, num95].wall == 59))
							Main.tile[num94, num95].wall = 15;
					}
				}
			});

			AddGenerationPass("Larva", delegate {
				for (int num83 = 0; num83 < numLarva; num83++) {
					int num84 = larvaX[num83];
					int num85 = larvaY[num83];
					for (int num86 = num84 - 1; num86 <= num84 + 1; num86++) {
						for (int num87 = num85 - 2; num87 <= num85 + 1; num87++) {
							if (num87 != num85 + 1) {
								Main.tile[num86, num87].active(active: false);
							}
							else {
								Main.tile[num86, num87].active(active: true);
								Main.tile[num86, num87].type = 225;
								Main.tile[num86, num87].slope(0);
								Main.tile[num86, num87].halfBrick(halfBrick: false);
							}
						}
					}

					PlaceTile(num84, num85, 231, mute: true);
				}

				Main.tileSolid[232] = true;
				Main.tileSolid[162] = true;
			});

			AddGenerationPass("Settle Liquids Again", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[27].Value;
				Liquid.QuickWater(3);
				WaterCheck();
				int num78 = 0;
				Liquid.quickSettle = true;
				while (num78 < 10) {
					int num79 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num78++;
					float num80 = 0f;
					while (Liquid.numLiquid > 0) {
						float num81 = (float)(num79 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (float)num79;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num79)
							num79 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;

						if (num81 > num80)
							num80 = num81;
						else
							num81 = num80;

						if (num78 == 1)
							progress.Set(num81 / 3f + 0.33f);

						int num82 = 10;
						if (num78 > num82)
							num82 = num78;

						Liquid.UpdateLiquid();
					}

					WaterCheck();
					progress.Set((float)num78 * 0.1f / 3f + 0.66f);
				}

				Liquid.quickSettle = false;
			});

			AddGenerationPass("Tile Cleanup", delegate {
				for (int num21 = 40; num21 < Main.maxTilesX - 40; num21++) {
					for (int num22 = 40; num22 < Main.maxTilesY - 40; num22++) {
						if (!Main.tile[num21, num22].active() && Main.tile[num21, num22].liquid == 0 && genRand.Next(3) != 0 && SolidTile(num21, num22 - 1)) {
							int num23 = genRand.Next(15, 21);
							for (int num24 = num22 - 2; num24 >= num22 - num23; num24--) {
								if (Main.tile[num21, num24].liquid >= 128) {
									int num25 = 373;
									if (Main.tile[num21, num24].lava())
										num25 = 374;
									else if (Main.tile[num21, num24].honey())
										num25 = 375;

									int maxValue = num22 - num24;
									if (genRand.Next(maxValue) <= 1) {
										Main.tile[num21, num22].type = (ushort)num25;
										Main.tile[num21, num22].frameX = 0;
										Main.tile[num21, num22].frameY = 0;
										Main.tile[num21, num22].active(active: true);
										break;
									}
								}
							}

							if (!Main.tile[num21, num22].active()) {
								num23 = genRand.Next(3, 11);
								for (int num26 = num22 + 1; num26 <= num22 + num23; num26++) {
									if (Main.tile[num21, num26].liquid >= 200) {
										int num27 = 373;
										if (Main.tile[num21, num26].lava())
											num27 = 374;
										else if (Main.tile[num21, num26].honey())
											num27 = 375;

										int num28 = num26 - num22;
										if (genRand.Next(num28 * 3) <= 1) {
											Main.tile[num21, num22].type = (ushort)num27;
											Main.tile[num21, num22].frameX = 0;
											Main.tile[num21, num22].frameY = 0;
											Main.tile[num21, num22].active(active: true);
											break;
										}
									}
								}
							}

							if (!Main.tile[num21, num22].active() && genRand.Next(3) != 0) {
								Tile tile = Main.tile[num21, num22 - 1];
								if (TileID.Sets.Conversion.Sandstone[tile.type] || TileID.Sets.Conversion.HardenedSand[tile.type]) {
									Main.tile[num21, num22].type = 461;
									Main.tile[num21, num22].frameX = 0;
									Main.tile[num21, num22].frameY = 0;
									Main.tile[num21, num22].active(active: true);
								}
							}
						}

						if (Main.tile[num21, num22].type == 137) {
							if (Main.tile[num21, num22].frameY <= 52) {
								int num29 = -1;
								if (Main.tile[num21, num22].frameX >= 18)
									num29 = 1;

								if (Main.tile[num21 + num29, num22].halfBrick() || Main.tile[num21 + num29, num22].slope() != 0)
									Main.tile[num21 + num29, num22].active(active: false);
							}
						}
						else if (Main.tile[num21, num22].type == 162 && Main.tile[num21, num22 + 1].liquid == 0) {
							Main.tile[num21, num22].active(active: false);
						}

						if (Main.tile[num21, num22].wall == 13 || Main.tile[num21, num22].wall == 14)
							Main.tile[num21, num22].liquid = 0;

						if (Main.tile[num21, num22].type == 31) {
							int num30 = Main.tile[num21, num22].frameX / 18;
							int num31 = 0;
							int num32 = num21;
							num31 += num30 / 2;
							num30 %= 2;
							num32 -= num30;
							int num33 = Main.tile[num21, num22].frameY / 18;
							int num34 = 0;
							int num35 = num22;
							num34 += num33 / 2;
							num33 %= 2;
							num35 -= num33;
							for (int num36 = 0; num36 < 2; num36++) {
								for (int num37 = 0; num37 < 2; num37++) {
									int num38 = num32 + num36;
									int num39 = num35 + num37;
									Main.tile[num38, num39].active(active: true);
									Main.tile[num38, num39].slope(0);
									Main.tile[num38, num39].halfBrick(halfBrick: false);
									Main.tile[num38, num39].type = 31;
									Main.tile[num38, num39].frameX = (short)(num36 * 18 + 36 * num31);
									Main.tile[num38, num39].frameY = (short)(num37 * 18 + 36 * num34);
								}
							}
						}

						if (Main.tile[num21, num22].type == 12) {
							int num40 = Main.tile[num21, num22].frameX / 18;
							int num41 = 0;
							int num42 = num21;
							num41 += num40 / 2;
							num40 %= 2;
							num42 -= num40;
							int num43 = Main.tile[num21, num22].frameY / 18;
							int num44 = 0;
							int num45 = num22;
							num44 += num43 / 2;
							num43 %= 2;
							num45 -= num43;
							for (int num46 = 0; num46 < 2; num46++) {
								for (int num47 = 0; num47 < 2; num47++) {
									int num48 = num42 + num46;
									int num49 = num45 + num47;
									Main.tile[num48, num49].active(active: true);
									Main.tile[num48, num49].slope(0);
									Main.tile[num48, num49].halfBrick(halfBrick: false);
									Main.tile[num48, num49].type = 12;
									Main.tile[num48, num49].frameX = (short)(num46 * 18 + 36 * num41);
									Main.tile[num48, num49].frameY = (short)(num47 * 18 + 36 * num44);
								}

								if (!Main.tile[num46, num22 + 2].active()) {
									Main.tile[num46, num22 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num46, num22 + 2].type] || Main.tileSolidTop[Main.tile[num46, num22 + 2].type])
										Main.tile[num46, num22 + 2].type = 0;
								}

								Main.tile[num46, num22 + 2].slope(0);
								Main.tile[num46, num22 + 2].halfBrick(halfBrick: false);
							}
						}

						if (TileID.Sets.BasicChest[Main.tile[num21, num22].type] && Main.tile[num21, num22].type < TileID.Count) {
							int num50 = Main.tile[num21, num22].frameX / 18;
							int num51 = 0;
							int num52 = num21;
							int num53 = num22 - Main.tile[num21, num22].frameY / 18;
							while (num50 >= 2) {
								num51++;
								num50 -= 2;
							}

							num52 -= num50;
							int num54 = Chest.FindChest(num52, num53);
							if (num54 != -1) {
								switch (Main.chest[num54].item[0].type) {
									case 1156:
										num51 = 23;
										break;
									case 1571:
										num51 = 24;
										break;
									case 1569:
										num51 = 25;
										break;
									case 1260:
										num51 = 26;
										break;
									case 1572:
										num51 = 27;
										break;
								}
							}

							for (int num55 = 0; num55 < 2; num55++) {
								for (int num56 = 0; num56 < 2; num56++) {
									int num57 = num52 + num55;
									int num58 = num53 + num56;
									Main.tile[num57, num58].active(active: true);
									Main.tile[num57, num58].slope(0);
									Main.tile[num57, num58].halfBrick(halfBrick: false);
									Main.tile[num57, num58].type = 21;
									Main.tile[num57, num58].frameX = (short)(num55 * 18 + 36 * num51);
									Main.tile[num57, num58].frameY = (short)(num56 * 18);
								}

								if (!Main.tile[num55, num22 + 2].active()) {
									Main.tile[num55, num22 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num55, num22 + 2].type] || Main.tileSolidTop[Main.tile[num55, num22 + 2].type])
										Main.tile[num55, num22 + 2].type = 0;
								}

								Main.tile[num55, num22 + 2].slope(0);
								Main.tile[num55, num22 + 2].halfBrick(halfBrick: false);
							}
						}

						if (Main.tile[num21, num22].type == 28) {
							int num59 = Main.tile[num21, num22].frameX / 18;
							int num60 = 0;
							int num61 = num21;
							while (num59 >= 2) {
								num60++;
								num59 -= 2;
							}

							num61 -= num59;
							int num62 = Main.tile[num21, num22].frameY / 18;
							int num63 = 0;
							int num64 = num22;
							while (num62 >= 2) {
								num63++;
								num62 -= 2;
							}

							num64 -= num62;
							for (int num65 = 0; num65 < 2; num65++) {
								for (int num66 = 0; num66 < 2; num66++) {
									int num67 = num61 + num65;
									int num68 = num64 + num66;
									Main.tile[num67, num68].active(active: true);
									Main.tile[num67, num68].slope(0);
									Main.tile[num67, num68].halfBrick(halfBrick: false);
									Main.tile[num67, num68].type = 28;
									Main.tile[num67, num68].frameX = (short)(num65 * 18 + 36 * num60);
									Main.tile[num67, num68].frameY = (short)(num66 * 18 + 36 * num63);
								}

								if (!Main.tile[num65, num22 + 2].active()) {
									Main.tile[num65, num22 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num65, num22 + 2].type] || Main.tileSolidTop[Main.tile[num65, num22 + 2].type])
										Main.tile[num65, num22 + 2].type = 0;
								}

								Main.tile[num65, num22 + 2].slope(0);
								Main.tile[num65, num22 + 2].halfBrick(halfBrick: false);
							}
						}

						if (Main.tile[num21, num22].type == 26) {
							int num69 = Main.tile[num21, num22].frameX / 18;
							int num70 = 0;
							int num71 = num21;
							int num72 = num22 - Main.tile[num21, num22].frameY / 18;
							while (num69 >= 3) {
								num70++;
								num69 -= 3;
							}

							num71 -= num69;
							for (int num73 = 0; num73 < 3; num73++) {
								for (int num74 = 0; num74 < 2; num74++) {
									int num75 = num71 + num73;
									int num76 = num72 + num74;
									Main.tile[num75, num76].active(active: true);
									Main.tile[num75, num76].slope(0);
									Main.tile[num75, num76].halfBrick(halfBrick: false);
									Main.tile[num75, num76].type = 26;
									Main.tile[num75, num76].frameX = (short)(num73 * 18 + 54 * num70);
									Main.tile[num75, num76].frameY = (short)(num74 * 18);
								}

								if (!Main.tile[num71 + num73, num72 + 2].active() || !Main.tileSolid[Main.tile[num71 + num73, num72 + 2].type] || Main.tileSolidTop[Main.tile[num71 + num73, num72 + 2].type]) {
									Main.tile[num71 + num73, num72 + 2].active(active: true);
									if (!TileID.Sets.Platforms[Main.tile[num71 + num73, num72 + 2].type] && (!Main.tileSolid[Main.tile[num71 + num73, num72 + 2].type] || Main.tileSolidTop[Main.tile[num71 + num73, num72 + 2].type]))
										Main.tile[num71 + num73, num72 + 2].type = 0;
								}

								Main.tile[num71 + num73, num72 + 2].slope(0);
								Main.tile[num71 + num73, num72 + 2].halfBrick(halfBrick: false);
								if (Main.tile[num71 + num73, num72 + 3].type == 28 && Main.tile[num71 + num73, num72 + 3].frameY % 36 >= 18) {
									Main.tile[num71 + num73, num72 + 3].type = 0;
									Main.tile[num71 + num73, num72 + 3].active(active: false);
								}
							}

							for (int num77 = 0; num77 < 3; num77++) {
								if ((Main.tile[num71 - 1, num72 + num77].type == 28 || Main.tile[num71 - 1, num72 + num77].type == 12) && Main.tile[num71 - 1, num72 + num77].frameX % 36 < 18) {
									Main.tile[num71 - 1, num72 + num77].type = 0;
									Main.tile[num71 - 1, num72 + num77].active(active: false);
								}

								if ((Main.tile[num71 + 3, num72 + num77].type == 28 || Main.tile[num71 + 3, num72 + num77].type == 12) && Main.tile[num71 + 3, num72 + num77].frameX % 36 >= 18) {
									Main.tile[num71 + 3, num72 + num77].type = 0;
									Main.tile[num71 + 3, num72 + num77].active(active: false);
								}
							}
						}

						if (Main.tile[num21, num22].type == 237 && Main.tile[num21, num22 + 1].type == 232)
							Main.tile[num21, num22 + 1].type = 226;
					}
				}
			});

			AddGenerationPass("Lihzahrd Altars", delegate {
				int num16 = lAltarX;
				int num17 = lAltarY;
				for (int n = 0; n <= 2; n++) {
					for (int num18 = 0; num18 <= 1; num18++) {
						int num19 = num16 + n;
						int num20 = num17 + num18;
						Main.tile[num19, num20].active(active: true);
						Main.tile[num19, num20].type = 237;
						Main.tile[num19, num20].frameX = (short)(n * 18);
						Main.tile[num19, num20].frameY = (short)(num18 * 18);
					}

					Main.tile[n, num17 + 2].active(active: true);
					Main.tile[n, num17 + 2].slope(0);
					Main.tile[n, num17 + 2].halfBrick(halfBrick: false);
					Main.tile[n, num17 + 2].type = 226;
				}
			});

			AddGenerationPass("Micro Biomes", delegate (GenerationProgress progress) {
				progress.Message = Lang.gen[76].Value + "..Thin Ice";
				float num = (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f;
				float num2 = (float)Main.maxTilesX / 4200f;
				int num3 = (int)((float)genRand.Next(3, 6) * num * Main.setting.ThinIceBiomeMultiplier);
				int num4 = 0;
				if (!Main.setting.NoSnow) {
					while (num4 < num3) {
						if (Biomes<ThinIceBiome>.Place(RandomWorldPoint((int)Main.worldSurface + 20, 50, 200, 50), structures))
							num4++;
					}
				}

				progress.Set(0.1f);
				progress.Message = Lang.gen[76] + "..Enchanted Swords";
				int num5 = (int)Math.Ceiling(num * Main.setting.EnchantedSwordBiomeMultiplier);
				int num6 = 0;
				Point origin = default(Point);
				int attempts = 0;
				while (num6 < num5 && attempts < 10000) {
					attempts++;
					origin.Y = (int)worldSurface + genRand.Next(50, 100);
					if (genRand.Next(2) == 0)
						origin.X = genRand.Next(50, (int)((float)Main.maxTilesX * 0.3f));
					else
						origin.X = genRand.Next((int)((float)Main.maxTilesX * 0.7f), Main.maxTilesX - 50);

					if (Biomes<EnchantedSwordBiome>.Place(origin, structures))
						num6++;
				}

				progress.Set(0.2f);
				progress.Message = Lang.gen[76] + "..Campsites";
				int num7 = (int)((float)genRand.Next(6, 12) * num * Main.setting.CampsiteBiomeMultiplier);
				int num8 = 0;
				while (num8 < num7) {
					if (Biomes<CampsiteBiome>.Place(RandomWorldPoint((int)Main.worldSurface, 50, 200, 50), structures))
						num8++;
				}

				progress.Message = Lang.gen[76] + "..Mining Explosives";
				progress.Set(0.25f);
				int num9 = (int)((float)genRand.Next(14, 30) * num * Main.setting.MiningExplosiveMultiplier);
				int num10 = 0;
				while (num10 < num9) {
					if (Biomes<MiningExplosivesBiome>.Place(RandomWorldPoint((int)rockLayer, 50, 200, 50), structures))
						num10++;
				}

				progress.Message = Lang.gen[76] + "..Mahogany Trees";
				progress.Set(0.3f);
				int num11 = (int)((float)genRand.Next(6, 12) * num2 * Main.setting.MahoganyTreeMultiplier);
				int num12 = 0;
				int num13 = 0;
				while (num12 < num11 && num13 < 20000 * Main.setting.MahoganyTreeMultiplier) {
					if (Biomes<MahoganyTreeBiome>.Place(RandomWorldPoint((int)Main.worldSurface + 50, 50, 500, 50), structures))
						num12++;

					num13++;
				}

				progress.Message = Lang.gen[76] + "..Corruption Pits";
				progress.Set(0.4f);
				if ((!WorldGen.crimson || Main.setting.IsCorruption == 4) && Main.setting.IsCorruption != 5 && ((int)Math.Ceiling(Main.maxTilesX * 0.00045 * Main.setting.CorruptionMultiplier) > 0)) {
					int num14 = (int)((float)genRand.Next(1, 3) * num);
					int num15 = 0;
					int Attempt = 0;
					while (num15 < num14) {
						Attempt++;
						if ((Biomes<CorruptionPitBiome>.Place(WorldGen.RandomWorldPoint((int)Main.worldSurface, Main.setting.CrimsonCorruptionAvoidJungle && dungeonSide == -1 ? Main.maxTilesX / 2 : 50, 500, Main.setting.CrimsonCorruptionAvoidJungle && dungeonSide == 1 ? Main.maxTilesX / 2 : 50), structures)) || Attempt > 1000)
							num15++;
					}
				}

				progress.Message = Lang.gen[76] + "..Minecart Tracks";
				progress.Set(0.5f);
				int minTrackLength = Math.Min((int)(num * 25f) + 250, 350);
				TrackGenerator.Run(progress, (int)(10f * num * Main.setting.MineCartMultiplier), minTrackLength);
				progress.Set(1f);
			});

			AddGenerationPass("Final Cleanup", delegate (GenerationProgress progress) {
				for (int l = 0; l < Main.maxTilesX; l++) {
					for (int m = 0; m < Main.maxTilesY; m++) {
						if (Main.tile[l, m].active() && (!SolidTile(l, m + 1) || !SolidTile(l, m + 2))) {
							switch (Main.tile[l, m].type) {
								case 53:
									Main.tile[l, m].type = 397;
									break;
								case 112:
									Main.tile[l, m].type = 398;
									break;
								case 234:
									Main.tile[l, m].type = 399;
									break;
								case 224:
									Main.tile[l, m].type = 147;
									break;
								case 123:
									Main.tile[l, m].type = 1;
									break;
							}
						}
					}
				}
				progress.Message = "Meteor Shower...";
				for (int predropMeteors = 0; predropMeteors < Main.setting.PreDropMeteor; predropMeteors++)
				{
					WorldGen.dropMeteor();
				}
				if (Main.hardMode && Main.setting.HardmodeStripes)
				{
					progress.Message = "Generating hardmode stripes...";
					smCallBack(null);
				}
				progress.Message = "Generating hardmode ores...";
				int preSmash = 0;
				while ((float)preSmash < Main.setting.PreSmashAltar * 50f)
				{
					WorldGen.SmashAltar();
					preSmash++;
				}
				WorldGen.altarCount = 0;
				noTileActions = false;
				gen = false;
				Main.AnglerQuestSwap();
			});

			

			

			if (Main.setting.RandomizedTiles == true) {
                AddGenerationPass("Mixing Tiles", delegate (GenerationProgress progress) {
                    progress.Message = "Mixing...";

                    ushort[] TileBlacklistOrigin = {21, 3, 4, 5, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 
                        24, 26, 27, 28, 29, 31, 33, 34, 35, 36, 42, 49, 50, 55, 61, 62, 72, 73, 74, 77, 78, 
                        79, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 
                        102, 103, 104, 105, 106, 110, 113, 114, 125, 126, 128, 129, 130, 131, 132, 133, 134,
                        135, 136, 137, 138, 139, 141, 142, 143, 144, 149, 165, 171, 172, 173, 174, 178, 184, 
                        185, 186, 187, 201, 207, 209, 210, 212, 215, 216, 217, 218, 219, 220, 227, 228, 231, 
                        233, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 254, 269, 270, 
                        271, 275, 276, 277, 278, 279, 280, 281, 282, 283, 285, 286, 287, 288, 289, 290, 291,
                        292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 
                        309, 310, 314, 316, 317, 318, 319, 320, 323, 330, 331, 332, 333, 334, 335, 337, 338,
                        339, 349, 354, 355, 356, 358, 359, 360, 361, 362, 363, 364, 372, 377, 373, 374, 375, 
                        376, 378, 379, 380, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 405, 406, 410, 
                        411, 412, 413, 414, 419, 420, 423, 424, 425, 428, 429, 440, 441, 442, 443, 444, 445, 
                        452, 453, 454, 455, 456, 457, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471};

                    List<ushort> TileBlacklist = new List<ushort>(TileBlacklistOrigin);

                    ushort[] DiscoveredTiles = new ushort[1000];
                    
                    List<ushort> PossibleTiles = new List<ushort>{0, 1, 2, 6, 7, 8, 9, 22, 23, 25, 30, 32, 37, 38, 39, 40, 41, 
                        43, 44, 45, 46, 47, 48, 51, 53, 54, 56, 57, 58, 59, 60, 63, 64, 65, 66, 67, 68, 69, 70, 
                        75, 76, 107, 108, 109, 111, 112, 116, 117, 118, 119, 120, 121, 122, 123, 140, 145, 146, 
                        145, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 
                        164, 166, 167, 168, 169, 170, 175, 176, 177, 179, 180, 181, 182, 183, 188, 189, 190, 191, 
                        192, 193, 194, 195, 196, 197, 198, 199, 200, 202, 203, 204, 206, 208, 211, 221, 222, 223, 
                        224, 225, 226, 229, 230, 232, 234, 248, 249, 250, 251, 252, 253, 255, 256, 257, 258, 259, 
                        260, 261, 262, 263, 264, 265, 266, 267, 268, 272, 273, 274, 284, 311, 312, 313, 315, 321,
                        322, 325, 346, 347, 348, 350, 357, 367, 368, 369, 370, 371, 381, 383, 384, 385, 396, 397, 
                        398, 399, 400, 401, 402, 403, 404, 407, 408, 409, 415, 416, 417, 418, 421, 422, 426, 430, 
                        431, 432, 433, 434, 446, 447, 448, 460};

                    var random = new Random();
                    for (int l = 0; l < Main.maxTilesX; l++) {
                        for (int m = 0; m < Main.maxTilesY; m++) {
                            if (Main.tile[l, m].active()) {
                                ushort oldType = Main.tile[l, m].type;
                                if (!TileBlacklist.Contains(oldType)) {
                                    ushort newType;
                                    if ((DiscoveredTiles)[oldType] == 0) {
                                        int newID = random.Next(PossibleTiles.Count);
                                        newType = PossibleTiles[newID];
                                        PossibleTiles.RemoveAt(newID);
                                        DiscoveredTiles[oldType] = (ushort)(newType + 1);
									}
                                    else {
                                        newType = (ushort)(DiscoveredTiles[oldType] - 1);
									}
                                    Main.tile[l, m].type = newType;
                                }
                            }
                        }
                    }
                });
            }

            if (Main.setting.RandomizedTiles == false && Main.setting.SwappedTiles == true) {
                AddGenerationPass("Swapping Tiles", delegate (GenerationProgress progress) {
                    progress.Message = "Swapping...";

                    ushort[] TileBlacklistOrigin = {21, 3, 4, 5, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20,
                        24, 26, 27, 28, 29, 31, 33, 34, 35, 36, 42, 49, 50, 55, 61, 62, 72, 73, 74, 77, 78,
                        79, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101,
                        102, 103, 104, 105, 106, 110, 113, 114, 125, 126, 128, 129, 130, 131, 132, 133, 134,
                        135, 136, 137, 138, 139, 141, 142, 143, 144, 149, 165, 171, 172, 173, 174, 178, 184,
                        185, 186, 187, 201, 207, 209, 210, 212, 215, 216, 217, 218, 219, 220, 227, 228, 231,
                        233, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 254, 269, 270,
                        271, 275, 276, 277, 278, 279, 280, 281, 282, 283, 285, 286, 287, 288, 289, 290, 291,
                        292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308,
                        309, 310, 314, 316, 317, 318, 319, 320, 323, 330, 331, 332, 333, 334, 335, 337, 338,
                        339, 349, 354, 355, 356, 358, 359, 360, 361, 362, 363, 364, 372, 377, 373, 374, 375,
                        376, 378, 379, 380, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 405, 406, 410,
                        411, 412, 413, 414, 419, 420, 423, 424, 425, 428, 429, 440, 441, 442, 443, 444, 445,
                        452, 453, 454, 455, 456, 457, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471};

                    List<ushort> TileBlacklist = new List<ushort>(TileBlacklistOrigin);

                    ushort[] DiscoveredTiles = new ushort[1000];
                    List<int> SortedList = new List<int>();

                    for (int l = 0; l < Main.maxTilesX; l++) {
                        for (int m = 0; m < Main.maxTilesY; m++) {
                            if (Main.tile[l, m].active()) {
                                ushort oldType = Main.tile[l, m].type;
                                if (!TileBlacklist.Contains(oldType)) {

                                    DiscoveredTiles[oldType] = (ushort)(DiscoveredTiles[oldType] + 1);

                                }
                            }
                        }
                    }

                    bool E = true;

                    while (E == true) {
                        int biggestCOUNT = 0;
                        int biggestPOS = -1;

                        for (int i = 0; i < new List<ushort>(DiscoveredTiles).Count; i++) {
                            if (DiscoveredTiles[i] > (ushort)biggestCOUNT) {
                                biggestPOS = i;
                                biggestCOUNT = (int)DiscoveredTiles[i];
                            }
						}
                        if (biggestPOS >= 0) {
                            SortedList.Add(biggestPOS);
                            DiscoveredTiles[biggestPOS] = (ushort)0;
                        }
                        else {
                            E = false;
						}
                    }

                    while (SortedList.Count > 0) {
                        DiscoveredTiles[SortedList[0]] = (ushort)(SortedList[SortedList.Count - 1]+1);
                        DiscoveredTiles[SortedList[SortedList.Count - 1]] = (ushort)(SortedList[0]+1);
                        SortedList.RemoveAt(SortedList.Count - 1);
                        if (SortedList.Count > 0) {
                            SortedList.RemoveAt(0);
						}
                    }

                    for (int l = 0; l < Main.maxTilesX; l++) {
                        for (int m = 0; m < Main.maxTilesY; m++) {
                            if (Main.tile[l, m].active()) {
                                ushort oldType = Main.tile[l, m].type;
                                if (!TileBlacklist.Contains(oldType)) {
                                    if ((DiscoveredTiles)[oldType] != 0) {
                                        Main.tile[l, m].type = (ushort)(DiscoveredTiles[oldType] - 1);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            if (Main.setting.FlippedWorld == true) {
                AddGenerationPass("Flipping World", delegate (GenerationProgress progress) {
                    progress.Message = "Turning World Upside-Down...";

                    for (int l = 0; l < Main.maxTilesX; l++) {
                        for (int m = 1; m < Main.maxTilesY/2; m++) {
                            //bool TileAActive = Main.tile[l, m].active();
                            //bool TileBActive = Main.tile[l, Main.maxTilesY - m].active();
                            if ((Main.tile[l, m].type == 21 && Main.tile[l, m+1].type == 21) || (Main.tile[l, m].type == 12 && Main.tile[l, m + 1].type == 12) ||
                            (Main.tile[l, m].type == 28 && Main.tile[l, m + 1].type == 28) || (Main.tile[l, m].type == 31 && Main.tile[l, m + 1].type == 31)) {
                                Tile oldTile2 = Main.tile[l, m];
                                Main.tile[l, m] = Main.tile[l, m + 1];
                                Main.tile[l, m + 1] = oldTile2;
                            }
                            if ((Main.tile[l, Main.maxTilesY - m].type == 21 && Main.tile[l, Main.maxTilesY - m - 1].type == 21) ||
                            (Main.tile[l, Main.maxTilesY - m].type == 12 && Main.tile[l, Main.maxTilesY - m - 1].type == 12) ||
                            (Main.tile[l, Main.maxTilesY - m].type == 28 && Main.tile[l, Main.maxTilesY - m - 1].type == 28) ||
                            (Main.tile[l, Main.maxTilesY - m].type == 31 && Main.tile[l, Main.maxTilesY - m - 1].type == 31)) {
                                Tile oldTile3 = Main.tile[l, Main.maxTilesY - m];
                                Main.tile[l, Main.maxTilesY - m] = Main.tile[l, Main.maxTilesY - m - 1];
                                Main.tile[l, Main.maxTilesY - m - 1] = oldTile3;
                            }
                            Tile oldTile = Main.tile[l, m];
                            Main.tile[l, m] = Main.tile[l, Main.maxTilesY - m];
                            Main.tile[l, Main.maxTilesY - m] = oldTile;
                            //if (!TileAActive) {
                            //    Main.tile[l, Main.maxTilesY - m] = Main.tile[0, 0];
                            //}
                            //if (!TileBActive) {
                            //    Main.tile[l, m] = Main.tile[0, 0];
                            //}
                        }
                    }
                });
            }
            if (!(Main.setting.CorruptedWorld == 0)) {
                AddGenerationPass("Corrupting World", delegate (GenerationProgress progress) {
                    progress.Message = "Making the world truely evil...";


                    List<int> EffectedTiles = new List<int> {69, 396, 397, 53, 161, 59, 1, 2, 60};

                    ushort[] ResultingTiles = new ushort[400];

                    if (Main.setting.CorruptedWorld == 1) { // corruption
                        ResultingTiles[69] = 32;
                        ResultingTiles[396] = 400;
                        ResultingTiles[397] = 398;
                        ResultingTiles[53] = 112;
                        ResultingTiles[161] = 163;
                        ResultingTiles[59] = 0;
                        ResultingTiles[1] = 25;
                        ResultingTiles[2] = 23;
                        ResultingTiles[60] = 23;
                        //ResultingTiles.AddRange(new List<ushort> { 32, 400, 398, 112, 163, 0, 25, 23});
                    }
                    else {
                        ResultingTiles[69] = 352;
                        ResultingTiles[396] = 401;
                        ResultingTiles[397] = 399;
                        ResultingTiles[53] = 116;
                        ResultingTiles[161] = 164;
                        ResultingTiles[59] = 0;
                        ResultingTiles[1] = 203;
                        ResultingTiles[2] = 199;
                        ResultingTiles[60] = 199;
                        //ResultingTiles.AddRange(new List<ushort> { 352, 401, 399, 116, 164, 0, 203, 199});
                    }



                    var random = new Random();
                    for (int l = 0; l < Main.maxTilesX; l++) {
                        for (int m = 0; m < Main.maxTilesY; m++) {
                            if (Main.tile[l, m].active()) {
                                ushort oldType = Main.tile[l, m].type;
                                if (EffectedTiles.Contains(oldType)) {
                                    Main.tile[l, m].type = ResultingTiles[oldType];
                                }
                            }
                        }
                    }
                });
            }

			if (false) { // currently unused because this, isn't fair...
				AddGenerationPass("Limbo World", delegate (GenerationProgress progress) {
					progress.Message = "Darkening...";

					for (int l = 0; l < Main.maxTilesX; l++) {
						for (int m = 1; m < Main.maxTilesY; m++) {
							if (Main.tile[l, m].active()) {
								WorldGen.paintTile(l, m, 29);
							}
							if (Main.tile[l, m].wall != 0) {
								WorldGen.paintWall(l, m, 29);
							}
								//Main.tile[l, m]. = paintColor(29);
						}
					}
				});
			}

			AddGenerationPass("PAUSABLE", delegate (GenerationProgress progress) {
                progress.Message = "Doing Literally Nothing...";
                Main.tile[0, 0] = Main.tile[0, 0];
            }); // this is for testing so i can see the results without having to use something like TEdit

            WorldHooks.ModifyWorldGenTasks(_generator._passes, ref _generator._totalLoadWeight);
			_generator.GenerateWorld(customProgressObject);
			WorldHooks.PostWorldGen();
			Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
			BackupIO.archiveLock = true;
		}
        
		public static Point RandomRectanglePoint(Rectangle rectangle) => new Point(genRand.Next(rectangle.X, rectangle.X + rectangle.Width), genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));
		public static Point RandomRectanglePoint(int x, int y, int width, int height) => new Point(genRand.Next(x, x + width), genRand.Next(y, y + height));
		public static Point RandomWorldPoint(int padding) => RandomWorldPoint(padding, padding, padding, padding);
		public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0) => new Point(genRand.Next(left, Main.maxTilesX - right), genRand.Next(top, Main.maxTilesY - bottom));

		public static bool GrowPalmTree(int i, int y) {
			int j;
			for (j = y; TileLoader.IsSapling(Main.tile[i, j].type); j++) {
			}

			Tile tile = Main.tile[i, j];
			Tile tile2 = Main.tile[i, j - 1];
			if (!tile.active() || tile.halfBrick() || tile.slope() != 0)
				return false;

			if (tile2.wall != 0 || tile2.liquid != 0)
				return false;

			if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112 && !TileLoader.CanGrowModPalmTree(tile.type))
				return false;

			if (!EmptyTileCheck(i - 1, i + 1, j - 30, j - 1, 20))
				return false;

			int num = genRand.Next(10, 21);
			int num2 = genRand.Next(-8, 9);
			num2 *= 2;
			short num3 = 0;
			for (int k = 0; k < num; k++) {
				tile = Main.tile[i, j - 1 - k];
				if (k == 0) {
					tile.active(active: true);
					tile.type = 323;
					tile.frameX = 66;
					tile.frameY = 0;
					continue;
				}

				if (k == num - 1) {
					tile.active(active: true);
					tile.type = 323;
					tile.frameX = (short)(22 * genRand.Next(4, 7));
					tile.frameY = num3;
					continue;
				}

				if (num3 != num2) {
					float num4 = (float)k / (float)num;
					bool flag = false;
					if (!(num4 < 0.25f) && ((num4 < 0.5f && genRand.Next(13) == 0) || (num4 < 0.7f && genRand.Next(9) == 0) || !(num4 < 0.95f) || genRand.Next(5) != 0 || true)) {
						short num5 = (short)Math.Sign(num2);
						num3 = (short)(num3 + (short)(num5 * 2));
					}
				}

				tile.active(active: true);
				tile.type = 323;
				tile.frameX = (short)(22 * genRand.Next(0, 3));
				tile.frameY = num3;
			}

			RangeFrame(i - 2, j - num - 1, i + 2, j + 1);
			if (Main.netMode == 2)
				NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num * 0.5), num + 1);

			return true;
		}

		public static bool GrowEpicTree(int i, int y) {
			int j;
			for (j = y; TileLoader.IsSapling(Main.tile[i, j].type); j++) {
			}

			if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type))) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type))))) {
				int num = 2;
				if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20)) {
					bool flag = false;
					bool flag2 = false;
					int num2 = genRand.Next(20, 30);
					if (Main.setting.TreeLowerBound != 5)
						num2 = WorldGen.genRand.Next(Main.setting.TreeLowerBound, Main.setting.TreeUpperBound + 1);
					int num3;
					for (int k = j - num2; k < j; k++) {
						Main.tile[i, k].frameNumber((byte)genRand.Next(3));
						Main.tile[i, k].active(active: true);
						Main.tile[i, k].type = 5;
						num3 = genRand.Next(3);
						int num4 = genRand.Next(10);
						if (k == j - 1 || k == j - num2)
							num4 = 0;

						while (((num4 == 5 || num4 == 7) && flag) || ((num4 == 6 || num4 == 7) && flag2)) {
							num4 = genRand.Next(10);
						}

						flag = false;
						flag2 = false;
						if (num4 == 5 || num4 == 7)
							flag = true;

						if (num4 == 6 || num4 == 7)
							flag2 = true;

						switch (num4) {
							case 1:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 66;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 88;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 2:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 0;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 22;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 44;
								}
								break;
							case 3:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 44;
									Main.tile[i, k].frameY = 66;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 44;
									Main.tile[i, k].frameY = 88;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 44;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 4:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 66;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 88;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 5:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 88;
									Main.tile[i, k].frameY = 0;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 88;
									Main.tile[i, k].frameY = 22;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 88;
									Main.tile[i, k].frameY = 44;
								}
								break;
							case 6:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 66;
									Main.tile[i, k].frameY = 66;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 66;
									Main.tile[i, k].frameY = 88;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 66;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 7:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 110;
									Main.tile[i, k].frameY = 66;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 110;
									Main.tile[i, k].frameY = 88;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 110;
									Main.tile[i, k].frameY = 110;
								}
								break;
							default:
								if (num3 == 0) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 0;
								}
								if (num3 == 1) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 22;
								}
								if (num3 == 2) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 44;
								}
								break;
						}

						if (num4 == 5 || num4 == 7) {
							Main.tile[i - 1, k].active(active: true);
							Main.tile[i - 1, k].type = 5;
							num3 = genRand.Next(3);
							if (genRand.Next(3) < 2) {
								if (num3 == 0) {
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 198;
								}

								if (num3 == 1) {
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 220;
								}

								if (num3 == 2) {
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 242;
								}
							}
							else {
								if (num3 == 0) {
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 0;
								}

								if (num3 == 1) {
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 22;
								}

								if (num3 == 2) {
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 44;
								}
							}
						}

						if (num4 != 6 && num4 != 7)
							continue;

						Main.tile[i + 1, k].active(active: true);
						Main.tile[i + 1, k].type = 5;
						num3 = genRand.Next(3);
						if (genRand.Next(3) < 2) {
							if (num3 == 0) {
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 198;
							}

							if (num3 == 1) {
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 220;
							}

							if (num3 == 2) {
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 242;
							}
						}
						else {
							if (num3 == 0) {
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 66;
							}

							if (num3 == 1) {
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 88;
							}

							if (num3 == 2) {
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 110;
							}
						}
					}

					int num5 = genRand.Next(3);
					bool flag3 = false;
					bool flag4 = false;
					if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type)))
						flag3 = true;

					if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))
						flag4 = true;

					if (!flag3) {
						if (num5 == 0)
							num5 = 2;

						if (num5 == 1)
							num5 = 3;
					}

					if (!flag4) {
						if (num5 == 0)
							num5 = 1;

						if (num5 == 2)
							num5 = 3;
					}

					if (flag3 && !flag4)
						num5 = 2;

					if (flag4 && !flag3)
						num5 = 1;

					if (num5 == 0 || num5 == 1) {
						Main.tile[i + 1, j - 1].active(active: true);
						Main.tile[i + 1, j - 1].type = 5;
						num3 = genRand.Next(3);
						if (num3 == 0) {
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 132;
						}

						if (num3 == 1) {
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 154;
						}

						if (num3 == 2) {
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 176;
						}
					}

					if (num5 == 0 || num5 == 2) {
						Main.tile[i - 1, j - 1].active(active: true);
						Main.tile[i - 1, j - 1].type = 5;
						num3 = genRand.Next(3);
						if (num3 == 0) {
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 132;
						}

						if (num3 == 1) {
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 154;
						}

						if (num3 == 2) {
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 176;
						}
					}

					num3 = genRand.Next(3);
					switch (num5) {
						case 0:
							if (num3 == 0) {
								Main.tile[i, j - 1].frameX = 88;
								Main.tile[i, j - 1].frameY = 132;
							}
							if (num3 == 1) {
								Main.tile[i, j - 1].frameX = 88;
								Main.tile[i, j - 1].frameY = 154;
							}
							if (num3 == 2) {
								Main.tile[i, j - 1].frameX = 88;
								Main.tile[i, j - 1].frameY = 176;
							}
							break;
						case 1:
							if (num3 == 0) {
								Main.tile[i, j - 1].frameX = 0;
								Main.tile[i, j - 1].frameY = 132;
							}
							if (num3 == 1) {
								Main.tile[i, j - 1].frameX = 0;
								Main.tile[i, j - 1].frameY = 154;
							}
							if (num3 == 2) {
								Main.tile[i, j - 1].frameX = 0;
								Main.tile[i, j - 1].frameY = 176;
							}
							break;
						case 2:
							if (num3 == 0) {
								Main.tile[i, j - 1].frameX = 66;
								Main.tile[i, j - 1].frameY = 132;
							}
							if (num3 == 1) {
								Main.tile[i, j - 1].frameX = 66;
								Main.tile[i, j - 1].frameY = 154;
							}
							if (num3 == 2) {
								Main.tile[i, j - 1].frameX = 66;
								Main.tile[i, j - 1].frameY = 176;
							}
							break;
					}

					if (genRand.Next(8) != 0) {
						num3 = genRand.Next(3);
						if (num3 == 0) {
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 198;
						}

						if (num3 == 1) {
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 220;
						}

						if (num3 == 2) {
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					else {
						num3 = genRand.Next(3);
						if (num3 == 0) {
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 198;
						}

						if (num3 == 1) {
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 220;
						}

						if (num3 == 2) {
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 242;
						}
					}

					RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num2 * 0.5), num2 + 1);

					return true;
				}
			}

			return false;
		}

		public static bool Pyramid(int i, int j) {
			WorldGen.numPyramids++;
			ushort num = 151;
			int num2 = j - genRand.Next(0, 7);
			int num3 = genRand.Next(9, 13);
			int num4 = 1;
			int num5 = j + genRand.Next(75, 125); // TODO * Main.setting.PyramidSizeMultiplier;
			for (int k = num2; k < num5; k++) {
				for (int l = i - num4; l < i + num4 - 1; l++) {
					Main.tile[l, k].type = num;
					Main.tile[l, k].active(active: true);
					Main.tile[l, k].halfBrick(halfBrick: false);
					Main.tile[l, k].slope(0);
				}

				num4++;
			}

			for (int m = i - num4 - 5; m <= i + num4 + 5; m++) {
				for (int n = j - 1; n <= num5 + 1; n++) {
					bool flag = true;
					for (int num6 = m - 1; num6 <= m + 1; num6++) {
						for (int num7 = n - 1; num7 <= n + 1; num7++) {
							if (Main.tile[num6, num7].type != num)
								flag = false;
						}
					}

					if (flag) {
						Main.tile[m, n].wall = 34;
						SquareWallFrame(m, n);
					}
				}
			}

			int num8 = 1;
			if (genRand.Next(2) == 0)
				num8 = -1;

			int num9 = i - num3 * num8;
			int num10 = j + num3;
			int num11 = genRand.Next(5, 8);
			bool flag2 = true;
			int num12 = genRand.Next(20, 30);
			while (flag2) {
				flag2 = false;
				bool flag3 = false;
				for (int num13 = num10; num13 <= num10 + num11; num13++) {
					int num14 = num9;
					if (Main.tile[num14, num13 - 1].type == 53)
						flag3 = true;

					if (Main.tile[num14, num13].type == num) {
						Main.tile[num14, num13 + 1].wall = 34;
						Main.tile[num14 + num8, num13].wall = 34;
						Main.tile[num14, num13].active(active: false);
						flag2 = true;
					}

					if (flag3) {
						Main.tile[num14, num13].type = 53;
						Main.tile[num14, num13].active(active: true);
						Main.tile[num14, num13].halfBrick(halfBrick: false);
						Main.tile[num14, num13].slope(0);
					}
				}

				num9 -= num8;
			}

			num9 = i - num3 * num8;
			bool flag4 = true;
			bool flag5 = false;
			flag2 = true;
			while (flag2) {
				for (int num15 = num10; num15 <= num10 + num11; num15++) {
					int num16 = num9;
					Main.tile[num16, num15].active(active: false);
				}

				num9 += num8;
				num10++;
				num12--;
				if (num10 >= num5 - num11 * 2)
					num12 = 10;

				if (num12 <= 0) {
					bool flag6 = false;
					if (!flag4 && !flag5) {
						flag5 = true;
						flag6 = true;
						int num17 = genRand.Next(7, 13);
						int num18 = genRand.Next(23, 28);
						int num19 = num18;
						int num20 = num9;
						while (num18 > 0) {
							for (int num21 = num10 - num17 + num11; num21 <= num10 + num11; num21++) {
								if (num18 == num19 || num18 == 1) {
									if (num21 >= num10 - num17 + num11 + 2)
										Main.tile[num9, num21].active(active: false);
								}
								else if (num18 == num19 - 1 || num18 == 2 || num18 == num19 - 2 || num18 == 3) {
									if (num21 >= num10 - num17 + num11 + 1)
										Main.tile[num9, num21].active(active: false);
								}
								else {
									Main.tile[num9, num21].active(active: false);
								}
							}

							num18--;
							num9 += num8;
						}

						int num22 = num9 - num8;
						int num23 = num22;
						int num24 = num20;
						if (num22 > num20) {
							num23 = num20;
							num24 = num22;
						}

						int num25 = genRand.Next(3);
						switch (num25) {
							case 0:
								num25 = 857;
								break;
							case 1:
								num25 = 848;
								break;
							case 2:
								num25 = 934;
								break;
						}

						AddBuriedChest((num23 + num24) / 2, num10, num25, notNearOtherChests: false, 1);
						int num26 = genRand.Next(1, 10);
						for (int num27 = 0; num27 < num26; num27++) {
							int i2 = genRand.Next(num23, num24);
							int j2 = num10 + num11;
							PlaceSmallPile(i2, j2, genRand.Next(16, 19), 1, 185);
						}

						PlaceTile(num23 + 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num23 + 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num24 - 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num24 - 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						for (int num28 = num23; num28 <= num24; num28++) {
							PlacePot(num28, num10 + num11, 28, genRand.Next(25, 28));
						}
					}

					if (flag4) {
						flag4 = false;
						num8 *= -1;
						num12 = genRand.Next(15, 20);
					}
					else if (flag6) {
						num12 = genRand.Next(10, 15);
					}
					else {
						num8 *= -1;
						num12 = genRand.Next(20, 40);
					}
				}

				if (num10 >= num5 - num11)
					flag2 = false;
			}

			int num29 = genRand.Next(100, 200);
			int num30 = genRand.Next(500, 800);
			flag2 = true;
			int num31 = num11;
			num12 = genRand.Next(10, 50);
			if (num8 == 1)
				num9 -= num31;

			int num32 = genRand.Next(5, 10);
			while (flag2) {
				num29--;
				num30--;
				num12--;
				for (int num33 = num9 - num32 - genRand.Next(0, 2); num33 <= num9 + num31 + num32 + genRand.Next(0, 2); num33++) {
					int num34 = num10;
					if (num33 >= num9 && num33 <= num9 + num31) {
						Main.tile[num33, num34].active(active: false);
					}
					else {
						Main.tile[num33, num34].type = num;
						Main.tile[num33, num34].active(active: true);
						Main.tile[num33, num34].halfBrick(halfBrick: false);
						Main.tile[num33, num34].slope(0);
					}

					if (num33 >= num9 - 1 && num33 <= num9 + 1 + num31)
						Main.tile[num33, num34].wall = 34;
				}

				num10++;
				num9 += num8;
				if (num29 <= 0) {
					flag2 = false;
					for (int num35 = num9 + 1; num35 <= num9 + num31 - 1; num35++) {
						if (Main.tile[num35, num10].active())
							flag2 = true;
					}
				}

				if (num12 < 0) {
					num12 = genRand.Next(10, 50);
					num8 *= -1;
				}

				if (num30 <= 0)
					flag2 = false;
			}

			return true;
		}

		public static bool GrowLivingTree(int i, int j) {
			int num = 0;
			int[] array = new int[1000];
			int[] array2 = new int[1000];
			int[] array3 = new int[1000];
			int[] array4 = new int[1000];
			int num2 = 0;
			int[] array5 = new int[2000];
			int[] array6 = new int[2000];
			bool[] array7 = new bool[2000];
			if (!SolidTile(i, j + 1))
				return false;

			if (Main.tile[i, j].active())
				return false;

			int num3 = i - genRand.Next(1, 4);
			int num4 = i + genRand.Next(1, 4);
			if (j < 150)
				return false;

			int num5 = i - 50;
			int num6 = i + 50;
			for (int k = num5; k <= num6; k++) {
				for (int l = 5; l < j - 5; l++) {
					if (Main.tile[k, l].active())
						return false;
				}
			}

			int num7 = num3;
			int num8 = num4;
			int num9 = num3;
			int num10 = num4;
			int num11 = num4 - num3;
			bool flag = true;
			int num12 = genRand.Next(-10, -5);
			int num13 = genRand.Next(2);
			int num14 = j;
			while (flag) {
				num12++;
				if (num12 > genRand.Next(5, 30)) {
					num12 = 0;
					array2[num] = num14 + genRand.Next(5);
					if (genRand.Next(5) == 0)
						num13 = ((num13 == 0) ? 1 : 0);

					if (num13 == 0) {
						array3[num] = -1;
						array[num] = num3;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
							num3++;

						num7++;
						num13 = 1;
					}
					else {
						array3[num] = 1;
						array[num] = num4;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
							num4--;

						num8--;
						num13 = 0;
					}

					if (num7 == num8)
						flag = false;

					num++;
				}

				for (int m = num3; m <= num4; m++) {
					Main.tile[m, num14].type = 191;
					Main.tile[m, num14].active(active: true);
					Main.tile[m, num14].halfBrick(halfBrick: false);
				}

				num14--;
			}

			for (int n = 0; n < num; n++) {
				int num15 = array[n] + array3[n];
				int num16 = array2[n];
				int num17 = (int)((float)array4[n] * (1f + (float)genRand.Next(20, 30) * 0.1f));
				Main.tile[num15, num16 + 1].type = 191;
				Main.tile[num15, num16 + 1].active(active: true);
				Main.tile[num15, num16 + 1].halfBrick(halfBrick: false);
				int num18 = genRand.Next(3, 5);
				while (num17 > 0) {
					num17--;
					Main.tile[num15, num16].type = 191;
					Main.tile[num15, num16].active(active: true);
					Main.tile[num15, num16].halfBrick(halfBrick: false);
					if (genRand.Next(10) == 0)
						num16 = ((genRand.Next(2) != 0) ? (num16 + 1) : (num16 - 1));
					else
						num15 += array3[n];

					if (num18 > 0) {
						num18--;
					}
					else if (genRand.Next(2) == 0) {
						num18 = genRand.Next(2, 5);
						if (genRand.Next(2) == 0) {
							Main.tile[num15, num16].type = 191;
							Main.tile[num15, num16].active(active: true);
							Main.tile[num15, num16].halfBrick(halfBrick: false);
							Main.tile[num15, num16 - 1].type = 191;
							Main.tile[num15, num16 - 1].active(active: true);
							Main.tile[num15, num16 - 1].halfBrick(halfBrick: false);
							array5[num2] = num15;
							array6[num2] = num16;
							num2++;
						}
						else {
							Main.tile[num15, num16].type = 191;
							Main.tile[num15, num16].active(active: true);
							Main.tile[num15, num16].halfBrick(halfBrick: false);
							Main.tile[num15, num16 + 1].type = 191;
							Main.tile[num15, num16 + 1].active(active: true);
							Main.tile[num15, num16 + 1].halfBrick(halfBrick: false);
							array5[num2] = num15;
							array6[num2] = num16;
							num2++;
						}
					}

					if (num17 == 0) {
						array5[num2] = num15;
						array6[num2] = num16;
						num2++;
					}
				}
			}

			int num19 = (num3 + num4) / 2;
			int num20 = num14;
			int num21 = genRand.Next(num11 * 3, num11 * 5);
			int num22 = 0;
			int num23 = 0;
			while (num21 > 0) {
				Main.tile[num19, num20].type = 191;
				Main.tile[num19, num20].active(active: true);
				Main.tile[num19, num20].halfBrick(halfBrick: false);
				if (num22 > 0)
					num22--;

				if (num23 > 0)
					num23--;

				for (int num24 = -1; num24 < 2; num24++) {
					if (num24 == 0 || ((num24 >= 0 || num22 != 0) && (num24 <= 0 || num23 != 0)) || genRand.Next(2) != 0)
						continue;

					int num25 = num19;
					int num26 = num20;
					int num27 = genRand.Next(num11, num11 * 3);
					if (num24 < 0)
						num22 = genRand.Next(3, 5);

					if (num24 > 0)
						num23 = genRand.Next(3, 5);

					int num28 = 0;
					while (num27 > 0) {
						num27--;
						num25 += num24;
						Main.tile[num25, num26].type = 191;
						Main.tile[num25, num26].active(active: true);
						Main.tile[num25, num26].halfBrick(halfBrick: false);
						if (num27 == 0) {
							array5[num2] = num25;
							array6[num2] = num26;
							array7[num2] = true;
							num2++;
						}

						if (genRand.Next(5) == 0) {
							num26 = ((genRand.Next(2) != 0) ? (num26 + 1) : (num26 - 1));
							Main.tile[num25, num26].type = 191;
							Main.tile[num25, num26].active(active: true);
							Main.tile[num25, num26].halfBrick(halfBrick: false);
						}

						if (num28 > 0) {
							num28--;
						}
						else if (genRand.Next(3) == 0) {
							num28 = genRand.Next(2, 4);
							int num29 = num25;
							int num30 = num26;
							num30 = ((genRand.Next(2) != 0) ? (num30 + 1) : (num30 - 1));
							Main.tile[num29, num30].type = 191;
							Main.tile[num29, num30].active(active: true);
							Main.tile[num29, num30].halfBrick(halfBrick: false);
							array5[num2] = num29;
							array6[num2] = num30;
							array7[num2] = true;
							num2++;
						}
					}
				}

				array5[num2] = num19;
				array6[num2] = num20;
				num2++;
				if (genRand.Next(4) == 0) {
					num19 = ((genRand.Next(2) != 0) ? (num19 + 1) : (num19 - 1));
					Main.tile[num19, num20].type = 191;
					Main.tile[num19, num20].active(active: true);
					Main.tile[num19, num20].halfBrick(halfBrick: false);
				}

				num20--;
				num21--;
			}

			for (int num31 = num9; num31 <= num10; num31++) {
				int num32 = genRand.Next(1, 6);
				int num33 = j + 1;
				while (num32 > 0) {
					if (SolidTile(num31, num33))
						num32--;

					Main.tile[num31, num33].type = 191;
					Main.tile[num31, num33].active(active: true);
					Main.tile[num31, num33].halfBrick(halfBrick: false);
					num33++;
				}

				int num34 = num33;
				for (int num35 = 0; num35 < 2; num35++) {
					num33 = num34;
					int num36 = (num9 + num10) / 2;
					int num37 = 0;
					int num38 = 1;
					num37 = ((num31 >= num36) ? 1 : (-1));
					if (num31 == num36 || (num11 > 6 && (num31 == num36 - 1 || num31 == num36 + 1)))
						num37 = 0;

					int num39 = num37;
					int num40 = num31;
					num32 = genRand.Next((int)((double)num11 * 2.5), num11 * 4);
					while (num32 > 0) {
						num32--;
						num40 += num37;
						Main.tile[num40, num33].type = 191;
						Main.tile[num40, num33].active(active: true);
						Main.tile[num40, num33].halfBrick(halfBrick: false);
						num33 += num38;
						Main.tile[num40, num33].type = 191;
						Main.tile[num40, num33].active(active: true);
						Main.tile[num40, num33].halfBrick(halfBrick: false);
						if (!Main.tile[num40, num33 + 1].active()) {
							num37 = 0;
							num38 = 1;
						}

						if (genRand.Next(3) == 0)
							num37 = ((num39 < 0) ? ((num37 == 0) ? (-1) : 0) : ((num39 <= 0) ? genRand.Next(-1, 2) : ((num37 == 0) ? 1 : 0)));

						if (genRand.Next(3) == 0)
							num38 = ((num38 == 0) ? 1 : 0);
					}
				}
			}

			for (int num41 = 0; num41 < num2; num41++) {
				int num42 = genRand.Next(5, 8);
				num42 = (int)((float)num42 * (1f + (float)num11 * 0.05f));
				if (array7[num41])
					num42 = genRand.Next(7, 13);

				int num43 = array5[num41] - num42;
				int num44 = array5[num41] + num42;
				int num45 = array6[num41] - num42;
				int num46 = array6[num41] + num42;
				float num47 = 2f - (float)genRand.Next(5) * 0.1f;
				for (int num48 = num43; num48 <= num44; num48++) {
					for (int num49 = num45; num49 <= num46; num49++) {
						if (Main.tile[num48, num49].type != 191 && (float)Math.Abs(array5[num41] - num48) + (float)Math.Abs(array6[num41] - num49) * num47 < (float)num42) {
							Main.tile[num48, num49].type = 192;
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].halfBrick(halfBrick: false);
						}
					}
				}
			}

			if (num11 >= 4 && genRand.Next(3) != 0) {
				bool flag2 = false;
				int num50 = num9;
				int num51 = num10;
				int num52 = j - 5;
				int num53 = 50;
				int num54 = genRand.Next(400, 700);
				int num55 = 1;
				bool flag3 = true;
				while (num54 > 0) {
					num52++;
					num54--;
					num53--;
					int num56 = (num9 + num10) / 2;
					int num57 = 0;
					if (num52 > j && num11 == 4)
						num57 = 1;

					for (int num58 = num9 - num57; num58 <= num10 + num57; num58++) {
						if (num58 > num56 - 2 && num58 <= num56 + 1) {
							if (Main.tile[num58, num52].type != 19)
								Main.tile[num58, num52].active(active: false);

							Main.tile[num58, num52].wall = 78;
							if (Main.tile[num58 - 1, num52].wall > 0 || (double)num52 >= Main.worldSurface)
								Main.tile[num58 - 1, num52].wall = 78;

							if (Main.tile[num58 + 1, num52].wall > 0 || (double)num52 >= Main.worldSurface)
								Main.tile[num58 + 1, num52].wall = 78;
						}
						else {
							Main.tile[num58, num52].type = 191;
							Main.tile[num58, num52].active(active: true);
							Main.tile[num58, num52].halfBrick(halfBrick: false);
						}
					}

					num55++;
					if (num55 >= 6) {
						num55 = 0;
						int num59 = genRand.Next(3);
						if (num59 == 0)
							num59 = -1;

						if (flag3)
							num59 = 2;

						if (num59 == 2) {
							flag3 = false;
							for (int num60 = num9; num60 <= num10; num60++) {
								if (num60 > num56 - 2 && num60 <= num56 + 1) {
									Main.tile[num60, num52 + 1].active(active: false);
									PlaceTile(num60, num52 + 1, 19, mute: true, forced: false, -1, 23);
								}
							}
						}
						else {
							num9 += num59;
							num10 += num59;
						}

						if (num53 <= 0 && !flag2) {
							flag2 = true;
							int num61 = genRand.Next(2);
							if (num61 == 0)
								num61 = -1;

							int num62 = num52 - 2;
							int num63 = num52;
							int num64 = (num9 + num10) / 2;
							if (num61 < 0)
								num64--;

							if (num61 > 0)
								num64++;

							int num65 = genRand.Next(15, 30);
							int num66 = num64 + num65;
							if (num61 < 0) {
								num66 = num64;
								num64 -= num65;
							}

							dMinX = num64;
							dMaxX = num66;
							if (num61 < 0)
								dMinX -= 40;
							else
								dMaxX += 40;

							bool flag4 = false;
							for (int num67 = num64; num67 < num66; num67++) {
								for (int num68 = num52 - 20; num68 < num52 + 10; num68++) {
									if (Main.tile[num67, num68].wall == 0 && !Main.tile[num67, num68].active() && (double)num68 < Main.worldSurface)
										flag4 = true;
								}
							}

							if (!flag4) {
								for (int num69 = num64; num69 <= num66; num69++) {
									for (int num70 = num62 - 2; num70 <= num63 + 2; num70++) {
										if (Main.tile[num69, num70].wall != 78 && Main.tile[num69, num70].type != 19) {
											Main.tile[num69, num70].active(active: true);
											Main.tile[num69, num70].type = 191;
											Main.tile[num69, num70].halfBrick(halfBrick: false);
										}

										if (num70 >= num62 && num70 <= num63) {
											Main.tile[num69, num70].liquid = 0;
											Main.tile[num69, num70].wall = 78;
											Main.tile[num69, num70].active(active: false);
										}
									}
								}

								int i2 = (num9 + num10) / 2 + 3 * num61;
								int j2 = num52;
								PlaceTile(i2, j2, 10, mute: true, forced: false, -1, 7);
								int num71 = genRand.Next(5, 9);
								int num72 = genRand.Next(4, 6);
								if (num61 < 0) {
									num66 = num64 + num71;
									num64 -= num71;
								}
								else {
									num64 = num66 - num71;
									num66 += num71;
								}

								num62 = num63 - num72;
								for (int num73 = num64 - 2; num73 <= num66 + 2; num73++) {
									for (int num74 = num62 - 2; num74 <= num63 + 2; num74++) {
										if (Main.tile[num73, num74].wall != 78 && Main.tile[num73, num74].type != 19) {
											Main.tile[num73, num74].active(active: true);
											Main.tile[num73, num74].type = 191;
											Main.tile[num73, num74].halfBrick(halfBrick: false);
										}

										if (num74 >= num62 && num74 <= num63 && num73 >= num64 && num73 <= num66) {
											Main.tile[num73, num74].liquid = 0;
											Main.tile[num73, num74].wall = 78;
											Main.tile[num73, num74].active(active: false);
										}
									}
								}

								i2 = num64 - 2;
								if (num61 < 0)
									i2 = num66 + 2;

								PlaceTile(i2, j2, 10, mute: true, forced: false, -1, 7);
								int num75 = num66;
								if (num61 < 0)
									num75 = num64;

								PlaceTile(num75, num52, 15, mute: true, forced: false, -1, 5);
								if (num61 < 0) {
									Main.tile[num75, num52 - 1].frameX += 18;
									Main.tile[num75, num52].frameX += 18;
								}

								num75 = num66 - 2;
								if (num61 < 0)
									num75 = num64 + 2;

								PlaceTile(num75, num52, 14, mute: true, forced: false, -1, 6);
								num75 = num66 - 4;
								if (num61 < 0)
									num75 = num64 + 4;

								PlaceTile(num75, num52, 15, mute: true, forced: false, -1, 5);
								if (num61 > 0) {
									Main.tile[num75, num52 - 1].frameX += 18;
									Main.tile[num75, num52].frameX += 18;
								}

								num75 = num66 - 7;
								if (num61 < 0)
									num75 = num64 + 8;

								int num76 = genRand.Next(2);
								num76 = 832;
								AddBuriedChest(num75, num52, num76, notNearOtherChests: false, 12);
							}
						}
					}

					if (num53 > 0)
						continue;

					bool flag5 = true;
					for (int num77 = num9; num77 <= num10; num77++) {
						for (int num78 = num52 + 1; num78 <= num52 + 4; num78++) {
							if (SolidTile(num77, num78))
								flag5 = false;
						}
					}

					if (flag5)
						num54 = 0;
				}

				num9 = num50;
				num10 = num51;
				int num79 = (num9 + num10) / 2;
				if (genRand.Next(2) == 0)
					num10 = num79;
				else
					num9 = num79;

				for (int num80 = num9; num80 <= num10; num80++) {
					for (int num81 = j - 3; num81 <= j; num81++) {
						Main.tile[num80, num81].active(active: false);
						bool flag6 = true;
						for (int num82 = num80 - 1; num82 <= num80 + 1; num82++) {
							for (int num83 = num81 - 1; num83 <= num81 + 1; num83++) {
								if (!Main.tile[num82, num83].active() && Main.tile[num82, num83].wall == 0)
									flag6 = false;
							}
						}

						if (flag6)
							Main.tile[num80, num81].wall = 78;
					}
				}
			}

			return true;
		}

		public static void TreeGrowFXCheck(int x, int y) {
			int num = 1;
			int num2 = -1;
			Tile tile = null;
			for (int num3 = -1; num3 > -100; num3--) {
				Tile tile2 = Main.tile[x, y + num3];
				if (!tile2.active() || (tile2.type != 5 && tile2.type != 323 && tile2.type != 72))
					break;

				tile = tile2;
				num++;
			}

			for (int i = 1; i < 5; i++) {
				Tile tile3 = Main.tile[x, y + i];
				if (tile3.active() && (tile3.type == 5 || tile3.type == 323 || tile3.type == 72)) {
					num++;
					continue;
				}

				int num4 = 0;
				if (tile.frameX == 22) {
					if (tile.frameY == 220)
						num4 = 1;
					else if (tile.frameY == 242)
						num4 = 2;
				}

				TileLoader.TreeGrowthFXGore(tile3.type, ref num2);
				if (num2 > 0)
					break;

				TileLoader.PalmTreeGrowthFXGore(tile3.type, ref num2);
				if (num2 > 0)
					break;

				switch (tile3.type) {
					case 2:
						num2 = 910;
						break;
					case 60:
						num2 = 914;
						break;
					case 70:
						num2 = 912;
						break;
					case 23:
					case 400:
						num2 = 915;
						break;
					case 199:
					case 234:
						num2 = 916;
						break;
					case 53:
						num2 = 911;
						break;
					case 116:
						num2 = 919;
						break;
					case 147:
						num2 = 913;
						break;
					case 109: {
							if (x % 3 == 1)
								num4 += 3;

							if (x % 3 == 2)
								num4 += 6;

							int num5 = 917;
							switch (num4) {
								case 0:
									num2 = 2;
									break;
								case 1:
									num2 = 1;
									break;
								case 2:
									num2 = 7;
									break;
								case 3:
									num2 = 4;
									break;
								case 4:
									num2 = 5;
									break;
								case 5:
									num2 = 6;
									break;
								case 6:
									num2 = 3;
									break;
								case 7:
									num2 = 8;
									break;
								case 8:
									num2 = 0;
									break;
							}

							num2 += num5;
							num += 5;
							break;
						}
				}

				break;
			}

			if (num > 0 && num2 > 0) {
				if (Main.netMode == 2)
					NetMessage.SendData(112, -1, -1, null, 1, x, y, num, num2);

				if (Main.netMode == 0)
					TreeGrowFX(x, y, num, num2);
			}
		}

		public static void TreeGrowFX(int x, int y, int height, int treeGore) {
			Vector2 value = new Vector2(x, y) * 16f + new Vector2(8f, 8f);
			int num = 4;
			int maxValue = 2;
			for (int num2 = 0; num2 > -height; num2--) {
				if (num2 > -height / 2 && Main.rand.Next(3) != 0) {
					for (int i = 0; i < 5; i++) {
						Dust.NewDust(value + new Vector2(-16f, num2 * 16) + Utils.RandomVector2(Main.rand, -20f, 20f), 4, 4, num + Main.rand.Next(maxValue), 0f, -4f, 100);
					}
				}
				else {
					float num3 = 10f;
					Gore.NewGore(value + new Vector2(-16f, num2 * 16), Utils.RandomVector2(Main.rand, 0f - num3, num3), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
					Gore.NewGore(value + new Vector2(0f, num2 * 16), Utils.RandomVector2(Main.rand, 0f - num3, num3), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
					Gore.NewGore(value + new Vector2(16f, num2 * 16), Utils.RandomVector2(Main.rand, 0f - num3, num3), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
					if (num2 == -height + 1) {
						for (int j = 0; j < 20; j++) {
							Gore.NewGore(value + new Vector2(0f, num2 * 16 - 40) + Utils.RandomVector2(Main.rand, -40f, 40f), Utils.RandomVector2(Main.rand, -10f, 10f), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
						}
					}
				}
			}
		}

		public static bool GrowTree(int i, int y) {
			int j;
			for (j = y; TileLoader.IsSapling(Main.tile[i, j].type); j++) {
			}

			if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && Main.tile[i, j].type != 60)
				return false;

			if (Main.tile[i, j].nactive() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 23 || Main.tile[i, j].type == 60 || Main.tile[i, j].type == 109 || Main.tile[i, j].type == 147 || Main.tile[i, j].type == 199 || Main.tile[i, j].type == 70 || TileLoader.CanGrowModTree(Main.tile[i, j].type)) && (Main.tile[i, j - 1].wall == 0 || Main.tile[i, j - 1].wall == 106 || Main.tile[i, j - 1].wall == 107 || Main.tile[i, j - 1].wall >= 138 && Main.tile[i, j - 1].wall <= 141 || Main.tile[i, j - 1].wall == 145 || Main.tile[i, j - 1].wall == 150 || Main.tile[i, j - 1].wall == 152) && (Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || Main.tile[i - 1, j].type == 147 || Main.tile[i - 1, j].type == 199 || Main.tile[i - 1, j].type == 70 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type)) || Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || Main.tile[i + 1, j].type == 147 || Main.tile[i + 1, j].type == 199 || Main.tile[i + 1, j].type == 70 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))) {
				// desert? near spawn? near ocean, near dungeon
				int num = 2;
				int num2 = Main.setting.TreeUpperBound; // 16;
				if (Main.tile[i, j].type == 60)
					num2 += 5;

				if (EmptyTileCheck(i - num, i + num, j - num2, j - 1, 20)) {
					bool flag = false;
					bool flag2 = false;
					int num3 = genRand.Next(Main.setting.TreeLowerBound, num2 + 1);
					int num4;
					for (int k = j - num3; k < j; k++) {
						Main.tile[i, k].frameNumber((byte)genRand.Next(3));
						Main.tile[i, k].active(active: true);
						Main.tile[i, k].type = 5;
						num4 = genRand.Next(3);
						int num5 = genRand.Next(10);
						if (k == j - 1 || k == j - num3)
							num5 = 0;

						while (((num5 == 5 || num5 == 7) && flag) || ((num5 == 6 || num5 == 7) && flag2)) {
							num5 = genRand.Next(10);
						}

						flag = false;
						flag2 = false;
						if (num5 == 5 || num5 == 7)
							flag = true;

						if (num5 == 6 || num5 == 7)
							flag2 = true;

						switch (num5) {
							case 1:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 66;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 88;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 2:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 0;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 22;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 44;
								}
								break;
							case 3:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 44;
									Main.tile[i, k].frameY = 66;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 44;
									Main.tile[i, k].frameY = 88;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 44;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 4:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 66;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 88;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 22;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 5:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 88;
									Main.tile[i, k].frameY = 0;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 88;
									Main.tile[i, k].frameY = 22;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 88;
									Main.tile[i, k].frameY = 44;
								}
								break;
							case 6:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 66;
									Main.tile[i, k].frameY = 66;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 66;
									Main.tile[i, k].frameY = 88;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 66;
									Main.tile[i, k].frameY = 110;
								}
								break;
							case 7:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 110;
									Main.tile[i, k].frameY = 66;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 110;
									Main.tile[i, k].frameY = 88;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 110;
									Main.tile[i, k].frameY = 110;
								}
								break;
							default:
								if (num4 == 0) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 0;
								}
								if (num4 == 1) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 22;
								}
								if (num4 == 2) {
									Main.tile[i, k].frameX = 0;
									Main.tile[i, k].frameY = 44;
								}
								break;
						}

						if (num5 == 5 || num5 == 7) {
							Main.tile[i - 1, k].active(active: true);
							Main.tile[i - 1, k].type = 5;
							num4 = genRand.Next(3);
							if (genRand.Next(3) < 2) {
								if (num4 == 0) {
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 198;
								}

								if (num4 == 1) {
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 220;
								}

								if (num4 == 2) {
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 242;
								}
							}
							else {
								if (num4 == 0) {
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 0;
								}

								if (num4 == 1) {
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 22;
								}

								if (num4 == 2) {
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 44;
								}
							}
						}

						if (num5 != 6 && num5 != 7)
							continue;

						Main.tile[i + 1, k].active(active: true);
						Main.tile[i + 1, k].type = 5;
						num4 = genRand.Next(3);
						if (genRand.Next(3) < 2) {
							if (num4 == 0) {
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 198;
							}

							if (num4 == 1) {
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 220;
							}

							if (num4 == 2) {
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 242;
							}
						}
						else {
							if (num4 == 0) {
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 66;
							}

							if (num4 == 1) {
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 88;
							}

							if (num4 == 2) {
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 110;
							}
						}
					}

					int num6 = genRand.Next(3);
					bool flag3 = false;
					bool flag4 = false;
					if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || Main.tile[i - 1, j].type == 147 || Main.tile[i - 1, j].type == 199 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type)))
						flag3 = true;

					if (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || Main.tile[i + 1, j].type == 147 || Main.tile[i + 1, j].type == 199 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))
						flag4 = true;

					if (!flag3) {
						if (num6 == 0)
							num6 = 2;

						if (num6 == 1)
							num6 = 3;
					}

					if (!flag4) {
						if (num6 == 0)
							num6 = 1;

						if (num6 == 2)
							num6 = 3;
					}

					if (flag3 && !flag4)
						num6 = 2;

					if (flag4 && !flag3)
						num6 = 1;

					if (num6 == 0 || num6 == 1) {
						Main.tile[i + 1, j - 1].active(active: true);
						Main.tile[i + 1, j - 1].type = 5;
						num4 = genRand.Next(3);
						if (num4 == 0) {
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 132;
						}

						if (num4 == 1) {
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 154;
						}

						if (num4 == 2) {
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 176;
						}
					}

					if (num6 == 0 || num6 == 2) {
						Main.tile[i - 1, j - 1].active(active: true);
						Main.tile[i - 1, j - 1].type = 5;
						num4 = genRand.Next(3);
						if (num4 == 0) {
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 132;
						}

						if (num4 == 1) {
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 154;
						}

						if (num4 == 2) {
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 176;
						}
					}

					num4 = genRand.Next(3);
					switch (num6) {
						case 0:
							if (num4 == 0) {
								Main.tile[i, j - 1].frameX = 88;
								Main.tile[i, j - 1].frameY = 132;
							}
							if (num4 == 1) {
								Main.tile[i, j - 1].frameX = 88;
								Main.tile[i, j - 1].frameY = 154;
							}
							if (num4 == 2) {
								Main.tile[i, j - 1].frameX = 88;
								Main.tile[i, j - 1].frameY = 176;
							}
							break;
						case 1:
							if (num4 == 0) {
								Main.tile[i, j - 1].frameX = 0;
								Main.tile[i, j - 1].frameY = 132;
							}
							if (num4 == 1) {
								Main.tile[i, j - 1].frameX = 0;
								Main.tile[i, j - 1].frameY = 154;
							}
							if (num4 == 2) {
								Main.tile[i, j - 1].frameX = 0;
								Main.tile[i, j - 1].frameY = 176;
							}
							break;
						case 2:
							if (num4 == 0) {
								Main.tile[i, j - 1].frameX = 66;
								Main.tile[i, j - 1].frameY = 132;
							}
							if (num4 == 1) {
								Main.tile[i, j - 1].frameX = 66;
								Main.tile[i, j - 1].frameY = 154;
							}
							if (num4 == 2) {
								Main.tile[i, j - 1].frameX = 66;
								Main.tile[i, j - 1].frameY = 176;
							}
							break;
					}

					if (genRand.Next(8) != 0) {
						num4 = genRand.Next(3);
						if (num4 == 0) {
							Main.tile[i, j - num3].frameX = 22;
							Main.tile[i, j - num3].frameY = 198;
						}

						if (num4 == 1) {
							Main.tile[i, j - num3].frameX = 22;
							Main.tile[i, j - num3].frameY = 220;
						}

						if (num4 == 2) {
							Main.tile[i, j - num3].frameX = 22;
							Main.tile[i, j - num3].frameY = 242;
						}
					}
					else {
						num4 = genRand.Next(3);
						if (num4 == 0) {
							Main.tile[i, j - num3].frameX = 0;
							Main.tile[i, j - num3].frameY = 198;
						}

						if (num4 == 1) {
							Main.tile[i, j - num3].frameX = 0;
							Main.tile[i, j - num3].frameY = 220;
						}

						if (num4 == 2) {
							Main.tile[i, j - num3].frameX = 0;
							Main.tile[i, j - num3].frameY = 242;
						}
					}

					RangeFrame(i - 2, j - num3 - 1, i + 2, j + 1);
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num3 * 0.5), num3 + 1);

					return true;
				}
			}

			return false;
		}

		public static void GrowUndergroundTree(int i, int y) {
			if (Main.tile[i, y].type != 60 || !Main.tile[i, y].nactive() || Main.tile[i, y].halfBrick() || Main.tile[i, y].slope() != 0 || Main.tile[i, y].type != 60 || ((!Main.tile[i - 1, y].active() || Main.tile[i - 1, y].type != 60) && (!Main.tile[i + 1, y].active() || Main.tile[i + 1, y].type != 60)))
				return;

			int num = 1;
			int num2 = genRand.Next(5, 15);
			int num3 = num2 + 2;
			if (Main.tile[i, y].type == 60)
				num3 += 5;

			if (!EmptyTileCheck(i - num, i + num, y - num3, y - 1, 20))
				return;

			bool flag = false;
			bool flag2 = false;
			int num4;
			for (int j = y - num2; j < y; j++) {
				Main.tile[i, j].frameNumber((byte)genRand.Next(3));
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].type = 5;
				num4 = genRand.Next(3);
				int num5 = genRand.Next(10);
				if (j == y - 1 || j == y - num2)
					num5 = 0;

				while (((num5 == 5 || num5 == 7) && flag) || ((num5 == 6 || num5 == 7) && flag2)) {
					num5 = genRand.Next(10);
				}

				flag = false;
				flag2 = false;
				if (num5 == 5 || num5 == 7)
					flag = true;

				if (num5 == 6 || num5 == 7)
					flag2 = true;

				switch (num5) {
					case 1:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 66;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 88;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 110;
						}
						break;
					case 2:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 22;
							Main.tile[i, j].frameY = 0;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 22;
							Main.tile[i, j].frameY = 22;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 22;
							Main.tile[i, j].frameY = 44;
						}
						break;
					case 3:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 44;
							Main.tile[i, j].frameY = 66;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 44;
							Main.tile[i, j].frameY = 88;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 44;
							Main.tile[i, j].frameY = 110;
						}
						break;
					case 4:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 22;
							Main.tile[i, j].frameY = 66;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 22;
							Main.tile[i, j].frameY = 88;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 22;
							Main.tile[i, j].frameY = 110;
						}
						break;
					case 5:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 88;
							Main.tile[i, j].frameY = 0;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 88;
							Main.tile[i, j].frameY = 22;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 88;
							Main.tile[i, j].frameY = 44;
						}
						break;
					case 6:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 66;
							Main.tile[i, j].frameY = 66;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 66;
							Main.tile[i, j].frameY = 88;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 66;
							Main.tile[i, j].frameY = 110;
						}
						break;
					case 7:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 110;
							Main.tile[i, j].frameY = 66;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 110;
							Main.tile[i, j].frameY = 88;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 110;
							Main.tile[i, j].frameY = 110;
						}
						break;
					default:
						if (num4 == 0) {
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 0;
						}
						if (num4 == 1) {
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 22;
						}
						if (num4 == 2) {
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 44;
						}
						break;
				}

				if (num5 == 5 || num5 == 7) {
					Main.tile[i - 1, j].active(active: true);
					Main.tile[i - 1, j].type = 5;
					num4 = genRand.Next(3);
					if (genRand.Next(3) < 2) {
						if (num4 == 0) {
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 198;
						}

						if (num4 == 1) {
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 220;
						}

						if (num4 == 2) {
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 242;
						}
					}
					else {
						if (num4 == 0) {
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 0;
						}

						if (num4 == 1) {
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 22;
						}

						if (num4 == 2) {
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 44;
						}
					}
				}

				if (num5 != 6 && num5 != 7)
					continue;

				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].type = 5;
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2) {
					if (num4 == 0) {
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 198;
					}

					if (num4 == 1) {
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 220;
					}

					if (num4 == 2) {
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 242;
					}
				}
				else {
					if (num4 == 0) {
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 66;
					}

					if (num4 == 1) {
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 88;
					}

					if (num4 == 2) {
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 110;
					}
				}
			}

			int num6 = genRand.Next(3);
			bool flag3 = false;
			bool flag4 = false;
			if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147))
				flag3 = true;

			if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147))
				flag4 = true;

			if (!flag3) {
				if (num6 == 0)
					num6 = 2;

				if (num6 == 1)
					num6 = 3;
			}

			if (!flag4) {
				if (num6 == 0)
					num6 = 1;

				if (num6 == 2)
					num6 = 3;
			}

			if (flag3 && !flag4)
				num6 = 2;

			if (flag4 && !flag3)
				num6 = 1;

			if (num6 == 0 || num6 == 1) {
				Main.tile[i + 1, y - 1].active(active: true);
				Main.tile[i + 1, y - 1].type = 5;
				num4 = genRand.Next(3);
				if (num4 == 0) {
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 132;
				}

				if (num4 == 1) {
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 154;
				}

				if (num4 == 2) {
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 176;
				}
			}

			if (num6 == 0 || num6 == 2) {
				Main.tile[i - 1, y - 1].active(active: true);
				Main.tile[i - 1, y - 1].type = 5;
				num4 = genRand.Next(3);
				if (num4 == 0) {
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 132;
				}

				if (num4 == 1) {
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 154;
				}

				if (num4 == 2) {
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 176;
				}
			}

			num4 = genRand.Next(3);
			switch (num6) {
				case 0:
					if (num4 == 0) {
						Main.tile[i, y - 1].frameX = 88;
						Main.tile[i, y - 1].frameY = 132;
					}
					if (num4 == 1) {
						Main.tile[i, y - 1].frameX = 88;
						Main.tile[i, y - 1].frameY = 154;
					}
					if (num4 == 2) {
						Main.tile[i, y - 1].frameX = 88;
						Main.tile[i, y - 1].frameY = 176;
					}
					break;
				case 1:
					if (num4 == 0) {
						Main.tile[i, y - 1].frameX = 0;
						Main.tile[i, y - 1].frameY = 132;
					}
					if (num4 == 1) {
						Main.tile[i, y - 1].frameX = 0;
						Main.tile[i, y - 1].frameY = 154;
					}
					if (num4 == 2) {
						Main.tile[i, y - 1].frameX = 0;
						Main.tile[i, y - 1].frameY = 176;
					}
					break;
				case 2:
					if (num4 == 0) {
						Main.tile[i, y - 1].frameX = 66;
						Main.tile[i, y - 1].frameY = 132;
					}
					if (num4 == 1) {
						Main.tile[i, y - 1].frameX = 66;
						Main.tile[i, y - 1].frameY = 154;
					}
					if (num4 == 2) {
						Main.tile[i, y - 1].frameX = 66;
						Main.tile[i, y - 1].frameY = 176;
					}
					break;
			}

			if (genRand.Next(8) != 0) {
				num4 = genRand.Next(3);
				if (num4 == 0) {
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 198;
				}

				if (num4 == 1) {
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 220;
				}

				if (num4 == 2) {
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 242;
				}
			}
			else {
				num4 = genRand.Next(3);
				if (num4 == 0) {
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 198;
				}

				if (num4 == 1) {
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 220;
				}

				if (num4 == 2) {
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 242;
				}
			}

			RangeFrame(i - 2, y - num2 - 1, i + 2, y + 1);
			if (Main.netMode == 2)
				NetMessage.SendTileSquare(-1, i, (int)((double)y - (double)num2 * 0.5), num2 + 1);
		}

		public static bool GrowShroom(int i, int y) {
			if (Main.tile[i - 1, y - 1].lava() || Main.tile[i - 1, y - 1].lava() || Main.tile[i + 1, y - 1].lava())
				return false;

			if (Main.tile[i, y].nactive() && !Main.tile[i, y].halfBrick() && Main.tile[i, y].slope() == 0 && Main.tile[i, y].type == 70 && Main.tile[i, y - 1].wall == 0 && Main.tile[i - 1, y].active() && Main.tile[i - 1, y].type == 70 && Main.tile[i + 1, y].active() && Main.tile[i + 1, y].type == 70 && EmptyTileCheck(i - 2, i + 2, y - 13, y - 1, 71)) {
				int num = genRand.Next(4, 11);
				for (int j = y - num; j < y; j++) {
					Main.tile[i, j].frameNumber((byte)genRand.Next(3));
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 72;
					int num2 = genRand.Next(3);
					if (num2 == 0) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}

					if (num2 == 1) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 18;
					}

					if (num2 == 2) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 36;
					}
				}

				int num3 = genRand.Next(3);
				if (num3 == 0) {
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 0;
				}

				if (num3 == 1) {
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 18;
				}

				if (num3 == 2) {
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 36;
				}

				RangeFrame(i - 2, y - num - 1, i + 2, y + 1);
				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, i, (int)((double)y - (double)num * 0.5), num + 1);

				return true;
			}

			return false;
		}

		public static void AddTrees() {
			for (int i = 1; i < Main.maxTilesX - 1; i++) {
				for (int j = 20; (double)j < Main.worldSurface; j++) {
					GrowTree(i, j);
					if ((i < 380 || i > Main.maxTilesX - 380) && genRand.Next(3) == 0)
						GrowPalmTree(i, j);
				}

				if (genRand.Next(3) == 0)
					i++;

				if (genRand.Next(4) == 0)
					i++;
			}
		}

		public static void ExplodeMine(int i, int j) {
			_ = Main.tile[i, j].type;
			KillTile(i, j, fail: false, effectOnly: false, noItem: true);
			NetMessage.SendTileSquare(-1, i, j, 1);
			Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 0f, 164, 250, 10f, Main.myPlayer);
		}

		public static bool EmptyTileCheck(int startX, int endX, int startY, int endY, int ignoreID = -1) {
			if (startX < 0)
				return false;

			if (endX >= Main.maxTilesX)
				return false;

			if (startY < 0)
				return false;

			if (endY >= Main.maxTilesY)
				return false;

			for (int i = startX; i < endX + 1; i++) {
				for (int j = startY; j < endY + 1; j++) {
					if (!Main.tile[i, j].active())
						continue;

					switch (ignoreID) {
						case -1:
							return false;
						case 11: {
								ushort type = Main.tile[i, j].type;
								if (type != 11)
									return false;

								break;
							}
						case 71: {
								ushort type = Main.tile[i, j].type;
								if (type != 71)
									return false;

								break;
							}
						case int _ when TileLoader.IsSapling(ignoreID):
							switch (Main.tile[i, j].type) {
								default:
									return false;
								case 3:
								case ushort _ when TileLoader.IsSapling(Main.tile[i, j].type):
								case 24:
								case 32:
								case 61:
								case 62:
								case 69:
								case 71:
								case 73:
								case 74:
								case 82:
								case 83:
								case 84:
								case 110:
								case 113:
								case 201:
								case 233:
								case 352:
									break;
							}
							break;
					}
				}
			}

			return true;
		}

		public static void StartHardmode() {
			if (Main.netMode != 1 && !Main.hardMode) {
				Main.hardMode = true;
				Main.InitLifeBytes();
				ThreadPool.QueueUserWorkItem(smCallBack, 1);
			}
		}

		public static void smCallBack(object threadContext) {
			List<GenPass> hardmodetasks = new List<GenPass>();
			IsGeneratingHardMode = true;
			if (Main.rand == null)
				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);

			float num = (float)genRand.Next(300, 400) * 0.001f;
			float num2 = (float)genRand.Next(200, 300) * 0.001f;
			int num3 = (int)((float)Main.maxTilesX * num);
			int num4 = (int)((float)Main.maxTilesX * (1f - num));
			int num5 = 1;
			if (genRand.Next(2) == 0) {
				num4 = (int)((float)Main.maxTilesX * num);
				num3 = (int)((float)Main.maxTilesX * (1f - num));
				num5 = -1;
			}

			int num6 = 1;
			if (dungeonX < Main.maxTilesX / 2)
				num6 = -1;

			if (num6 < 0) {
				if (num4 < num3)
					num4 = (int)((float)Main.maxTilesX * num2);
				else
					num3 = (int)((float)Main.maxTilesX * num2);
			}
			else if (num4 > num3) {
				num4 = (int)((float)Main.maxTilesX * (1f - num2));
			}
			else {
				num3 = (int)((float)Main.maxTilesX * (1f - num2));
			}

			hardmodetasks.Add(new PassLegacy("Hardmode Good", delegate (GenerationProgress progress) {
				GERunner(num3, 0, 3 * num5, 5f, true);
			}));

			hardmodetasks.Add(new PassLegacy("Hardmode Evil", delegate (GenerationProgress progress) {
				GERunner(num4, 0, 3 * -(float)num5, 5f, false);
			}));

			hardmodetasks.Add(new PassLegacy("Hardmode Walls", delegate (GenerationProgress progress) {
			float num7 = (float)Main.maxTilesX / 4200f;
			int num8 = (int)(25f * num7);
			ShapeData shapeData = new ShapeData();
			int num9 = 0;
			while (num8 > 0) {
				if (++num9 % 15000 == 0)
					num8--;

				Point point = RandomWorldPoint((int)Main.worldSurface - 100, 1, 190, 1);
				Tile tile = Main.tile[point.X, point.Y];
				Tile tile2 = Main.tile[point.X, point.Y - 1];
				byte b = 0;
				if (TileID.Sets.Crimson[tile.type])
					b = (byte)(192 + genRand.Next(4));
				else if (TileID.Sets.Corrupt[tile.type])
					b = (byte)(188 + genRand.Next(4));
				else if (TileID.Sets.Hallow[tile.type])
					b = (byte)(200 + genRand.Next(4));

				if (tile.active() && b != 0 && !tile2.active()) {
					bool flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Modifiers.OnlyWalls(0, 54, 55, 56, 57, 58, 59, 61, 185, 212, 213, 214, 215, 196, 197, 198, 199, 15, 40, 71, 64, 204, 205, 206, 207, 208, 209, 210, 211, 71), new Actions.Blank().Output(shapeData)));
					if (shapeData.Count > 50 && flag) {
						WorldUtils.Gen(new Point(point.X, point.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), new Actions.PlaceWall(b));
						num8--;
					}

					shapeData.Clear();
				}
			}
			}));

			hardmodetasks.Add(new PassLegacy("Hardmode Announcment", delegate (GenerationProgress progress) {
			if (Main.netMode == 0)
				Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
			else if (Main.netMode == 2)
				NetMessage.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));

			// AchievementsHelper.NotifyProgressionEvent(9);
			}));

			WorldHooks.ModifyHardmodeTasks(hardmodetasks);
			foreach (GenPass task in hardmodetasks) {
				task.Apply(null);
			}

			if (Main.netMode == 2)
				Netplay.ResetSections();

			IsGeneratingHardMode = false;
		}

		public static bool PlaceDoor(int i, int j, int type, int style = 0) {
			int num = 54 * style;
			try {
				if (Main.tile[i, j - 2].nactive() && Main.tileSolid[Main.tile[i, j - 2].type] && SolidTile(i, j + 2)) {
					Main.tile[i, j - 1].active(active: true);
					Main.tile[i, j - 1].type = 10;
					Main.tile[i, j - 1].frameY = (short)num;
					Main.tile[i, j - 1].frameX = (short)(genRand.Next(3) * 18);
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 10;
					Main.tile[i, j].frameY = (short)(num + 18);
					Main.tile[i, j].frameX = (short)(genRand.Next(3) * 18);
					Main.tile[i, j + 1].active(active: true);
					Main.tile[i, j + 1].type = 10;
					Main.tile[i, j + 1].frameY = (short)(num + 36);
					Main.tile[i, j + 1].frameX = (short)(genRand.Next(3) * 18);
					return true;
				}

				return false;
			}
			catch {
				return false;
			}
		}

		public static bool CloseDoor(int i, int j, bool forced = false) {
			int num = 0;
			int num2 = i;
			int num3 = j;
			if (Main.tile[i, j] == null)
				Main.tile[i, j] = new Tile();

			int frameX = Main.tile[i, j].frameX;
			Tile tile = Main.tile[i, j];
			if (TileLoader.CloseDoorID(Main.tile[i, j]) < 0)
				return false;

			int num4 = tile.frameY;
			int num5 = 0;
			int num6 = 0;
			while (num4 >= 54) {
				num4 -= 54;
				num5++;
			}

			if (frameX >= 72) {
				num5 += 36 * (frameX / 72);
				num6 += 54 * (frameX / 72);
			}

			num3 = j - num4 / 18;
			switch (frameX % 72) {
				case 0:
					num2 = i;
					num = 1;
					break;
				case 18:
					num2 = i - 1;
					num = 1;
					break;
				case 36:
					num2 = i + 1;
					num = -1;
					break;
				case 54:
					num2 = i;
					num = -1;
					break;
			}

			int num7 = num2;
			if (num == -1)
				num7 = num2 - 1;

			if (!forced) {
				for (int k = num3; k < num3 + 3; k++) {
					if (!Collision.EmptyTile(num2, k, ignoreTiles: true))
						return false;
				}
			}

			ushort closeDoorID = (ushort)TileLoader.CloseDoorID(tile);
			for (int l = num7; l < num7 + 2; l++) {
				for (int m = num3; m < num3 + 3; m++) {
					if (l == num2) {
						if (Main.tile[l, m] == null)
							Main.tile[l, m] = new Tile();

						Main.tile[l, m].type = closeDoorID;
						Main.tile[l, m].frameX = (short)(genRand.Next(3) * 18 + num6);
					}
					else {
						if (Main.tile[l, m] == null)
							Main.tile[l, m] = new Tile();

						Main.tile[l, m].active(active: false);
					}
				}
			}

			if (Main.netMode != 1 && Wiring.running) {
				Wiring.SkipWire(num2, num3);
				Wiring.SkipWire(num2, num3 + 1);
				Wiring.SkipWire(num2, num3 + 2);
			}

			for (int n = num2 - 1; n <= num2 + 1; n++) {
				for (int num8 = num3 - 1; num8 <= num3 + 2; num8++) {
					TileFrame(n, num8);
				}
			}

			Main.PlaySound(9, i * 16, j * 16);
			return true;
		}

		public static bool AddLifeCrystal(int i, int j) {
			for (int k = j; k < Main.maxTilesY; k++) {
				if (Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type]) {
					int num = k - 1;
					if (Main.tile[i, num - 1].lava() || Main.tile[i - 1, num - 1].lava())
						return false;

					if (!EmptyTileCheck(i - 1, i, num - 1, num))
						return false;

					if (Main.wallDungeon[Main.tile[i, num].wall])
						return false;

					Tile tile = Main.tile[i - 1, num + 1];
					Tile tile2 = Main.tile[i, num + 1];
					if (!tile.nactive() || !Main.tileSolid[tile.type])
						return false;

					if (!tile2.nactive() || !Main.tileSolid[tile2.type])
						return false;

					if (tile.blockType() != 0) {
						tile.slope(0);
						tile.halfBrick(halfBrick: false);
					}

					if (tile2.blockType() != 0) {
						tile2.slope(0);
						tile2.halfBrick(halfBrick: false);
					}

					Main.tile[i - 1, num - 1].active(active: true);
					Main.tile[i - 1, num - 1].type = 12;
					Main.tile[i - 1, num - 1].frameX = 0;
					Main.tile[i - 1, num - 1].frameY = 0;
					Main.tile[i, num - 1].active(active: true);
					Main.tile[i, num - 1].type = 12;
					Main.tile[i, num - 1].frameX = 18;
					Main.tile[i, num - 1].frameY = 0;
					Main.tile[i - 1, num].active(active: true);
					Main.tile[i - 1, num].type = 12;
					Main.tile[i - 1, num].frameX = 0;
					Main.tile[i - 1, num].frameY = 18;
					Main.tile[i, num].active(active: true);
					Main.tile[i, num].type = 12;
					Main.tile[i, num].frameX = 18;
					Main.tile[i, num].frameY = 18;
					return true;
				}
			}

			return false;
		}

		public static void AddShadowOrb(int x, int y, bool shadowOrb) {
			if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesY - 10)
				return;

			for (int i = x - 1; i < x + 1; i++) {
				for (int j = y - 1; j < y + 1; j++) {
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 31)
						return;
				}
			}

			short num = 0;
			if (!shadowOrb)
				num = (short)(num + 36);

			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].type = 31;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].type = 31;
			Main.tile[x, y - 1].frameX = (short)(18 + num);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].type = 31;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].type = 31;
			Main.tile[x, y].frameX = (short)(18 + num);
			Main.tile[x, y].frameY = 18;
		}

		public static void AddHellHouses() {
			int num = (int)((double)Main.maxTilesX * 0.25);
			for (int i = num; i < Main.maxTilesX - num; i++) {
				int num2 = Main.maxTilesY - 40;
				while (Main.tile[i, num2].active() || Main.tile[i, num2].liquid > 0) {
					num2--;
				}

				if (Main.tile[i, num2 + 1].active()) {
					ushort num3 = (ushort)genRand.Next(75, 77);
					byte wallType = 13;
					if (genRand.Next(5) > 0)
						num3 = 75;

					if (num3 == 75)
						wallType = 14;

					HellFort(i, num2, num3, wallType);
					i += (int)(genRand.Next(30, 130) / Main.setting.UnderworldHouseMult);
					if (genRand.Next(10) == 0)
						i += (int)(WorldGen.genRand.Next(0, 200) / Main.setting.UnderworldHouseMult);
				}
			}
			float num4 = ((float)Main.maxTilesX / 4200);
			for (int j = 0; (float)j < 200f * num4; j++) {
				int num5 = 0;
				bool flag = false;
				while (!flag) {
					num5++;
					int num6 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
					int num7 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 20);
					if (Main.tile[num6, num7].active() && (Main.tile[num6, num7].type == 75 || Main.tile[num6, num7].type == 76)) {
						int num8 = 0;
						if (Main.tile[num6 - 1, num7].wall > 0)
							num8 = -1;
						else if (Main.tile[num6 + 1, num7].wall > 0)
							num8 = 1;

						if (!Main.tile[num6 + num8, num7].active() && !Main.tile[num6 + num8, num7 + 1].active()) {
							bool flag2 = false;
							for (int k = num6 - 8; k < num6 + 8; k++) {
								for (int l = num7 - 8; l < num7 + 8; l++) {
									if (Main.tile[k, l].active() && TileLoader.IsTorch(Main.tile[k, l].type)) {
										flag2 = true;
										break;
									}
								}
							}

							if (!flag2) {
								PlaceTile(num6 + num8, num7, 4, mute: true, forced: true, -1, 7);
								flag = true;
							}
						}
					}

					if (num5 > 1000)
						flag = true;
				}
			}

			float num9 = 4200000f / (float)Main.maxTilesX;
			for (int m = 0; (float)m < num9; m++) {
				int num10 = genRand.Next(num, Main.maxTilesX - num);
				int n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				while ((Main.tile[num10, n].wall != 13 && Main.tile[num10, n].wall != 14) || Main.tile[num10, n].active()) {
					num10 = genRand.Next(num, Main.maxTilesX - num);
					n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				}

				if ((Main.tile[num10, n].wall != 13 && Main.tile[num10, n].wall != 14) || Main.tile[num10, n].active())
					continue;

				for (; !SolidTile(num10, n) && n < Main.maxTilesY - 20; n++) {
				}

				n--;
				int num11 = num10;
				int num12 = num10;
				while (!Main.tile[num11, n].active() && SolidTile(num11, n + 1)) {
					num11--;
				}

				num11++;
				for (; !Main.tile[num12, n].active() && SolidTile(num12, n + 1); num12++) {
				}

				num12--;
				int num13 = num12 - num11;
				int num14 = (num12 + num11) / 2;
				if (Main.tile[num14, n].active() || (Main.tile[num14, n].wall != 13 && Main.tile[num14, n].wall != 14) || !SolidTile(num14, n + 1))
					continue;

				int style = 16;
				int style2 = 13;
				int style3 = 14;
				int style4 = 49;
				int style5 = 4;
				int style6 = 8;
				int style7 = 15;
				int style8 = 9;
				int style9 = 10;
				int style10 = 17;
				int style11 = 25;
				int style12 = 25;
				int style13 = 23;
				int style14 = 25;
				int num15 = genRand.Next(13);
				int num16 = 0;
				int num17 = 0;
				if (num15 == 0) {
					num16 = 5;
					num17 = 4;
				}

				if (num15 == 1) {
					num16 = 4;
					num17 = 3;
				}

				if (num15 == 2) {
					num16 = 3;
					num17 = 5;
				}

				if (num15 == 3) {
					num16 = 4;
					num17 = 6;
				}

				if (num15 == 4) {
					num16 = 3;
					num17 = 3;
				}

				if (num15 == 5) {
					num16 = 5;
					num17 = 3;
				}

				if (num15 == 6) {
					num16 = 5;
					num17 = 4;
				}

				if (num15 == 7) {
					num16 = 5;
					num17 = 4;
				}

				if (num15 == 8) {
					num16 = 5;
					num17 = 4;
				}

				if (num15 == 9) {
					num16 = 3;
					num17 = 5;
				}

				if (num15 == 10) {
					num16 = 5;
					num17 = 3;
				}

				if (num15 == 11) {
					num16 = 2;
					num17 = 4;
				}

				if (num15 == 12) {
					num16 = 3;
					num17 = 3;
				}

				for (int num18 = num14 - num16; num18 <= num14 + num16; num18++) {
					for (int num19 = n - num17; num19 <= n; num19++) {
						if (Main.tile[num18, num19].active()) {
							num15 = -1;
							break;
						}
					}
				}

				if ((double)num13 < (double)num16 * 1.75)
					num15 = -1;

				switch (num15) {
					case 0: {
							PlaceTile(num14, n, 14, mute: true, forced: false, -1, style2);
							int num21 = genRand.Next(6);
							if (num21 < 3)
								PlaceTile(num14 + num21, n - 2, 33, mute: true, forced: false, -1, style12);

							if (!Main.tile[num14, n].active())
								break;

							if (!Main.tile[num14 - 2, n].active()) {
								PlaceTile(num14 - 2, n, 15, mute: true, forced: false, -1, style);
								if (Main.tile[num14 - 2, n].active()) {
									Main.tile[num14 - 2, n].frameX += 18;
									Main.tile[num14 - 2, n - 1].frameX += 18;
								}
							}

							if (!Main.tile[num14 + 2, n].active())
								PlaceTile(num14 + 2, n, 15, mute: true, forced: false, -1, style);

							break;
						}
					case 1: {
							PlaceTile(num14, n, 18, mute: true, forced: false, -1, style3);
							int num20 = genRand.Next(4);
							if (num20 < 2)
								PlaceTile(num14 + num20, n - 1, 33, mute: true, forced: false, -1, style12);

							if (!Main.tile[num14, n].active())
								break;

							if (genRand.Next(2) == 0) {
								if (!Main.tile[num14 - 1, n].active()) {
									PlaceTile(num14 - 1, n, 15, mute: true, forced: false, -1, style);
									if (Main.tile[num14 - 1, n].active()) {
										Main.tile[num14 - 1, n].frameX += 18;
										Main.tile[num14 - 1, n - 1].frameX += 18;
									}
								}
							}
							else if (!Main.tile[num14 + 2, n].active()) {
								PlaceTile(num14 + 2, n, 15, mute: true, forced: false, -1, style);
							}

							break;
						}
					case 2:
						PlaceTile(num14, n, 105, mute: true, forced: false, -1, style4);
						break;
					case 3:
						PlaceTile(num14, n, 101, mute: true, forced: false, -1, style5);
						break;
					case 4:
						if (genRand.Next(2) == 0) {
							PlaceTile(num14, n, 15, mute: true, forced: false, -1, style);
							Main.tile[num14, n].frameX += 18;
							Main.tile[num14, n - 1].frameX += 18;
						}
						else {
							PlaceTile(num14, n, 15, mute: true, forced: false, -1, style);
						}
						break;
					case 5:
						if (genRand.Next(2) == 0)
							Place4x2(num14, n, 79, 1, style6);
						else
							Place4x2(num14, n, 79, -1, style6);
						break;
					case 6:
						PlaceTile(num14, n, 87, mute: true, forced: false, -1, style7);
						break;
					case 7:
						PlaceTile(num14, n, 88, mute: true, forced: false, -1, style8);
						break;
					case 8:
						PlaceTile(num14, n, 89, mute: true, forced: false, -1, style9);
						break;
					case 9:
						PlaceTile(num14, n, 104, mute: true, forced: false, -1, style10);
						break;
					case 10:
						if (genRand.Next(2) == 0)
							Place4x2(num14, n, 90, 1, style14);
						else
							Place4x2(num14, n, 90, -1, style14);
						break;
					case 11:
						PlaceTile(num14, n, 93, mute: true, forced: false, -1, style13);
						break;
					case 12:
						PlaceTile(num14, n, 100, mute: true, forced: false, -1, style11);
						break;
				}
			}

			num9 = 420000f / (float)Main.maxTilesX;
			for (int num22 = 0; (float)num22 < num9; num22++) {
				int num23 = genRand.Next(num, Main.maxTilesX - num);
				int num24 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				while ((Main.tile[num23, num24].wall != 13 && Main.tile[num23, num24].wall != 14) || Main.tile[num23, num24].active()) {
					num23 = genRand.Next(num, Main.maxTilesX - num);
					num24 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				}

				int num25 = num23;
				int num26 = num23;
				int num27 = num24;
				int num28 = num24;
				int num29 = 0;
				for (int num30 = 0; num30 < 2; num30++) {
					num25 = num23;
					num26 = num23;
					while (!Main.tile[num25, num24].active() && (Main.tile[num25, num24].wall == 13 || Main.tile[num25, num24].wall == 14)) {
						num25--;
					}

					num25++;
					for (; !Main.tile[num26, num24].active() && (Main.tile[num26, num24].wall == 13 || Main.tile[num26, num24].wall == 14); num26++) {
					}

					num26--;
					num23 = (num25 + num26) / 2;
					num27 = num24;
					num28 = num24;
					while (!Main.tile[num23, num27].active() && (Main.tile[num23, num27].wall == 13 || Main.tile[num23, num27].wall == 14)) {
						num27--;
					}

					num27++;
					for (; !Main.tile[num23, num28].active() && (Main.tile[num23, num28].wall == 13 || Main.tile[num23, num28].wall == 14); num28++) {
					}

					num28--;
					num24 = (num27 + num28) / 2;
				}

				num25 = num23;
				num26 = num23;
				while (!Main.tile[num25, num24].active() && !Main.tile[num25, num24 - 1].active() && !Main.tile[num25, num24 + 1].active()) {
					num25--;
				}

				num25++;
				for (; !Main.tile[num26, num24].active() && !Main.tile[num26, num24 - 1].active() && !Main.tile[num26, num24 + 1].active(); num26++) {
				}

				num26--;
				num27 = num24;
				num28 = num24;
				while (!Main.tile[num23, num27].active() && !Main.tile[num23 - 1, num27].active() && !Main.tile[num23 + 1, num27].active()) {
					num27--;
				}

				num27++;
				for (; !Main.tile[num23, num28].active() && !Main.tile[num23 - 1, num28].active() && !Main.tile[num23 + 1, num28].active(); num28++) {
				}

				num28--;
				num23 = (num25 + num26) / 2;
				num24 = (num27 + num28) / 2;
				int num31 = num26 - num25;
				num29 = num28 - num27;
				if (num31 <= 7 || num29 <= 5)
					continue;

				int num32 = 0;
				if (nearPicture2(num23, num24))
					num32 = -1;

				if (num32 == 0) {
					Vector2 vector = randHellPicture();
					int type = (int)vector.X;
					int style15 = (int)vector.Y;
					if (!nearPicture(num23, num24))
						PlaceTile(num23, num24, type, mute: true, forced: false, -1, style15);
				}
			}

			int[] array = new int[3] {
				genRand.Next(16, 22),
				genRand.Next(16, 22),
				genRand.Next(16, 22)
			};

			while (array[1] == array[0]) {
				array[1] = genRand.Next(16, 22);
			}

			while (array[2] == array[0] || array[2] == array[1]) {
				array[2] = genRand.Next(16, 22);
			}

			num9 = 420000f / (float)Main.maxTilesX;
			for (int num33 = 0; (float)num33 < num9; num33++) {
				int num34;
				int num35;
				do {
					num34 = genRand.Next(num, Main.maxTilesX - num);
					num35 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				} while ((Main.tile[num34, num35].wall != 13 && Main.tile[num34, num35].wall != 14) || Main.tile[num34, num35].active());

				while (!SolidTile(num34, num35) && num35 > 10) {
					num35--;
				}

				num35++;
				if (Main.tile[num34, num35].wall != 13 && Main.tile[num34, num35].wall != 14)
					continue;

				int num36 = genRand.Next(3);
				int style16 = 32;
				int style17 = 32;
				int num37;
				int num38;
				switch (num36) {
					default:
						num37 = 1;
						num38 = 3;
						break;
					case 1:
						num37 = 3;
						num38 = 3;
						break;
					case 2:
						num37 = 1;
						num38 = 2;
						break;
				}

				for (int num39 = num34 - 1; num39 <= num34 + num37; num39++) {
					for (int num40 = num35; num40 <= num35 + num38; num40++) {
						Tile tile = Main.tile[num34, num35];
						if (num39 < num34 || num39 == num34 + num37) {
							if (tile.active()) {
								switch (tile.type) {
									case 10:
									case 11:
									case 34:
									case 42:
									case 91:
										num36 = -1;
										break;
								}
							}
						}
						else if (tile.active()) {
							num36 = -1;
						}
					}
				}

				switch (num36) {
					case 0:
						PlaceTile(num34, num35, 91, mute: true, forced: false, -1, array[genRand.Next(3)]);
						break;
					case 1:
						PlaceTile(num34, num35, 34, mute: true, forced: false, -1, style16);
						break;
					case 2:
						PlaceTile(num34, num35, 42, mute: true, forced: false, -1, style17);
						break;
				}
			}
		}

		public static void HellFort(int i, int j, ushort tileType = 75, byte wallType = 14) {
			int[] array = new int[5];
			int[] array2 = new int[5];
			int[] array3 = new int[10];
			int[] array4 = new int[10];
			int num = 8;
			int num2 = 20;
			array[2] = i - genRand.Next(num / 2, num2 / 2);
			array2[2] = i + genRand.Next(num / 2, num2 / 2);
			array[3] = array2[2];
			array2[3] = array[3] + genRand.Next(num, num2);
			array[4] = array2[3];
			array2[4] = array[4] + genRand.Next(num, num2);
			array2[1] = array[2];
			array[1] = array2[1] - genRand.Next(num, num2);
			array2[0] = array[1];
			array[0] = array2[0] - genRand.Next(num, num2);
			num = 6;
			num2 = 12;
			array3[3] = j - genRand.Next(num, num2);
			array4[3] = j;
			for (int k = 4; k < 10; k++) {
				array3[k] = array4[k - 1];
				array4[k] = array3[k] + genRand.Next(num, num2);
			}

			for (int num3 = 2; num3 >= 0; num3--) {
				array4[num3] = array3[num3 + 1];
				array3[num3] = array4[num3] - genRand.Next(num, num2);
			}

			bool flag = false;
			bool flag2 = false;
			bool[,] array5 = new bool[5, 10];
			int num4 = 3;
			int num5 = 3;
			for (int l = 0; l < 2; l++) {
				if (genRand.Next(3) == 0) {
					flag = true;
					int num6 = genRand.Next(10);
					if (num6 < num4)
						num4 = num6;

					if (num6 > num5)
						num5 = num6;

					int num7 = 1;
					if (genRand.Next(2) == 0) {
						array5[0, num6] = true;
						array5[1, num6] = true;
						num7 = 0;
					}
					else {
						array5[1, num6] = true;
					}

					int num8 = genRand.Next(2);
					if (num8 == 0)
						num8 = -1;

					int num9 = genRand.Next(10);
					while (num9 > 0 && num6 >= 0 && num6 < 10) {
						array5[num7, num6] = true;
						num6 += num8;
					}
				}

				if (genRand.Next(3) == 0) {
					flag2 = true;
					int num10 = genRand.Next(10);
					if (num10 < num4)
						num4 = num10;

					if (num10 > num5)
						num5 = num10;

					int num11 = 3;
					if (genRand.Next(2) == 0) {
						array5[3, num10] = true;
						array5[4, num10] = true;
						num11 = 4;
					}
					else {
						array5[3, num10] = true;
					}

					int num12 = genRand.Next(2);
					if (num12 == 0)
						num12 = -1;

					int num13 = genRand.Next(10);
					while (num13 > 0 && num10 >= 0 && num10 < 10) {
						array5[num11, num10] = true;
						num10 += num12;
					}
				}
			}

			for (int m = 0; m < 5; m++) {
				int num14 = array[m];
				bool flag3 = false;
				for (int n = Main.maxTilesY - 200; n < Main.maxTilesY; n++) {
					if (Main.tile[num14, n].wall > 0)
						flag3 = true;
				}

				if (flag3) {
					for (int num15 = 0; num15 < 10; num15++) {
						array5[m, num15] = false;
					}
				}
			}

			int num16 = genRand.Next(10);
			if (num16 < num4)
				num4 = num16;

			num16 = genRand.Next(10);
			if (num16 > num5)
				num5 = num16;

			if (!flag && !flag2) {
				while (num5 - num4 < 5) {
					num16 = genRand.Next(10);
					if (num16 < num4)
						num4 = num16;

					num16 = genRand.Next(10);
					if (num16 > num5)
						num5 = num16;
				}
			}

			for (int num17 = num4; num17 <= num5; num17++) {
				array5[2, num17] = true;
			}

			for (int num18 = 0; num18 < 5; num18++) {
				for (int num19 = 0; num19 < 10; num19++) {
					if (array5[num18, num19] && (array3[num19] < Main.maxTilesY - 200 || array4[num19] > Main.maxTilesY - 20))
						array5[num18, num19] = false;
				}
			}

			for (int num20 = 0; num20 < 5; num20++) {
				for (int num21 = 0; num21 < 10; num21++) {
					if (!array5[num20, num21])
						continue;

					for (int num22 = array[num20]; num22 <= array2[num20]; num22++) {
						for (int num23 = array3[num21]; num23 <= array4[num21]; num23++) {
							Main.tile[num22, num23].liquid = 0;
							if (num22 == array[num20] || num22 == array2[num20] || num23 == array3[num21] || num23 == array4[num21]) {
								Main.tile[num22, num23].active(active: true);
								Main.tile[num22, num23].type = tileType;
								Main.tile[num22, num23].halfBrick(halfBrick: false);
								Main.tile[num22, num23].slope(0);
							}
							else {
								Main.tile[num22, num23].wall = wallType;
								Main.tile[num22, num23].active(active: false);
							}
						}
					}
				}
			}

			int style = 19;
			int style2 = 13;
			for (int num24 = 0; num24 < 4; num24++) {
				bool[] array6 = new bool[10];
				bool flag4 = false;
				for (int num25 = 0; num25 < 10; num25++) {
					if (array5[num24, num25] && array5[num24 + 1, num25]) {
						array6[num25] = true;
						flag4 = true;
					}
				}

				while (flag4) {
					int num26 = genRand.Next(10);
					if (array6[num26]) {
						flag4 = false;
						Main.tile[array2[num24], array4[num26] - 1].active(active: false);
						Main.tile[array2[num24], array4[num26] - 2].active(active: false);
						Main.tile[array2[num24], array4[num26] - 3].active(active: false);
						Main.tile[array2[num24], array4[num26] - 1].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 2].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 3].wall = wallType;
						PlaceTile(array2[num24], array4[num26] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
			}

			for (int num27 = 0; num27 < 5; num27++) {
				for (int num28 = 0; num28 < 10; num28++) {
					if (!array5[num27, num28])
						continue;

					if (num28 > 0 && array5[num27, num28 - 1]) {
						int num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						int num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						while (num30 - num29 < 2 || num30 - num29 > 5) {
							num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
							num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						}

						for (int num31 = num29; num31 <= num30; num31++) {
							Main.tile[num31, array3[num28]].active(active: false);
							PlaceTile(num31, array3[num28], 19, mute: true, forced: true, -1, style2);
							Main.tile[num31, array3[num28]].wall = wallType;
						}
					}

					if (num27 < 4 && array5[num27 + 1, num28] && genRand.Next(3) == 0) {
						Main.tile[array2[num27], array4[num28] - 1].active(active: false);
						Main.tile[array2[num27], array4[num28] - 2].active(active: false);
						Main.tile[array2[num27], array4[num28] - 3].active(active: false);
						Main.tile[array2[num27], array4[num28] - 1].wall = wallType;
						Main.tile[array2[num27], array4[num28] - 2].wall = wallType;
						Main.tile[array2[num27], array4[num28] - 3].wall = wallType;
						PlaceTile(array2[num27], array4[num28] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
			}

			bool flag5 = false;
			for (int num32 = 0; num32 < 5; num32++) {
				bool[] array7 = new bool[10];
				for (int num33 = 0; num33 < 10; num33++) {
					if (array5[num32, num33]) {
						flag5 = true;
						array7[num33] = true;
					}
				}

				if (!flag5)
					continue;

				bool flag6 = false;
				for (int num34 = 0; num34 < 10; num34++) {
					if (array7[num34]) {
						if (!Main.tile[array[num32] - 1, array4[num34] - 1].active() && !Main.tile[array[num32] - 1, array4[num34] - 2].active() && !Main.tile[array[num32] - 1, array4[num34] - 3].active() && Main.tile[array[num32] - 1, array4[num34] - 1].liquid == 0 && Main.tile[array[num32] - 1, array4[num34] - 2].liquid == 0 && Main.tile[array[num32] - 1, array4[num34] - 3].liquid == 0)
							flag6 = true;
						else
							array7[num34] = false;
					}
				}

				while (flag6) {
					int num35 = genRand.Next(10);
					if (array7[num35]) {
						flag6 = false;
						Main.tile[array[num32], array4[num35] - 1].active(active: false);
						Main.tile[array[num32], array4[num35] - 2].active(active: false);
						Main.tile[array[num32], array4[num35] - 3].active(active: false);
						PlaceTile(array[num32], array4[num35] - 1, 10, mute: true, forced: false, -1, style);
					}
				}

				break;
			}

			bool flag7 = false;
			for (int num36 = 4; num36 >= 0; num36--) {
				bool[] array8 = new bool[10];
				for (int num37 = 0; num37 < 10; num37++) {
					if (array5[num36, num37]) {
						flag7 = true;
						array8[num37] = true;
					}
				}

				if (flag7) {
					bool flag8 = false;
					for (int num38 = 0; num38 < 10; num38++) {
						if (array8[num38]) {
							if (!Main.tile[array2[num36] + 1, array4[num38] - 1].active() && !Main.tile[array2[num36] + 1, array4[num38] - 2].active() && !Main.tile[array2[num36] + 1, array4[num38] - 3].active() && Main.tile[array2[num36] + 1, array4[num38] - 1].liquid == 0 && Main.tile[array2[num36] + 1, array4[num38] - 2].liquid == 0 && Main.tile[array2[num36] + 1, array4[num38] - 3].liquid == 0)
								flag8 = true;
							else
								array8[num38] = false;
						}
					}

					while (flag8) {
						int num39 = genRand.Next(10);
						if (array8[num39]) {
							flag8 = false;
							Main.tile[array2[num36], array4[num39] - 1].active(active: false);
							Main.tile[array2[num36], array4[num39] - 2].active(active: false);
							Main.tile[array2[num36], array4[num39] - 3].active(active: false);
							PlaceTile(array2[num36], array4[num39] - 1, 10, mute: true, forced: false, -1, style);
						}
					}

					break;
				}
			}

			bool flag9 = false;
			int num40 = 0;
			bool[] array9;
			while (true) {
				if (num40 >= 10)
					return;

				array9 = new bool[10];
				for (int num41 = 0; num41 < 5; num41++) {
					if (array5[num41, num40]) {
						flag9 = true;
						array9[num41] = true;
					}
				}

				if (flag9)
					break;

				num40++;
			}

			bool flag10 = true;
			while (flag10) {
				int num42 = genRand.Next(5);
				if (!array9[num42])
					continue;

				int num43 = genRand.Next(array[num42] + 2, array2[num42] - 1);
				int num44 = genRand.Next(array[num42] + 2, array2[num42] - 1);
				while (num44 - num43 < 2 || num44 - num43 > 5) {
					num43 = genRand.Next(array[num42] + 2, array2[num42] - 1);
					num44 = genRand.Next(array[num42] + 2, array2[num42] - 1);
				}

				for (int num45 = num43; num45 <= num44; num45++) {
					if (Main.tile[num45, array3[num40] - 1].active() || Main.tile[num45, array3[num40] - 1].liquid > 0)
						flag10 = false;
				}

				if (flag10) {
					for (int num46 = num43; num46 <= num44; num46++) {
						Main.tile[num46, array3[num40]].active(active: false);
						PlaceTile(num46, array3[num40], 19, mute: true, forced: true, -1, style2);
					}
				}

				flag10 = false;
			}
		}

		public static void HellHouse(int i, int j, byte type = 76, byte wall = 13) {
			int num = genRand.Next(8, 20);
			int num2 = genRand.Next(1, 3);
			int num3 = genRand.Next(4, 13);
			int num4 = j;
			for (int k = 0; k < num2; k++) {
				int num5 = genRand.Next(5, 9);
				HellRoom(i, num4, num, num5, type, wall);
				num4 -= num5;
			}

			num4 = j;
			for (int l = 0; l < num3; l++) {
				int num6 = genRand.Next(5, 9);
				num4 += num6;
				HellRoom(i, num4, num, num6, type, wall);
			}

			for (int m = i - num / 2; m <= i + num / 2; m++) {
				for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[m, num4].active() && (Main.tile[m, num4].type == 76 || Main.tile[m, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++) {
				}

				int num7 = 6 + genRand.Next(3);
				while (num4 < Main.maxTilesY && !Main.tile[m, num4].active()) {
					num7--;
					Main.tile[m, num4].active(active: true);
					Main.tile[m, num4].type = 57;
					num4++;
					if (num7 <= 0)
						break;
				}
			}

			int num8 = 0;
			int num9 = 0;
			for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++) {
			}

			num4--;
			num9 = num4;
			while ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14) {
				num4--;
				if (!Main.tile[i, num4].active() || (Main.tile[i, num4].type != 76 && Main.tile[i, num4].type != 75))
					continue;

				int num10 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
				int num11 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
				if (num10 > num11) {
					int num12 = num10;
					num10 = num11;
					num11 = num12;
				}

				if (num10 == num11) {
					if (num10 < i)
						num11++;
					else
						num10--;
				}

				for (int n = num10; n <= num11; n++) {
					if (Main.tile[n, num4 - 1].wall == 13)
						Main.tile[n, num4].wall = 13;

					if (Main.tile[n, num4 - 1].wall == 14)
						Main.tile[n, num4].wall = 14;

					Main.tile[n, num4].type = 19;
					Main.tile[n, num4].active(active: true);
				}

				num4--;
			}

			num8 = num4;
			float num13 = (float)((num9 - num8) * num) * 0.02f;
			for (int num14 = 0; (float)num14 < num13; num14++) {
				int num15 = genRand.Next(i - num / 2, i + num / 2 + 1);
				int num16 = genRand.Next(num8, num9);
				int num17 = genRand.Next(3, 8);
				for (int num18 = num15 - num17; num18 <= num15 + num17; num18++) {
					for (int num19 = num16 - num17; num19 <= num16 + num17; num19++) {
						float num20 = Math.Abs(num18 - num15);
						float num21 = Math.Abs(num19 - num16);
						if (!(Math.Sqrt(num20 * num20 + num21 * num21) < (double)num17 * 0.4))
							continue;

						try {
							if (Main.tile[num18, num19].type == 76 || Main.tile[num18, num19].type == 19)
								Main.tile[num18, num19].active(active: false);

							Main.tile[num18, num19].wall = 0;
						}
						catch {
						}
					}
				}
			}
		}

		public static void HellRoom(int i, int j, int width, int height, byte type = 76, byte wall = 13) {
			if (j > Main.maxTilesY - 40)
				return;

			for (int k = i - width / 2; k <= i + width / 2; k++) {
				for (int l = j - height; l <= j; l++) {
					try {
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = type;
						Main.tile[k, l].liquid = 0;
						Main.tile[k, l].lava(lava: false);
					}
					catch {
					}
				}
			}

			for (int m = i - width / 2 + 1; m <= i + width / 2 - 1; m++) {
				for (int n = j - height + 1; n <= j - 1; n++) {
					try {
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = wall;
						Main.tile[m, n].liquid = 0;
						Main.tile[m, n].lava(lava: false);
					}
					catch {
					}
				}
			}
		}

		public static void templeCleaner(int x, int y) {
			int num = 0;
			if (Main.tile[x + 1, y].active() && Main.tile[x + 1, y].type == 226)
				num++;

			if (Main.tile[x - 1, y].active() && Main.tile[x - 1, y].type == 226)
				num++;

			if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == 226)
				num++;

			if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type == 226)
				num++;

			if (Main.tile[x, y].active() && Main.tile[x, y].type == 226) {
				if (num <= 1) {
					Main.tile[x, y].active(active: false);
					Main.tile[x, y].wall = 87;
				}
			}
			else if (!Main.tile[x, y].active() && num == 3) {
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].type = 226;
				Main.tile[x, y].liquid = 0;
				Main.tile[x, y].slope(0);
				Main.tile[x, y].halfBrick(halfBrick: false);
			}
		}

		public static Vector2 templePather(Vector2 templePath, int destX, int destY) {
			int num = (int)templePath.X;
			int num2 = (int)templePath.Y;
			int num3 = genRand.Next(5, 20);
			int num4 = genRand.Next(2, 5);
			while (num3 > 0 && (num != destX || num2 != destY)) {
				num3--;
				if (num > destX)
					num--;

				if (num < destX)
					num++;

				if (num2 > destY)
					num2--;

				if (num2 < destY)
					num2++;

				for (int i = num - num4; i < num + num4; i++) {
					for (int j = num2 - num4; j < num2 + num4; j++) {
						Main.tile[i, j].active(active: false);
						Main.tile[i, j].wall = 87;
					}
				}
			}

			return new Vector2(num, num2);
		}

		public static void outerTempled(int x, int y) {
			if ((Main.tile[x, y].active() & (Main.tile[x, y].type == 226)) || Main.tile[x, y].wall == 87)
				return;

			int num = 6;
			for (int i = x - num; i <= x + num; i++) {
				for (int j = y - num; j <= y + num; j++) {
					if (!Main.tile[i, j].active() && Main.tile[i, j].wall == 87) {
						i = x;
						j = y;
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 226;
						Main.tile[i, j].liquid = 0;
						Main.tile[i, j].slope(0);
						Main.tile[i, j].halfBrick(halfBrick: false);
						return;
					}
				}
			}
		}

		public static void makeTemple(int x, int y) {
			Rectangle[] array = new Rectangle[400]; // 40 to 400
			float num = Main.maxTilesX / 4200f;
			num *= Main.setting.TempleSizeMultiplier;
			int num2 = genRand.Next((int)(num * 10f), (int)(num * 16f));
			int num3 = 1;
			if (genRand.Next(2) == 0)
				num3 = -1;

			int num4 = num3;
			int num5 = x;
			int num6 = y;
			int num7 = x;
			int num8 = y;
			int num9 = genRand.Next(1, 3);
			int num10 = 0;
			for (int i = 0; i < num2; i++) {
				num10++;
				int num11 = num3;
				int num12 = num7;
				int num13 = num8;
				bool flag = true;
				int num14 = 0;
				int num15 = 0;
				int num16 = -10;
				Rectangle rectangle = new Rectangle(num12 - num14 / 2, num13 - num15 / 2, num14, num15);
				while (flag) {
					num12 = num7;
					num13 = num8;
					num14 = genRand.Next(25, 50);
					num15 = genRand.Next(20, 35);
					if (num15 > num14)
						num15 = num14;

					if (i == num2 - 1) {
						num14 = genRand.Next(55, 65);
						num15 = genRand.Next(45, 50);
						if (num15 > num14)
							num15 = num14;

						num14 = (int)((double)(float)num14 * 1.6);
						num15 = (int)((double)(float)num15 * 1.35);
						num13 += genRand.Next(5, 10);
					}

					if (num10 > num9) {
						num13 += genRand.Next(num15 + 1, num15 + 3) + num16;
						num12 += genRand.Next(-5, 6);
						num11 = num3 * -1;
					}
					else {
						num12 += (genRand.Next(num14 + 1, num14 + 3) + num16) * num11;
						num13 += genRand.Next(-5, 6);
					}

					flag = false;
					rectangle = new Rectangle(num12 - num14 / 2, num13 - num15 / 2, num14, num15);
					for (int j = 0; j < i; j++) {
						if (rectangle.Intersects(array[j]))
							flag = true;

						if (genRand.Next(100) == 0)
							num16++;
					}
				}

				if (num10 > num9) {
					num9++;
					num10 = 1;
				}

				array[i] = rectangle;
				num3 = num11;
				num7 = num12;
				num8 = num13;
			}

			for (int k = 0; k < num2; k++) {
				for (int l = 0; l < 2; l++) {
					for (int m = 0; m < num2; m++) {
						for (int n = 0; n < 2; n++) {
							int num17 = array[k].X;
							if (l == 1)
								num17 += array[k].Width - 1;

							int num18 = array[k].Y;
							int num19 = num18 + array[k].Height;
							int num20 = array[m].X;
							if (n == 1)
								num20 += array[m].Width - 1;

							int y2 = array[m].Y;
							int num21 = y2 + array[m].Height;
							while (num17 != num20 || num18 != y2 || num19 != num21) {
								if (num17 < num20)
									num17++;

								if (num17 > num20)
									num17--;

								if (num18 < y2)
									num18++;

								if (num18 > y2)
									num18--;

								if (num19 < num21)
									num19++;

								if (num19 > num21)
									num19--;

								int num22 = num17;
								for (int num23 = num18; num23 < num19; num23++) {
									Main.tile[num22, num23].active(active: true);
									Main.tile[num22, num23].type = 226;
									Main.tile[num22, num23].liquid = 0;
									Main.tile[num22, num23].slope(0);
									Main.tile[num22, num23].halfBrick(halfBrick: false);
								}
							}
						}
					}
				}
			}

			for (int num24 = 0; num24 < num2; num24++) {
				if (genRand.Next(1) != 0)
					continue;

				for (int num25 = array[num24].X; num25 < array[num24].X + array[num24].Width; num25++) {
					for (int num26 = array[num24].Y; num26 < array[num24].Y + array[num24].Height; num26++) {
						Main.tile[num25, num26].active(active: true);
						Main.tile[num25, num26].type = 226;
						Main.tile[num25, num26].liquid = 0;
						Main.tile[num25, num26].slope(0);
						Main.tile[num25, num26].halfBrick(halfBrick: false);
					}
				}

				int x2 = array[num24].X;
				int num27 = x2 + array[num24].Width;
				int y3 = array[num24].Y;
				int num28 = y3 + array[num24].Height;
				x2 += genRand.Next(3, 8);
				num27 -= genRand.Next(3, 8);
				y3 += genRand.Next(3, 8);
				num28 -= genRand.Next(3, 8);
				int num29 = x2;
				int num30 = num27;
				int num31 = y3;
				int num32 = num28;
				int num33 = (x2 + num27) / 2;
				int num34 = (y3 + num28) / 2;
				for (int num35 = x2; num35 < num27; num35++) {
					for (int num36 = y3; num36 < num28; num36++) {
						if (genRand.Next(20) == 0)
							num31 += genRand.Next(-1, 2);

						if (genRand.Next(20) == 0)
							num32 += genRand.Next(-1, 2);

						if (genRand.Next(20) == 0)
							num29 += genRand.Next(-1, 2);

						if (genRand.Next(20) == 0)
							num30 += genRand.Next(-1, 2);

						if (num29 < x2)
							num29 = x2;

						if (num30 > num27)
							num30 = num27;

						if (num31 < y3)
							num31 = y3;

						if (num32 > num28)
							num32 = num28;

						if (num29 > num33)
							num29 = num33;

						if (num30 < num33)
							num30 = num33;

						if (num31 > num34)
							num31 = num34;

						if (num32 < num34)
							num32 = num34;

						if (num35 >= num29 && num35 < num30 && num36 >= num31 && num36 <= num32) {
							Main.tile[num35, num36].active(active: false);
							Main.tile[num35, num36].wall = 87;
						}
					}
				}

				for (int num37 = num28; num37 > y3; num37--) {
					for (int num38 = num27; num38 > x2; num38--) {
						if (genRand.Next(20) == 0)
							num31 += genRand.Next(-1, 2);

						if (genRand.Next(20) == 0)
							num32 += genRand.Next(-1, 2);

						if (genRand.Next(20) == 0)
							num29 += genRand.Next(-1, 2);

						if (genRand.Next(20) == 0)
							num30 += genRand.Next(-1, 2);

						if (num29 < x2)
							num29 = x2;

						if (num30 > num27)
							num30 = num27;

						if (num31 < y3)
							num31 = y3;

						if (num32 > num28)
							num32 = num28;

						if (num29 > num33)
							num29 = num33;

						if (num30 < num33)
							num30 = num33;

						if (num31 > num34)
							num31 = num34;

						if (num32 < num34)
							num32 = num34;

						if (num38 >= num29 && num38 < num30 && num37 >= num31 && num37 <= num32) {
							Main.tile[num38, num37].active(active: false);
							Main.tile[num38, num37].wall = 87;
						}
					}
				}
			}

			Vector2 templePath = new Vector2(num5, num6);
			for (int num39 = 0; num39 < num2; num39++) {
				Rectangle rectangle2 = array[num39];
				rectangle2.X += 8;
				rectangle2.Y += 8;
				rectangle2.Width -= 16;
				rectangle2.Height -= 16;
				bool flag2 = true;
				while (flag2) {
					int num40 = genRand.Next(rectangle2.X, rectangle2.X + rectangle2.Width);
					int num41 = genRand.Next(rectangle2.Y, rectangle2.Y + rectangle2.Height);
					templePath = templePather(templePath, num40, num41);
					if (templePath.X == (float)num40 && templePath.Y == (float)num41)
						flag2 = false;
				}

				if (num39 >= num2 - 1)
					continue;

				if (genRand.Next(3) != 0) {
					int num42 = num39 + 1;
					if (array[num42].Y >= array[num39].Y + array[num39].Height) {
						rectangle2.X = array[num42].X;
						if (array[num42].X < array[num39].X)
							rectangle2.X += (int)((double)(float)array[num42].Width * 0.2);
						else
							rectangle2.X += (int)((double)(float)array[num42].Width * 0.8);

						rectangle2.Y = array[num42].Y;
					}
					else {
						rectangle2.X = (array[num39].X + array[num39].Width / 2 + (array[num42].X + array[num42].Width / 2)) / 2;
						rectangle2.Y = (int)((double)array[num42].Y + (double)array[num42].Height * 0.8);
					}

					int x3 = rectangle2.X;
					int y4 = rectangle2.Y;
					flag2 = true;
					while (flag2) {
						int num43 = genRand.Next(x3 - 6, x3 + 7);
						int num44 = genRand.Next(y4 - 6, y4 + 7);
						templePath = templePather(templePath, num43, num44);
						if (templePath.X == (float)num43 && templePath.Y == (float)num44)
							flag2 = false;
					}

					continue;
				}

				int num45 = num39 + 1;
				int num46 = (array[num39].X + array[num39].Width / 2 + (array[num45].X + array[num45].Width / 2)) / 2;
				int num47 = (array[num39].Y + array[num39].Height / 2 + (array[num45].Y + array[num45].Height / 2)) / 2;
				flag2 = true;
				while (flag2) {
					int num48 = genRand.Next(num46 - 6, num46 + 7);
					int num49 = genRand.Next(num47 - 6, num47 + 7);
					templePath = templePather(templePath, num48, num49);
					if (templePath.X == (float)num48 && templePath.Y == (float)num49)
						flag2 = false;
				}
			}

			int num50 = Main.maxTilesX - 20;
			int num51 = 20;
			int num52 = Main.maxTilesY - 20;
			int num53 = 20;
			for (int num54 = 0; num54 < num2; num54++) {
				if (array[num54].X < num50)
					num50 = array[num54].X;

				if (array[num54].X + array[num54].Width > num51)
					num51 = array[num54].X + array[num54].Width;

				if (array[num54].Y < num52)
					num52 = array[num54].Y;

				if (array[num54].Y + array[num54].Height > num53)
					num53 = array[num54].Y + array[num54].Height;
			}

			num50 -= 10;
			num51 += 10;
			num52 -= 10;
			num53 += 10;
			for (int num55 = num50; num55 < num51; num55++) {
				for (int num56 = num52; num56 < num53; num56++) {
					outerTempled(num55, num56);
				}
			}

			for (int num57 = num51; num57 >= num50; num57--) {
				for (int num58 = num52; num58 < num53 / 2; num58++) {
					outerTempled(num57, num58);
				}
			}

			for (int num59 = num52; num59 < num53; num59++) {
				for (int num60 = num50; num60 < num51; num60++) {
					outerTempled(num60, num59);
				}
			}

			for (int num61 = num53; num61 >= num52; num61--) {
				for (int num62 = num50; num62 < num51; num62++) {
					outerTempled(num62, num61);
				}
			}

			num3 = -num4;
			Vector2 vector = new Vector2(num5, num6);
			int num63 = genRand.Next(2, 5);
			bool flag3 = true;
			int num64 = 0;
			int num65 = genRand.Next(9, 14);
			while (flag3) {
				num64++;
				if (num64 >= num65) {
					num64 = 0;
					vector.Y -= 1f;
				}

				vector.X += num3;
				int num66 = (int)vector.X;
				flag3 = false;
				for (int num67 = (int)vector.Y - num63; (float)num67 < vector.Y + (float)num63; num67++) {
					if (Main.tile[num66, num67].wall == 87 || (Main.tile[num66, num67].active() && Main.tile[num66, num67].type == 226))
						flag3 = true;

					if (Main.tile[num66, num67].active() && Main.tile[num66, num67].type == 226) {
						Main.tile[num66, num67].active(active: false);
						Main.tile[num66, num67].wall = 87;
					}
				}
			}

			int num68 = num5;
			int num69;
			for (num69 = num6; !Main.tile[num68, num69].active(); num69++) {
			}

			num69 -= 4;
			int num70 = num69;
			while ((Main.tile[num68, num70].active() && Main.tile[num68, num70].type == 226) || Main.tile[num68, num70].wall == 87) {
				num70--;
			}

			num70 += 2;
			for (int num71 = num68 - 1; num71 <= num68 + 1; num71++) {
				for (int num72 = num70; num72 <= num69; num72++) {
					Main.tile[num71, num72].active(active: true);
					Main.tile[num71, num72].type = 226;
					Main.tile[num71, num72].liquid = 0;
					Main.tile[num71, num72].slope(0);
					Main.tile[num71, num72].halfBrick(halfBrick: false);
				}
			}

			for (int num73 = num68 - 4; num73 <= num68 + 4; num73++) {
				for (int num74 = num69 - 1; num74 < num69 + 3; num74++) {
					Main.tile[num73, num74].active(active: false);
					Main.tile[num73, num74].wall = 87;
				}
			}

			for (int num75 = num68 - 1; num75 <= num68 + 1; num75++) {
				for (int num76 = num69 - 5; num76 <= num69 + 8; num76++) {
					Main.tile[num75, num76].active(active: true);
					Main.tile[num75, num76].type = 226;
					Main.tile[num75, num76].liquid = 0;
					Main.tile[num75, num76].slope(0);
					Main.tile[num75, num76].halfBrick(halfBrick: false);
				}
			}

			for (int num77 = num68 - 1; num77 <= num68 + 1; num77++) {
				for (int num78 = num69; num78 < num69 + 3; num78++) {
					Main.tile[num77, num78].active(active: false);
					Main.tile[num77, num78].wall = 87;
				}
			}

			PlaceTile(num68, num69, 10, mute: true, forced: false, -1, 11);
			for (int num79 = num50; num79 < num51; num79++) {
				for (int num80 = num52; num80 < num53; num80++) {
					templeCleaner(num79, num80);
				}
			}

			for (int num81 = num53; num81 >= num52; num81--) {
				for (int num82 = num51; num82 >= num50; num82--) {
					templeCleaner(num82, num81);
				}
			}

			for (int num83 = num50; num83 < num51; num83++) {
				for (int num84 = num52; num84 < num53; num84++) {
					bool flag4 = true;
					for (int num85 = num83 - 1; num85 <= num83 + 1; num85++) {
						for (int num86 = num84 - 1; num86 <= num84 + 1; num86++) {
							if ((!Main.tile[num85, num86].active() || Main.tile[num85, num86].type != 226) && Main.tile[num85, num86].wall != 87) {
								flag4 = false;
								break;
							}
						}
					}

					if (flag4)
						Main.tile[num83, num84].wall = 87;
				}
			}

			int num87 = 0;
			while (true) {
				num87++;
				Rectangle rectangle3 = array[num2 - 1];
				int num88 = rectangle3.X + genRand.Next(rectangle3.Width);
				int num89 = rectangle3.Y + genRand.Next(rectangle3.Height);
				PlaceTile(num88, num89, 237);
				if (Main.tile[num88, num89].type == 237) {
					lAltarX = num88 - Main.tile[num88, num89].frameX / 18;
					lAltarY = num89 - Main.tile[num88, num89].frameY / 18;
					break;
				}

				if (num87 < 1000)
					continue;

				num88 = rectangle3.X + rectangle3.Width / 2;
				num89 = rectangle3.Y + rectangle3.Height / 2;
				num88 += genRand.Next(-10, 11);
				for (num89 += genRand.Next(-10, 11); !Main.tile[num88, num89].active(); num89++) {
				}

				Main.tile[num88 - 1, num89].active(active: true);
				Main.tile[num88 - 1, num89].slope(0);
				Main.tile[num88 - 1, num89].halfBrick(halfBrick: false);
				Main.tile[num88 - 1, num89].type = 226;
				Main.tile[num88, num89].active(active: true);
				Main.tile[num88, num89].slope(0);
				Main.tile[num88, num89].halfBrick(halfBrick: false);
				Main.tile[num88, num89].type = 226;
				Main.tile[num88 + 1, num89].active(active: true);
				Main.tile[num88 + 1, num89].slope(0);
				Main.tile[num88 + 1, num89].halfBrick(halfBrick: false);
				Main.tile[num88 + 1, num89].type = 226;
				num89 -= 2;
				num88--;
				for (int num90 = -1; num90 <= 3; num90++) {
					for (int num91 = -1; num91 <= 1; num91++) {
						x = num88 + num90;
						y = num89 + num91;
						Main.tile[x, y].active(active: false);
					}
				}

				lAltarX = num88;
				lAltarY = num89;
				for (int num92 = 0; num92 <= 2; num92++) {
					for (int num93 = 0; num93 <= 1; num93++) {
						x = num88 + num92;
						y = num89 + num93;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].type = 237;
						Main.tile[x, y].frameX = (short)(num92 * 18);
						Main.tile[x, y].frameY = (short)(num93 * 18);
					}
				}

				break;
			}

			float num94 = (float)num2 * 1.1f;
			num94 *= 1f + (float)genRand.Next(-25, 26) * 0.01f;
			num94 *= Main.setting.TempleTrapMultiplier;
			int num95 = 0;
			while (num94 > 0f) {
				num95++;
				int num96 = genRand.Next(num2);
				int num97 = genRand.Next(array[num96].X, array[num96].X + array[num96].Width);
				int num98 = genRand.Next(array[num96].Y, array[num96].Y + array[num96].Height);
				if (Main.tile[num97, num98].wall == 87 && !Main.tile[num97, num98].active()) {
					bool flag5 = false;
					if (genRand.Next(2) == 0) {
						int num99 = 1;
						if (genRand.Next(2) == 0)
							num99 = -1;

						for (; !Main.tile[num97, num98].active(); num98 += num99) {
						}

						num98 -= num99;
						int num100 = genRand.Next(2);
						int num101 = genRand.Next(3, 10);
						bool flag6 = true;
						for (int num102 = num97 - num101; num102 < num97 + num101; num102++) {
							for (int num103 = num98 - num101; num103 < num98 + num101; num103++) {
								if (Main.tile[num102, num103].active() && Main.tile[num102, num103].type == 10) {
									flag6 = false;
									break;
								}
							}
						}

						if (flag6) {
							for (int num104 = num97 - num101; num104 < num97 + num101; num104++) {
								for (int num105 = num98 - num101; num105 < num98 + num101; num105++) {
									if (SolidTile(num104, num105) && Main.tile[num104, num105].type != 232 && !SolidTile(num104, num105 - num99)) {
										Main.tile[num104, num105].type = 232;
										flag5 = true;
										if (num100 == 0) {
											Main.tile[num104, num105 - 1].type = 232;
											Main.tile[num104, num105 - 1].active(active: true);
										}
										else {
											Main.tile[num104, num105 + 1].type = 232;
											Main.tile[num104, num105 + 1].active(active: true);
										}

										num100++;
										if (num100 > 1)
											num100 = 0;
									}
								}
							}
						}

						if (flag5) {
							num95 = 0;
							num94 -= 1f;
						}
					}
					else {
						int num106 = 1;
						if (genRand.Next(2) == 0)
							num106 = -1;

						for (; !Main.tile[num97, num98].active(); num97 += num106) {
						}

						num97 -= num106;
						int num107 = genRand.Next(2);
						int num108 = genRand.Next(3, 10);
						bool flag7 = true;
						for (int num109 = num97 - num108; num109 < num97 + num108; num109++) {
							for (int num110 = num98 - num108; num110 < num98 + num108; num110++) {
								if (Main.tile[num109, num110].active() && Main.tile[num109, num110].type == 10) {
									flag7 = false;
									break;
								}
							}
						}

						if (flag7) {
							for (int num111 = num97 - num108; num111 < num97 + num108; num111++) {
								for (int num112 = num98 - num108; num112 < num98 + num108; num112++) {
									if (SolidTile(num111, num112) && Main.tile[num111, num112].type != 232 && !SolidTile(num111 - num106, num112)) {
										Main.tile[num111, num112].type = 232;
										flag5 = true;
										if (num107 == 0) {
											Main.tile[num111 - 1, num112].type = 232;
											Main.tile[num111 - 1, num112].active(active: true);
										}
										else {
											Main.tile[num111 + 1, num112].type = 232;
											Main.tile[num111 + 1, num112].active(active: true);
										}

										num107++;
										if (num107 > 1)
											num107 = 0;
									}
								}
							}
						}

						if (flag5) {
							num95 = 0;
							num94 -= 1f;
						}
					}
				}

				if (num95 > 1000) {
					num95 = 0;
					num94 -= 1f;
				}
			}

			tLeft = num50;
			tRight = num51;
			tTop = num52;
			tBottom = num53;
			tRooms = num2;
		}

		public static void templePart2() {
			int minValue = tLeft;
			int maxValue = tRight;
			int minValue2 = tTop;
			int num = tBottom;
			int num2 = tRooms;
			float num3 = (float)num2 * 1.9f;
			num3 *= 1f + (float)genRand.Next(-15, 16) * 0.01f;
			int num4 = 0;
			while (num3 > 0f) {
				int num5 = genRand.Next(minValue, maxValue);
				int num6 = genRand.Next(minValue2, num);
				if (Main.tile[num5, num6].wall == 87 && !Main.tile[num5, num6].active()) {
					if (mayanTrap(num5, num6)) {
						num3 -= 1f;
						num4 = 0;
					}
					else {
						num4++;
					}
				}
				else {
					num4++;
				}

				if (num4 > 100) {
					num4 = 0;
					num3 -= 1f;
				}
			}

			Main.tileSolid[232] = false;
			float num7 = (float)num2 * 0.35f * Main.setting.TempleChestMultiplier;
			num7 *= 1f + (float)genRand.Next(-15, 16) * 0.01f;
			int contain = 1293;
			num4 = 0;
			while (num7 > 0f) {
				int num8 = genRand.Next(minValue, maxValue);
				int num9 = genRand.Next(minValue2, num);
				if (Main.tile[num8, num9].wall == 87 && !Main.tile[num8, num9].active() && AddBuriedChest(num8, num9, contain, notNearOtherChests: true, 16)) {
					num7 -= 1f;
					num4 = 0;
				}

				num4++;
				if (num4 > 10000)
					break;
			}

			float num10 = (float)num2 * 1.25f;
			num10 *= 1f + (float)genRand.Next(-25, 36) * 0.01f;
			num4 = 0;
			while (num10 > 0f) {
				num4++;
				int num11 = genRand.Next(minValue, maxValue);
				int num12 = genRand.Next(minValue2, num);
				if (Main.tile[num11, num12].wall != 87 || Main.tile[num11, num12].active())
					continue;

				int num13 = num11;
				int num14 = num12;
				while (!Main.tile[num13, num14].active()) {
					num14++;
					if (num14 > num)
						break;
				}

				num14--;
				if (num14 <= num) {
					PlaceTile(num13, num14, 105, mute: true, forced: false, -1, genRand.Next(43, 46));
					if (Main.tile[num13, num14].type == 105)
						num10 -= 1f;
				}
			}

			float num15 = (float)num2 * 1.35f;
			num15 *= 1f + (float)genRand.Next(-15, 26) * 0.01f;
			num4 = 0;
			while (num15 > 0f) {
				num4++;
				int num16 = genRand.Next(minValue, maxValue);
				int num17 = genRand.Next(minValue2, num);
				if (Main.tile[num16, num17].wall == 87 && !Main.tile[num16, num17].active()) {
					int num18 = num16;
					int num19 = num17;
					while (!Main.tile[num18, num19].active()) {
						num19++;
						if (num19 > num)
							break;
					}

					num19--;
					if (num19 <= num) {
						switch (genRand.Next(3)) {
							case 0:
								PlaceTile(num18, num19, 18, mute: true, forced: false, -1, 10);
								if (Main.tile[num18, num19].type == 18)
									num15 -= 1f;
								break;
							case 1:
								PlaceTile(num18, num19, 14, mute: true, forced: false, -1, 9);
								if (Main.tile[num18, num19].type == 14)
									num15 -= 1f;
								break;
							case 2:
								PlaceTile(num18, num19, 15, mute: true, forced: false, -1, 12);
								if (Main.tile[num18, num19].type == 15)
									num15 -= 1f;
								break;
						}
					}
				}

				if (num4 > 10000)
					break;
			}

			Main.tileSolid[232] = true;
		}

		public static bool nearPicture(int x, int y) {
			for (int i = x - 4; i <= x + 3; i++) {
				for (int j = y - 3; j <= y + 2; j++) {
					if (Main.tile[i, j].active())
						return true;
				}
			}

			return false;
		}

		public static bool nearPicture2(int x, int y) {
			if (Main.tile[x, y].wall != 7 && Main.tile[x, y].wall != 8 && Main.tile[x, y].wall != 9) {
				for (int i = x - 8; i <= x + 8; i++) {
					for (int j = y - 5; j <= y + 5; j++) {
						if (Main.tile[i, j].active() && (Main.tile[i, j].type == 240 || Main.tile[i, j].type == 241 || Main.tile[i, j].type == 242))
							return true;
					}
				}
			}
			else {
				for (int k = x - 15; k <= x + 15; k++) {
					for (int l = y - 10; l <= y + 10; l++) {
						if (Main.tile[k, l].active() && (Main.tile[k, l].type == 240 || Main.tile[k, l].type == 241 || Main.tile[k, l].type == 242))
							return true;
					}
				}
			}

			return false;
		}


		public static void MakeDungeon(int x, int y) { } // Empty method for IL compatibility
		public static void MakeDungeon(int x, int y, GenerationProgress progress) {
			Main.setting.DungeonStyle = Main.setting.SelectDungeon;
			if (Main.setting.DungeonStyle == 3)
			{
				Main.setting.DungeonStyle = WorldGen.genRand.Next(3);
			}
			genRand.Next(3);
			ushort num2;
			int num3;
			switch (Main.setting.DungeonStyle) {
				case 0:
					num2 = 41;
					num3 = 7;
					break;
				case 1:
					num2 = 43;
					num3 = 8;
					break;
				default:
					num2 = 44;
					num3 = 9;
					break;
			}

			numDDoors = 0;
			numDPlats = 0;
			numDRooms = 0;
			dungeonX = x;
			dungeonY = y;
			dMinX = x;
			dMaxX = x;
			dMinY = y;
			dMaxY = y;
			dxStrength1 = genRand.Next(25, 30);
			dyStrength1 = genRand.Next(20, 25);
			dxStrength2 = genRand.Next(35, 50);
			dyStrength2 = genRand.Next(10, 15);
			float num4 = (float)(Main.setting.DungeonSizeMultiplier * Main.maxTilesX / 60);
			num4 += (float)genRand.Next(0, (int)(num4 / 3f));
			float num5 = num4;
			int num6 = 5;
			DungeonRoom(dungeonX, dungeonY, num2, num3);
			while (num4 > 0f) {
				if (dungeonX < dMinX)
					dMinX = dungeonX;

				if (dungeonX > dMaxX)
					dMaxX = dungeonX;

				if (dungeonY > dMaxY)
					dMaxY = dungeonY;

				num4 -= 1f;
				Main.statusText = Lang.gen[58].Value + " " + (int)((num5 - num4) / num5 * 60f) + "%";
				progress.Message = Main.statusText;
				if (num6 > 0)
					num6--;

				if ((num6 == 0) & (genRand.Next(3) == 0)) {
					num6 = 5;
					if (genRand.Next(2) == 0) {
						int num7 = dungeonX;
						int num8 = dungeonY;
						DungeonHalls(dungeonX, dungeonY, num2, num3);
						if (genRand.Next(2) == 0)
							DungeonHalls(dungeonX, dungeonY, num2, num3);

						DungeonRoom(dungeonX, dungeonY, num2, num3);
						dungeonX = num7;
						dungeonY = num8;
					}
					else {
						DungeonRoom(dungeonX, dungeonY, num2, num3);
					}
				}
				else {
					DungeonHalls(dungeonX, dungeonY, num2, num3);
				}
			}

			DungeonRoom(dungeonX, dungeonY, num2, num3);
			int num9 = dRoomX[0];
			int num10 = dRoomY[0];
			for (int i = 0; i < numDRooms; i++) {
				if (dRoomY[i] < num10) {
					num9 = dRoomX[i];
					num10 = dRoomY[i];
				}
			}

			dungeonX = num9;
			dungeonY = num10;
			dEnteranceX = num9;
			dSurface = false;
			num6 = 5;
			while (!dSurface) {
				if (num6 > 0)
					num6--;

				if (num6 == 0 && genRand.Next(5) == 0 && (double)dungeonY > Main.worldSurface + 100.0) {
					num6 = 10;
					int num11 = dungeonX;
					int num12 = dungeonY;
					DungeonHalls(dungeonX, dungeonY, num2, num3, forceX: true);
					DungeonRoom(dungeonX, dungeonY, num2, num3);
					dungeonX = num11;
					dungeonY = num12;
				}

				DungeonStairs(dungeonX, dungeonY, num2, num3);
			}

			DungeonEnt(dungeonX, dungeonY, num2, num3);
			Main.statusText = Lang.gen[58].Value + " 65%";
			for (int j = 0; j < numDRooms; j++) {
				for (int k = dRoomL[j]; k <= dRoomR[j]; k++) {
					if (!Main.tile[k, dRoomT[j] - 1].active()) {
						DPlatX[numDPlats] = k;
						DPlatY[numDPlats] = dRoomT[j] - 1;
						numDPlats++;
						break;
					}
				}

				for (int l = dRoomL[j]; l <= dRoomR[j]; l++) {
					if (!Main.tile[l, dRoomB[j] + 1].active()) {
						DPlatX[numDPlats] = l;
						DPlatY[numDPlats] = dRoomB[j] + 1;
						numDPlats++;
						break;
					}
				}

				for (int m = dRoomT[j]; m <= dRoomB[j]; m++) {
					if (!Main.tile[dRoomL[j] - 1, m].active()) {
						DDoorX[numDDoors] = dRoomL[j] - 1;
						DDoorY[numDDoors] = m;
						DDoorPos[numDDoors] = -1;
						numDDoors++;
						break;
					}
				}

				for (int n = dRoomT[j]; n <= dRoomB[j]; n++) {
					if (!Main.tile[dRoomR[j] + 1, n].active()) {
						DDoorX[numDDoors] = dRoomR[j] + 1;
						DDoorY[numDDoors] = n;
						DDoorPos[numDDoors] = 1;
						numDDoors++;
						break;
					}
				}
			}

			Main.statusText = Lang.gen[58].Value + " 70%";
			int num13 = 0;
			int num14 = 1000;
			int num15 = 0;
			while (num15 < Main.maxTilesX / 100) {
				num13++;
				int num16 = genRand.Next(dMinX, dMaxX);
				int num17 = genRand.Next((int)Main.worldSurface + 25, dMaxY);
				int num18 = num16;
				if (Main.tile[num16, num17].wall == num3 && !Main.tile[num16, num17].active()) {
					int num19 = 1;
					if (genRand.Next(2) == 0)
						num19 = -1;

					for (; !Main.tile[num16, num17].active(); num17 += num19) {
					}

					if (Main.tile[num16 - 1, num17].active() && Main.tile[num16 + 1, num17].active() && !Main.tile[num16 - 1, num17 - num19].active() && !Main.tile[num16 + 1, num17 - num19].active()) {
						num15++;
						int num20 = genRand.Next(5, 13);
						while (Main.tile[num16 - 1, num17].active() && Main.tile[num16, num17 + num19].active() && Main.tile[num16, num17].active() && !Main.tile[num16, num17 - num19].active() && num20 > 0) {
							Main.tile[num16, num17].type = 48;
							if (!Main.tile[num16 - 1, num17 - num19].active() && !Main.tile[num16 + 1, num17 - num19].active()) {
								Main.tile[num16, num17 - num19].type = 48;
								Main.tile[num16, num17 - num19].active(active: true);
							}

							num16--;
							num20--;
						}

						num20 = genRand.Next(5, 13);
						num16 = num18 + 1;
						while (Main.tile[num16 + 1, num17].active() && Main.tile[num16, num17 + num19].active() && Main.tile[num16, num17].active() && !Main.tile[num16, num17 - num19].active() && num20 > 0) {
							Main.tile[num16, num17].type = 48;
							if (!Main.tile[num16 - 1, num17 - num19].active() && !Main.tile[num16 + 1, num17 - num19].active()) {
								Main.tile[num16, num17 - num19].type = 48;
								Main.tile[num16, num17 - num19].active(active: true);
							}

							num16++;
							num20--;
						}
					}
				}

				if (num13 > num14) {
					num13 = 0;
					num15++;
				}
			}

			num13 = 0;
			num14 = 1000;
			num15 = 0;
			Main.statusText = Lang.gen[58].Value + " 75%";
			while (num15 < Main.maxTilesX / 100) {
				num13++;
				int num21 = genRand.Next(dMinX, dMaxX);
				int num22 = genRand.Next((int)Main.worldSurface + 25, dMaxY);
				int num23 = num22;
				if (Main.tile[num21, num22].wall == num3 && !Main.tile[num21, num22].active()) {
					int num24 = 1;
					if (genRand.Next(2) == 0)
						num24 = -1;

					for (; num21 > 5 && num21 < Main.maxTilesX - 5 && !Main.tile[num21, num22].active(); num21 += num24) {
					}

					if (Main.tile[num21, num22 - 1].active() && Main.tile[num21, num22 + 1].active() && !Main.tile[num21 - num24, num22 - 1].active() && !Main.tile[num21 - num24, num22 + 1].active()) {
						num15++;
						int num25 = genRand.Next(5, 13);
						while (Main.tile[num21, num22 - 1].active() && Main.tile[num21 + num24, num22].active() && Main.tile[num21, num22].active() && !Main.tile[num21 - num24, num22].active() && num25 > 0) {
							Main.tile[num21, num22].type = 48;
							if (!Main.tile[num21 - num24, num22 - 1].active() && !Main.tile[num21 - num24, num22 + 1].active()) {
								Main.tile[num21 - num24, num22].type = 48;
								Main.tile[num21 - num24, num22].active(active: true);
							}

							num22--;
							num25--;
						}

						num25 = genRand.Next(5, 13);
						num22 = num23 + 1;
						while (Main.tile[num21, num22 + 1].active() && Main.tile[num21 + num24, num22].active() && Main.tile[num21, num22].active() && !Main.tile[num21 - num24, num22].active() && num25 > 0) {
							Main.tile[num21, num22].type = 48;
							if (!Main.tile[num21 - num24, num22 - 1].active() && !Main.tile[num21 - num24, num22 + 1].active()) {
								Main.tile[num21 - num24, num22].type = 48;
								Main.tile[num21 - num24, num22].active(active: true);
							}

							num22++;
							num25--;
						}
					}
				}

				if (num13 > num14) {
					num13 = 0;
					num15++;
				}
			}

			Main.statusText = Lang.gen[58].Value + " 80%";
			for (int num26 = 0; num26 < numDDoors; num26++) {
				int num27 = DDoorX[num26] - 10;
				int num28 = DDoorX[num26] + 10;
				int num29 = 100;
				int num30 = 0;
				int num31 = 0;
				int num32 = 0;
				for (int num33 = num27; num33 < num28; num33++) {
					bool flag = true;
					int num34 = DDoorY[num26];
					while (num34 > 10 && !Main.tile[num33, num34].active()) {
						num34--;
					}

					if (!Main.tileDungeon[Main.tile[num33, num34].type])
						flag = false;

					num31 = num34;
					for (num34 = DDoorY[num26]; !Main.tile[num33, num34].active(); num34++) {
					}

					if (!Main.tileDungeon[Main.tile[num33, num34].type])
						flag = false;

					num32 = num34;
					if (num32 - num31 < 3)
						continue;

					int num35 = num33 - 20;
					int num36 = num33 + 20;
					int num37 = num32 - 10;
					int num38 = num32 + 10;
					for (int num39 = num35; num39 < num36; num39++) {
						for (int num40 = num37; num40 < num38; num40++) {
							if (Main.tile[num39, num40].active() && Main.tile[num39, num40].type == 10) {
								flag = false;
								break;
							}
						}
					}

					if (flag) {
						for (int num41 = num32 - 3; num41 < num32; num41++) {
							for (int num42 = num33 - 3; num42 <= num33 + 3; num42++) {
								if (Main.tile[num42, num41].active()) {
									flag = false;
									break;
								}
							}
						}
					}

					if (flag && num32 - num31 < 20) {
						bool flag2 = false;
						if (DDoorPos[num26] == 0 && num32 - num31 < num29)
							flag2 = true;

						if (DDoorPos[num26] == -1 && num33 > num30)
							flag2 = true;

						if (DDoorPos[num26] == 1 && (num33 < num30 || num30 == 0))
							flag2 = true;

						if (flag2) {
							num30 = num33;
							num29 = num32 - num31;
						}
					}
				}

				if (num29 >= 20)
					continue;

				int num43 = num30;
				int num44 = DDoorY[num26];
				int num45 = num44;
				for (; !Main.tile[num43, num44].active(); num44++) {
					Main.tile[num43, num44].active(active: false);
				}

				while (!Main.tile[num43, num45].active()) {
					num45--;
				}

				num44--;
				num45++;
				for (int num46 = num45; num46 < num44 - 2; num46++) {
					Main.tile[num43, num46].active(active: true);
					Main.tile[num43, num46].type = num2;
				}

				int style = 13;
				if (genRand.Next(3) == 0) {
					switch (num3) {
						case 7:
							style = 16;
							break;
						case 8:
							style = 17;
							break;
						case 9:
							style = 18;
							break;
					}
				}

				PlaceTile(num43, num44, 10, mute: true, forced: false, -1, style);
				num43--;
				int num47 = num44 - 3;
				while (!Main.tile[num43, num47].active()) {
					num47--;
				}

				if (num44 - num47 < num44 - num45 + 5 && Main.tileDungeon[Main.tile[num43, num47].type]) {
					for (int num48 = num44 - 4 - genRand.Next(3); num48 > num47; num48--) {
						Main.tile[num43, num48].active(active: true);
						Main.tile[num43, num48].type = num2;
					}
				}

				num43 += 2;
				num47 = num44 - 3;
				while (!Main.tile[num43, num47].active()) {
					num47--;
				}

				if (num44 - num47 < num44 - num45 + 5 && Main.tileDungeon[Main.tile[num43, num47].type]) {
					for (int num49 = num44 - 4 - genRand.Next(3); num49 > num47; num49--) {
						Main.tile[num43, num49].active(active: true);
						Main.tile[num43, num49].type = num2;
					}
				}

				num44++;
				num43--;
				Main.tile[num43 - 1, num44].active(active: true);
				Main.tile[num43 - 1, num44].type = num2;
				Main.tile[num43 + 1, num44].active(active: true);
				Main.tile[num43 + 1, num44].type = num2;
			}

			int[] array = new int[3];
			switch (num3) {
				case 7:
					array[0] = 7;
					array[1] = 94;
					array[2] = 95;
					break;
				case 9:
					array[0] = 9;
					array[1] = 96;
					array[2] = 97;
					break;
				default:
					array[0] = 8;
					array[1] = 98;
					array[2] = 99;
					break;
			}

			for (int num50 = 0; num50 < 5; num50++) {
				for (int num51 = 0; num51 < 3; num51++) {
					int num52 = genRand.Next(40, 240);
					int num53 = genRand.Next(dMinX, dMaxX);
					int num54 = genRand.Next(dMinY, dMaxY);
					for (int num55 = num53 - num52; num55 < num53 + num52; num55++) {
						for (int num56 = num54 - num52; num56 < num54 + num52; num56++) {
							if ((double)num56 > Main.worldSurface) {
								float num57 = Math.Abs(num53 - num55);
								float num58 = Math.Abs(num54 - num56);
								if (Math.Sqrt(num57 * num57 + num58 * num58) < (double)num52 * 0.4 &&  num53 < Main.maxTilesX && Main.wallDungeon[Main.tile[num55, num56].wall])
									Spread.WallDungeon(num55, num56, array[num51]);
							}
						}
					}
				}
			}

			Main.statusText = Lang.gen[58].Value + " 85%";
			for (int num59 = 0; num59 < numDPlats; num59++) {
				int num60 = DPlatX[num59];
				int num61 = DPlatY[num59];
				int num62 = Main.maxTilesX;
				int num63 = 10;
				if ((double)num61 < Main.worldSurface + 50.0)
					num63 = 20;

				for (int num64 = num61 - 5; num64 <= num61 + 5; num64++) {
					int num65 = num60;
					int num66 = num60;
					bool flag3 = false;
					if (Main.tile[num65, num64].active()) {
						flag3 = true;
					}
					else {
						while (!Main.tile[num65, num64].active()) {
							num65--;
							if (!Main.tileDungeon[Main.tile[num65, num64].type])
								flag3 = true;
						}

						while (!Main.tile[num66, num64].active()) {
							num66++;
							if (!Main.tileDungeon[Main.tile[num66, num64].type])
								flag3 = true;
						}
					}

					if (flag3 || num66 - num65 > num63)
						continue;

					bool flag4 = true;
					int num67 = num60 - num63 / 2 - 2;
					int num68 = num60 + num63 / 2 + 2;
					int num69 = num64 - 5;
					int num70 = num64 + 5;
					for (int num71 = num67; num71 <= num68; num71++) {
						for (int num72 = num69; num72 <= num70; num72++) {
							if (Main.tile[num71, num72].active() && Main.tile[num71, num72].type == 19) {
								flag4 = false;
								break;
							}
						}
					}

					for (int num73 = num64 + 3; num73 >= num64 - 5; num73--) {
						if (Main.tile[num60, num73].active()) {
							flag4 = false;
							break;
						}
					}

					if (flag4) {
						num62 = num64;
						break;
					}
				}

				if (num62 <= num61 - 10 || num62 >= num61 + 10)
					continue;

				int num74 = num60;
				int num75 = num62;
				int num76 = num60 + 1;
				while (!Main.tile[num74, num75].active()) {
					Main.tile[num74, num75].active(active: true);
					Main.tile[num74, num75].type = 19;
					if (num3 == 7)
						Main.tile[num74, num75].frameY = 108;

					if (num3 == 8)
						Main.tile[num74, num75].frameY = 144;

					if (num3 == 9)
						Main.tile[num74, num75].frameY = 126;

					num74--;
				}

				for (; !Main.tile[num76, num75].active(); num76++) {
					Main.tile[num76, num75].active(active: true);
					Main.tile[num76, num75].type = 19;
					if (num3 == 7)
						Main.tile[num76, num75].frameY = 108;

					if (num3 == 8)
						Main.tile[num76, num75].frameY = 144;

					if (num3 == 9)
						Main.tile[num76, num75].frameY = 126;
				}
			}

			int numChests = 4;
			if (Main.setting.IsCorruption == 3 || Main.setting.IsCorruption == 4)
				numChests++;
			for (int round = 0; round < Main.setting.BiomeChestSets; round++)
			{
			for (int num77 = 0; num77 < numChests; num77++) {
				bool flag5 = false;
				while (!flag5) {
					int num78 = genRand.Next(dMinX, dMaxX);
					int num79 = genRand.Next((int)Main.worldSurface, dMaxY);
					if (!Main.wallDungeon[Main.tile[num78, num79].wall] || Main.tile[num78, num79].active())
						continue;

					int contain = 0;
					int style2 = 0;
					switch (num77) {
						case 0:
							style2 = 23;
							contain = 1156;
							break;
						case 1:
							if (!crimson) {
								style2 = 24;
								contain = 1571;
							}
							else {
								style2 = 25;
								contain = 1569;
							}
							break;
						case 2:
							style2 = 26;
							contain = 1260;
							break;
						case 3:
							style2 = 27;
							contain = 1572;
							break;
						case 4:
							if (WorldGen.crimson)
							{
								style2 = 24;
								contain = 1571;
							}
							else
							{
								style2 = 25;
								contain = 1569;
							}
							break;

					}

					flag5 = AddBuriedChest(num78, num79, contain, notNearOtherChests: false, style2);
				}
			}
			}

			int[] array2 = new int[3] {
				genRand.Next(9, 13),
				genRand.Next(9, 13),
				0
			};

			while (array2[1] == array2[0]) {
				array2[1] = genRand.Next(9, 13);
			}

			array2[2] = genRand.Next(9, 13);
			while (array2[2] == array2[0] || array2[2] == array2[1]) {
				array2[2] = genRand.Next(9, 13);
			}

			Main.statusText = Lang.gen[58].Value + " 90%";
			num13 = 0;
			num14 = 1000;
			num15 = 0;
			while (num15 < Main.maxTilesX / 20) {
				num13++;
				int num80 = genRand.Next(dMinX, dMaxX);
				int num81 = genRand.Next(dMinY, dMaxY);
				bool flag6 = true;
				if (Main.wallDungeon[Main.tile[num80, num81].wall] && !Main.tile[num80, num81].active()) {
					int num82 = 1;
					if (genRand.Next(2) == 0)
						num82 = -1;

					while (flag6 && !Main.tile[num80, num81].active()) {
						num80 -= num82;
						if (num80 < 5 || num80 > Main.maxTilesX - 5)
							flag6 = false;
						else if (Main.tile[num80, num81].active() && !Main.tileDungeon[Main.tile[num80, num81].type])
							flag6 = false;
					}

					if (flag6 && Main.tile[num80, num81].active() && Main.tileDungeon[Main.tile[num80, num81].type] && Main.tile[num80, num81 - 1].active() && Main.tileDungeon[Main.tile[num80, num81 - 1].type] && Main.tile[num80, num81 + 1].active() && Main.tileDungeon[Main.tile[num80, num81 + 1].type]) {
						num80 += num82;
						for (int num83 = num80 - 3; num83 <= num80 + 3; num83++) {
							for (int num84 = num81 - 3; num84 <= num81 + 3; num84++) {
								if (Main.tile[num83, num84].active() && Main.tile[num83, num84].type == 19) {
									flag6 = false;
									break;
								}
							}
						}

						if (flag6 && (!Main.tile[num80, num81 - 1].active() & !Main.tile[num80, num81 - 2].active() & !Main.tile[num80, num81 - 3].active())) {
							int num85 = num80;
							int num86 = num80;
							for (; num85 > dMinX && num85 < dMaxX && !Main.tile[num85, num81].active() && !Main.tile[num85, num81 - 1].active() && !Main.tile[num85, num81 + 1].active(); num85 += num82) {
							}

							num85 = Math.Abs(num80 - num85);
							bool flag7 = false;
							if (genRand.Next(2) == 0)
								flag7 = true;

							if (num85 > 5) {
								for (int num87 = genRand.Next(1, 4); num87 > 0; num87--) {
									Main.tile[num80, num81].active(active: true);
									Main.tile[num80, num81].type = 19;
									if (Main.tile[num80, num81].wall == array[0])
										Main.tile[num80, num81].frameY = (short)(18 * array2[0]);

									if (Main.tile[num80, num81].wall == array[1])
										Main.tile[num80, num81].frameY = (short)(18 * array2[1]);

									if (Main.tile[num80, num81].wall == array[2])
										Main.tile[num80, num81].frameY = (short)(18 * array2[2]);

									if (flag7) {
										PlaceTile(num80, num81 - 1, 50, mute: true);
										if (genRand.Next(50) == 0 && Main.tile[num80, num81 - 1].type == 50)
											Main.tile[num80, num81 - 1].frameX = 90;
									}

									num80 += num82;
								}

								num13 = 0;
								num15++;
								if (!flag7 && genRand.Next(2) == 0) {
									num80 = num86;
									num81--;
									int num88 = 0;
									if (genRand.Next(4) == 0)
										num88 = 1;

									switch (num88) {
										case 0:
											num88 = 13;
											break;
										case 1:
											num88 = 49;
											break;
									}

									PlaceTile(num80, num81, num88, mute: true);
									if (Main.tile[num80, num81].type == 13) {
										if (genRand.Next(2) == 0)
											Main.tile[num80, num81].frameX = 18;
										else
											Main.tile[num80, num81].frameX = 36;
									}
								}
							}
						}
					}
				}

				if (num13 > num14) {
					num13 = 0;
					num15++;
				}
			}

			Main.statusText = Lang.gen[58].Value + " 95%";
			int num89 = 1;
			for (int num90 = 0; num90 < numDRooms; num90++) {
				int num91 = 0;
				while (num91 < 1000) {
					int num92 = (int)((double)dRoomSize[num90] * 0.4);
					int i2 = dRoomX[num90] + genRand.Next(-num92, num92 + 1);
					int num93 = dRoomY[num90] + genRand.Next(-num92, num92 + 1);
					int num94 = 0;
					int style3 = 2;
					switch (num89) {
						case 1:
							num94 = 329;
							break;
						case 2:
							num94 = 155;
							break;
						case 3:
							num94 = 156;
							break;
						case 4:
							num94 = 157;
							break;
						case 5:
							num94 = 163;
							break;
						case 6:
							num94 = 113;
							break;
						case 7:
							num94 = 3317;
							break;
						case 8:
							num94 = 327;
							style3 = 0;
							break;
						default:
							num94 = 164;
							num89 = 0;
							break;
					}

					if ((double)num93 < Main.worldSurface + 50.0) {
						num94 = 327;
						style3 = 0;
					}

					if (num94 == 0 && genRand.Next(2) == 0) {
						num91 = 1000;
						continue;
					}

					if (AddBuriedChest(i2, num93, num94, notNearOtherChests: false, style3)) {
						num91 += 1000;
						num89++;
					}

					num91++;
				}
			}

			dMinX -= 25;
			dMaxX += 25;
			dMinY -= 25;
			dMaxY += 25;
			if (dMinX < 0)
				dMinX = 0;

			if (dMaxX > Main.maxTilesX)
				dMaxX = Main.maxTilesX;

			if (dMinY < 0)
				dMinY = 0;

			if (dMaxY > Main.maxTilesY)
				dMaxY = Main.maxTilesY;

			num13 = 0;
			num14 = 1000;
			num15 = 0;
			MakeDungeon_Lights(num2, ref num13, num14, ref num15, array);
			num13 = 0;
			num14 = 1000;
			num15 = 0;
			MakeDungeon_Traps(ref num13, num14, ref num15);
			float count = MakeDungeon_GroundFurniture(num3);
			count = MakeDungeon_Pictures(array, count);
			count = MakeDungeon_Banners(array, count);
		}

		private static void MakeDungeon_Traps(ref int failCount, int failMax, ref int numAdd) {
			while (numAdd < Main.maxTilesX / 500) {
				failCount++;
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next(dMinY, dMaxY);
				while ((double)num2 < Main.worldSurface) {
					num2 = genRand.Next(dMinY, dMaxY);
				}

				if (Main.wallDungeon[Main.tile[num, num2].wall] && placeTrap(num, num2, 0))
					failCount = failMax;

				if (failCount > failMax) {
					numAdd++;
					failCount = 0;
				}
			}
			Tile.WireTypeOverride = -1;
		}

		private static void MakeDungeon_Lights(ushort tileType, ref int failCount, int failMax, ref int numAdd, int[] roomWall) {
			int[] array = new int[3] {
				genRand.Next(7),
				genRand.Next(7),
				0
			};

			while (array[1] == array[0]) {
				array[1] = genRand.Next(7);
			}

			array[2] = genRand.Next(7);
			while (array[2] == array[0] || array[2] == array[1]) {
				array[2] = genRand.Next(7);
			}

			while (numAdd < Main.maxTilesX / 150) {
				failCount++;
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next(dMinY, dMaxY);
				if (Main.wallDungeon[Main.tile[num, num2].wall]) {
					for (int num3 = num2; num3 > dMinY; num3--) {
						if (Main.tile[num, num3 - 1].active() && Main.tile[num, num3 - 1].type == tileType) {
							bool flag = false;
							for (int i = num - 15; i < num + 15; i++) {
								for (int j = num3 - 15; j < num3 + 15; j++) {
									if (i > 0 && i < Main.maxTilesX && j > 0 && j < Main.maxTilesY && (Main.tile[i, j].type == 42 || Main.tile[i, j].type == 34)) {
										flag = true;
										break;
									}
								}
							}

							if (Main.tile[num - 1, num3].active() || Main.tile[num + 1, num3].active() || Main.tile[num - 1, num3 + 1].active() || Main.tile[num + 1, num3 + 1].active() || Main.tile[num, num3 + 2].active())
								flag = true;

							if (flag)
								break;

							bool flag2 = false;
							if (!flag2 && genRand.Next(7) == 0) {
								int style = 27;
								switch (roomWall[0]) {
									case 7:
										style = 27;
										break;
									case 8:
										style = 28;
										break;
									case 9:
										style = 29;
										break;
								}

								bool flag3 = false;
								for (int k = 0; k < 15; k++) {
									if (SolidTile(num, num3 + k)) {
										flag3 = true;
										break;
									}
								}

								if (!flag3)
									PlaceChand(num, num3, 34, style);

								if (Main.tile[num, num3].type == 34) {
									flag2 = true;
									failCount = 0;
									numAdd++;
									for (int l = 0; l < 1000; l++) {
										int num4 = num + genRand.Next(-12, 13);
										int num5 = num3 + genRand.Next(3, 21);
										if (Main.tile[num4, num5].active() || Main.tile[num4, num5 + 1].active() || Main.tile[num4 - 1, num5].type == 48 || Main.tile[num4 + 1, num5].type == 48 || !Collision.CanHit(new Vector2(num4 * 16, num5 * 16), 16, 16, new Vector2(num * 16, num3 * 16 + 1), 16, 16))
											continue;

										if ((SolidTile(num4 - 1, num5) && Main.tile[num4 - 1, num5].type != 10) || (SolidTile(num4 + 1, num5) && Main.tile[num4 + 1, num5].type != 10) || SolidTile(num4, num5 + 1))
											PlaceTile(num4, num5, 136, mute: true);

										if (!Main.tile[num4, num5].active())
											continue;

										while (num4 != num || num5 != num3) {
											Main.tile[num4, num5].wire(wire: true);
											if (num4 > num)
												num4--;

											if (num4 < num)
												num4++;

											Main.tile[num4, num5].wire(wire: true);
											if (num5 > num3)
												num5--;

											if (num5 < num3)
												num5++;

											Main.tile[num4, num5].wire(wire: true);
										}

										if (genRand.Next(3) > 0) {
											Main.tile[num, num3].frameX = 18;
											Main.tile[num, num3 + 1].frameX = 18;
										}

										break;
									}
								}
							}

							if (flag2)
								break;

							int style2 = array[0];
							if (Main.tile[num, num3].wall == roomWall[1])
								style2 = array[1];

							if (Main.tile[num, num3].wall == roomWall[2])
								style2 = array[2];

							Place1x2Top(num, num3, 42, style2);
							if (Main.tile[num, num3].type != 42)
								break;

							flag2 = true;
							failCount = 0;
							numAdd++;
							for (int m = 0; m < 1000; m++) {
								int num6 = num + genRand.Next(-12, 13);
								int num7 = num3 + genRand.Next(3, 21);
								if (Main.tile[num6, num7].active() || Main.tile[num6, num7 + 1].active() || Main.tile[num6 - 1, num7].type == 48 || Main.tile[num6 + 1, num7].type == 48 || !Collision.CanHit(new Vector2(num6 * 16, num7 * 16), 16, 16, new Vector2(num * 16, num3 * 16 + 1), 16, 16))
									continue;

								if ((SolidTile(num6 - 1, num7) && Main.tile[num6 - 1, num7].type != 10) || (SolidTile(num6 + 1, num7) && Main.tile[num6 + 1, num7].type != 10) || SolidTile(num6, num7 + 1))
									PlaceTile(num6, num7, 136, mute: true);

								if (!Main.tile[num6, num7].active())
									continue;

								while (num6 != num || num7 != num3) {
									Main.tile[num6, num7].wire(wire: true);
									if (num6 > num)
										num6--;

									if (num6 < num)
										num6++;

									Main.tile[num6, num7].wire(wire: true);
									if (num7 > num3)
										num7--;

									if (num7 < num3)
										num7++;

									Main.tile[num6, num7].wire(wire: true);
								}

								if (genRand.Next(3) > 0) {
									Main.tile[num, num3].frameX = 18;
									Main.tile[num, num3 + 1].frameX = 18;
								}

								break;
							}

							break;
						}
					}
				}

				if (failCount > failMax) {
					numAdd++;
					failCount = 0;
				}
			}
		}

		private static float MakeDungeon_Banners(int[] roomWall, float count) {
			count = 840000f / (float)Main.maxTilesX;
			for (int i = 0; (float)i < count; i++) {
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next(dMinY, dMaxY);
				while (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2].active()) {
					num = genRand.Next(dMinX, dMaxX);
					num2 = genRand.Next(dMinY, dMaxY);
				}

				while (!SolidTile(num, num2) && num2 > 10) {
					num2--;
				}

				num2++;
				if (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2 - 1].type == 48 || Main.tile[num, num2].active() || Main.tile[num, num2 + 1].active() || Main.tile[num, num2 + 2].active() || Main.tile[num, num2 + 3].active())
					continue;

				bool flag = true;
				for (int j = num - 1; j <= num + 1; j++) {
					for (int k = num2; k <= num2 + 3; k++) {
						if (Main.tile[j, k].active() && (Main.tile[j, k].type == 10 || Main.tile[j, k].type == 11 || Main.tile[j, k].type == 91))
							flag = false;
					}
				}

				if (flag) {
					int num3 = 10;
					if (Main.tile[num, num2].wall == roomWall[1])
						num3 = 12;

					if (Main.tile[num, num2].wall == roomWall[2])
						num3 = 14;

					num3 += genRand.Next(2);
					PlaceTile(num, num2, 91, mute: true, forced: false, -1, num3);
				}
			}

			return count;
		}

		private static float MakeDungeon_Pictures(int[] roomWall, float count) {
			count = 420000f / (float)Main.maxTilesX;
			for (int i = 0; (float)i < count; i++) {
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next((int)Main.worldSurface, dMaxY);
				while (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2].active()) {
					num = genRand.Next(dMinX, dMaxX);
					num2 = genRand.Next((int)Main.worldSurface, dMaxY);
				}

				int num3 = num;
				int num4 = num;
				int num5 = num2;
				int num6 = num2;
				int num7 = 0;
				int num8 = 0;
				for (int j = 0; j < 2; j++) {
					num3 = num;
					num4 = num;
					while (!Main.tile[num3, num2].active() && Main.wallDungeon[Main.tile[num3, num2].wall]) {
						num3--;
					}

					num3++;
					for (; !Main.tile[num4, num2].active() && Main.wallDungeon[Main.tile[num4, num2].wall]; num4++) {
					}

					num4--;
					num = (num3 + num4) / 2;
					num5 = num2;
					num6 = num2;
					while (!Main.tile[num, num5].active() && Main.wallDungeon[Main.tile[num, num5].wall]) {
						num5--;
					}

					num5++;
					for (; !Main.tile[num, num6].active() && Main.wallDungeon[Main.tile[num, num6].wall]; num6++) {
					}

					num6--;
					num2 = (num5 + num6) / 2;
				}

				num3 = num;
				num4 = num;
				while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active()) {
					num3--;
				}

				num3++;
				for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++) {
				}

				num4--;
				num5 = num2;
				num6 = num2;
				while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active()) {
					num5--;
				}

				num5++;
				for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++) {
				}

				num6--;
				num = (num3 + num4) / 2;
				num2 = (num5 + num6) / 2;
				num7 = num4 - num3;
				num8 = num6 - num5;
				if (num7 <= 7 || num8 <= 5)
					continue;

				bool[] array = new bool[3] {
					true,
					false,
					false
				};

				if (num7 > num8 * 3 && num7 > 21)
					array[1] = true;

				if (num8 > num7 * 3 && num8 > 21)
					array[2] = true;

				int num9 = genRand.Next(3);
				if (Main.tile[num, num2].wall == roomWall[0])
					num9 = 0;

				while (!array[num9]) {
					num9 = genRand.Next(3);
				}

				if (nearPicture2(num, num2))
					num9 = -1;

				switch (num9) {
					case 0: {
							Vector2 vector2 = randPictureTile();
							if (Main.tile[num, num2].wall != roomWall[0])
								vector2 = randBoneTile();

							int type2 = (int)vector2.X;
							int style2 = (int)vector2.Y;
							if (!nearPicture(num, num2))
								PlaceTile(num, num2, type2, mute: true, forced: false, -1, style2);

							break;
						}
					case 1: {
							Vector2 vector3 = randPictureTile();
							if (Main.tile[num, num2].wall != roomWall[0])
								vector3 = randBoneTile();

							int type3 = (int)vector3.X;
							int style3 = (int)vector3.Y;
							if (!Main.tile[num, num2].active())
								PlaceTile(num, num2, type3, mute: true, forced: false, -1, style3);

							int num13 = num;
							int num14 = num2;
							int num15 = num2;
							for (int m = 0; m < 2; m++) {
								num += 7;
								num5 = num15;
								num6 = num15;
								while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active()) {
									num5--;
								}

								num5++;
								for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++) {
								}

								num6--;
								num15 = (num5 + num6) / 2;
								vector3 = randPictureTile();
								if (Main.tile[num, num15].wall != roomWall[0])
									vector3 = randBoneTile();

								type3 = (int)vector3.X;
								style3 = (int)vector3.Y;
								if (Math.Abs(num14 - num15) >= 4 || nearPicture(num, num15))
									break;

								PlaceTile(num, num15, type3, mute: true, forced: false, -1, style3);
							}

							num15 = num2;
							num = num13;
							for (int n = 0; n < 2; n++) {
								num -= 7;
								num5 = num15;
								num6 = num15;
								while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active()) {
									num5--;
								}

								num5++;
								for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++) {
								}

								num6--;
								num15 = (num5 + num6) / 2;
								vector3 = randPictureTile();
								if (Main.tile[num, num15].wall != roomWall[0])
									vector3 = randBoneTile();

								type3 = (int)vector3.X;
								style3 = (int)vector3.Y;
								if (Math.Abs(num14 - num15) >= 4 || nearPicture(num, num15))
									break;

								PlaceTile(num, num15, type3, mute: true, forced: false, -1, style3);
							}

							break;
						}
					case 2: {
							Vector2 vector = randPictureTile();
							if (Main.tile[num, num2].wall != roomWall[0])
								vector = randBoneTile();

							int type = (int)vector.X;
							int style = (int)vector.Y;
							if (!Main.tile[num, num2].active())
								PlaceTile(num, num2, type, mute: true, forced: false, -1, style);

							int num10 = num2;
							int num11 = num;
							int num12 = num;
							for (int k = 0; k < 3; k++) {
								num2 += 7;
								num3 = num12;
								num4 = num12;
								while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active()) {
									num3--;
								}

								num3++;
								for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++) {
								}

								num4--;
								num12 = (num3 + num4) / 2;
								vector = randPictureTile();
								if (Main.tile[num12, num2].wall != roomWall[0])
									vector = randBoneTile();

								type = (int)vector.X;
								style = (int)vector.Y;
								if (Math.Abs(num11 - num12) >= 4 || nearPicture(num12, num2))
									break;

								PlaceTile(num12, num2, type, mute: true, forced: false, -1, style);
							}

							num12 = num;
							num2 = num10;
							for (int l = 0; l < 3; l++) {
								num2 -= 7;
								num3 = num12;
								num4 = num12;
								while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active()) {
									num3--;
								}

								num3++;
								for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++) {
								}

								num4--;
								num12 = (num3 + num4) / 2;
								vector = randPictureTile();
								if (Main.tile[num12, num2].wall != roomWall[0])
									vector = randBoneTile();

								type = (int)vector.X;
								style = (int)vector.Y;
								if (Math.Abs(num11 - num12) >= 4 || nearPicture(num12, num2))
									break;

								PlaceTile(num12, num2, type, mute: true, forced: false, -1, style);
							}

							break;
						}
				}
			}

			return count;
		}

		private static float MakeDungeon_GroundFurniture(int wallType) {
			float num = 2000f * (float)Main.maxTilesX / 4200f;
			int num2 = 1 + Main.maxTilesX / 4200;
			int num3 = 1 + Main.maxTilesX / 4200;
			for (int i = 0; (float)i < num; i++) {
				if (num2 > 0 || num3 > 0)
					i--;

				int num4 = genRand.Next(dMinX, dMaxX);
				int j = genRand.Next((int)Main.worldSurface + 10, dMaxY);
				while (!Main.wallDungeon[Main.tile[num4, j].wall] || Main.tile[num4, j].active()) {
					num4 = genRand.Next(dMinX, dMaxX);
					j = genRand.Next((int)Main.worldSurface + 10, dMaxY);
				}

				if (!Main.wallDungeon[Main.tile[num4, j].wall] || Main.tile[num4, j].active())
					continue;

				for (; !SolidTile(num4, j) && j < Main.maxTilesY - 200; j++) {
				}

				j--;
				int num5 = num4;
				int k = num4;
				while (!Main.tile[num5, j].active() && SolidTile(num5, j + 1)) {
					num5--;
				}

				num5++;
				for (; !Main.tile[k, j].active() && SolidTile(k, j + 1); k++) {
				}

				k--;
				int num6 = k - num5;
				int num7 = (k + num5) / 2;
				if (Main.tile[num7, j].active() || !Main.wallDungeon[Main.tile[num7, j].wall] || !SolidTile(num7, j + 1) || Main.tile[num7, j + 1].type == 48)
					continue;

				int style = 13;
				int style2 = 10;
				int style3 = 11;
				int num8 = 1;
				int num9 = 46;
				int style4 = 1;
				int num10 = 5;
				int num11 = 11;
				int num12 = 5;
				int num13 = 6;
				int num14 = 21;
				int num15 = 22;
				int num16 = 24;
				int num17 = 30;
				switch (wallType) {
					case 8:
						style = 14;
						style2 = 11;
						style3 = 12;
						num8 = 2;
						num9 = 47;
						style4 = 2;
						num10 = 6;
						num11 = 12;
						num12 = 6;
						num13 = 7;
						num14 = 22;
						num15 = 23;
						num16 = 25;
						num17 = 31;
						break;
					case 9:
						style = 15;
						style2 = 12;
						style3 = 13;
						num8 = 3;
						num9 = 48;
						style4 = 3;
						num10 = 7;
						num11 = 13;
						num12 = 7;
						num13 = 8;
						num14 = 23;
						num15 = 24;
						num16 = 26;
						num17 = 32;
						break;
				}

				if (Main.tile[num7, j].wall >= 94 && Main.tile[num7, j].wall <= 105) {
					style = 17;
					style2 = 14;
					style3 = 15;
					num8 = -1;
					num9 = -1;
					style4 = 5;
					num10 = -1;
					num11 = -1;
					num12 = -1;
					num13 = -1;
					num14 = -1;
					num15 = -1;
					num16 = -1;
					num17 = -1;
				}

				int num18 = genRand.Next(13);
				if ((num18 == 10 || num18 == 11 || num18 == 12) && genRand.Next(4) != 0)
					num18 = genRand.Next(13);

				while ((num18 == 2 && num9 == -1) || (num18 == 5 && num10 == -1) || (num18 == 6 && num11 == -1) || (num18 == 7 && num12 == -1) || (num18 == 8 && num13 == -1) || (num18 == 9 && num14 == -1) || (num18 == 10 && num15 == -1) || (num18 == 11 && num16 == -1) || (num18 == 12 && num17 == -1)) {
					num18 = genRand.Next(13);
				}

				int num19 = 0;
				int num20 = 0;
				if (num18 == 0) {
					num19 = 5;
					num20 = 4;
				}

				if (num18 == 1) {
					num19 = 4;
					num20 = 3;
				}

				if (num18 == 2) {
					num19 = 3;
					num20 = 5;
				}

				if (num18 == 3) {
					num19 = 4;
					num20 = 6;
				}

				if (num18 == 4) {
					num19 = 3;
					num20 = 3;
				}

				if (num18 == 5) {
					num19 = 5;
					num20 = 3;
				}

				if (num18 == 6) {
					num19 = 5;
					num20 = 4;
				}

				if (num18 == 7) {
					num19 = 5;
					num20 = 4;
				}

				if (num18 == 8) {
					num19 = 5;
					num20 = 4;
				}

				if (num18 == 9) {
					num19 = 5;
					num20 = 3;
				}

				if (num18 == 10) {
					num19 = 2;
					num20 = 4;
				}

				if (num18 == 11) {
					num19 = 3;
					num20 = 3;
				}

				if (num18 == 12) {
					num19 = 2;
					num20 = 5;
				}

				for (int l = num7 - num19; l <= num7 + num19; l++) {
					for (int m = j - num20; m <= j; m++) {
						if (Main.tile[l, m].active()) {
							num18 = -1;
							break;
						}
					}
				}

				if ((double)num6 < (double)num19 * 1.75)
					num18 = -1;

				if (num2 > 0 || num3 > 0) {
					if (num2 > 0) {
						PlaceTile(num7, j, 355, mute: true);
						if (Main.tile[num7, j].type == 355)
							num2--;
					}
					else if (num3 > 0) {
						PlaceTile(num7, j, 354, mute: true);
						if (Main.tile[num7, j].type == 354)
							num3--;
					}

					continue;
				}

				switch (num18) {
					case 0: {
							PlaceTile(num7, j, 14, mute: true, forced: false, -1, style2);
							if (Main.tile[num7, j].active()) {
								if (!Main.tile[num7 - 2, j].active()) {
									PlaceTile(num7 - 2, j, 15, mute: true, forced: false, -1, style);
									if (Main.tile[num7 - 2, j].active()) {
										Main.tile[num7 - 2, j].frameX += 18;
										Main.tile[num7 - 2, j - 1].frameX += 18;
									}
								}

								if (!Main.tile[num7 + 2, j].active())
									PlaceTile(num7 + 2, j, 15, mute: true, forced: false, -1, style);
							}

							for (int num22 = num7 - 1; num22 <= num7 + 1; num22++) {
								if (genRand.Next(2) == 0 && !Main.tile[num22, j - 2].active()) {
									int num23 = genRand.Next(5);
									if (num8 != -1 && num23 <= 1 && !Main.tileLighted[Main.tile[num22 - 1, j - 2].type])
										PlaceTile(num22, j - 2, 33, mute: true, forced: false, -1, num8);

									if (num23 == 2 && !Main.tileLighted[Main.tile[num22 - 1, j - 2].type])
										PlaceTile(num22, j - 2, 49, mute: true);

									if (num23 == 3)
										PlaceTile(num22, j - 2, 50, mute: true);

									if (num23 == 4)
										PlaceTile(num22, j - 2, 103, mute: true);
								}
							}

							break;
						}
					case 1: {
							PlaceTile(num7, j, 18, mute: true, forced: false, -1, style3);
							if (!Main.tile[num7, j].active())
								break;

							if (genRand.Next(2) == 0) {
								if (!Main.tile[num7 - 1, j].active()) {
									PlaceTile(num7 - 1, j, 15, mute: true, forced: false, -1, style);
									if (Main.tile[num7 - 1, j].active()) {
										Main.tile[num7 - 1, j].frameX += 18;
										Main.tile[num7 - 1, j - 1].frameX += 18;
									}
								}
							}
							else if (!Main.tile[num7 + 2, j].active()) {
								PlaceTile(num7 + 2, j, 15, mute: true, forced: false, -1, style);
							}

							for (int n = num7; n <= num7 + 1; n++) {
								if (genRand.Next(2) == 0 && !Main.tile[n, j - 1].active()) {
									int num21 = genRand.Next(5);
									if (num8 != -1 && num21 <= 1 && !Main.tileLighted[Main.tile[n - 1, j - 1].type])
										PlaceTile(n, j - 1, 33, mute: true, forced: false, -1, num8);

									if (num21 == 2 && !Main.tileLighted[Main.tile[n - 1, j - 1].type])
										PlaceTile(n, j - 1, 49, mute: true);

									if (num21 == 3)
										PlaceTile(n, j - 1, 50, mute: true);

									if (num21 == 4)
										PlaceTile(n, j - 1, 103, mute: true);
								}
							}

							break;
						}
					case 2:
						PlaceTile(num7, j, 105, mute: true, forced: false, -1, num9);
						break;
					case 3:
						PlaceTile(num7, j, 101, mute: true, forced: false, -1, style4);
						break;
					case 4:
						if (genRand.Next(2) == 0) {
							PlaceTile(num7, j, 15, mute: true, forced: false, -1, style);
							Main.tile[num7, j].frameX += 18;
							Main.tile[num7, j - 1].frameX += 18;
						}
						else {
							PlaceTile(num7, j, 15, mute: true, forced: false, -1, style);
						}
						break;
					case 5:
						if (genRand.Next(2) == 0)
							Place4x2(num7, j, 79, 1, num10);
						else
							Place4x2(num7, j, 79, -1, num10);
						break;
					case 6:
						PlaceTile(num7, j, 87, mute: true, forced: false, -1, num11);
						break;
					case 7:
						PlaceTile(num7, j, 88, mute: true, forced: false, -1, num12);
						break;
					case 8:
						PlaceTile(num7, j, 89, mute: true, forced: false, -1, num13);
						break;
					case 9:
						if (genRand.Next(2) == 0)
							Place4x2(num7, j, 90, 1, num14);
						else
							Place4x2(num7, j, 90, -1, num14);
						break;
					case 10:
						PlaceTile(num7, j, 93, mute: true, forced: false, -1, num16);
						break;
					case 11:
						PlaceTile(num7, j, 100, mute: true, forced: false, -1, num15);
						break;
					case 12:
						PlaceTile(num7, j, 104, mute: true, forced: false, -1, num17);
						break;
				}
			}

			return num;
		}

		public static Vector2 randBoneTile() {
			int num = genRand.Next(2);
			int num2 = 0;
			switch (num) {
				case 0:
					num = 240;
					num2 = genRand.Next(2);
					switch (num2) {
						case 0:
							num2 = 16;
							break;
						case 1:
							num2 = 17;
							break;
					}
					break;
				case 1:
					num = 241;
					num2 = genRand.Next(9);
					break;
			}

			return new Vector2(num, num2);
		}

		public static Vector2 randHellPicture() {
			int num = genRand.Next(4);
			int num2 = 0;
			if (num == 1)
				num = genRand.Next(4);

			switch (num) {
				case 0:
					num = 240;
					num2 = genRand.Next(5);
					switch (num2) {
						case 0:
							num2 = 27;
							break;
						case 1:
							num2 = 29;
							break;
						case 2:
							num2 = 30;
							break;
						case 3:
							num2 = 31;
							break;
						case 4:
							num2 = 32;
							break;
					}
					break;
				case 1:
					num = 242;
					num2 = 14;
					break;
				case 2:
					num = 245;
					num2 = genRand.Next(3);
					switch (num2) {
						case 0:
							num2 = 1;
							break;
						case 1:
							num2 = 2;
							break;
						case 2:
							num2 = 4;
							break;
					}
					break;
				default:
					num = 246;
					num2 = genRand.Next(3);
					switch (num2) {
						case 0:
							num2 = 0;
							break;
						case 1:
							num2 = 16;
							break;
						case 2:
							num2 = 17;
							break;
					}
					break;
			}

			return new Vector2(num, num2);
		}

		public static Vector2 randHousePicture() {
			int num = genRand.Next(4);
			int num2 = 0;
			if (num <= 1) {
				num = 240;
				int maxValue = 10;
				num2 = genRand.Next(maxValue);
				if (num2 == 9)
					num2 = genRand.Next(maxValue);

				if (num2 == 5)
					num2 = genRand.Next(maxValue);

				if (num2 == 6)
					num2 = genRand.Next(maxValue);

				switch (num2) {
					case 0:
						num2 = 26;
						break;
					case 1:
						num2 = 28;
						break;
					case 2:
						num2 = 20;
						break;
					case 3:
						num2 = 21;
						break;
					case 4:
						num2 = 22;
						break;
					case 5:
						num2 = 24;
						break;
					case 6:
						num2 = 25;
						break;
					case 7:
						num2 = 33;
						break;
					case 8:
						num2 = 34;
						break;
					case 9:
						num2 = 35;
						break;
				}
			}
			else if (num == 2) {
				int maxValue2 = 4;
				num = 245;
				num2 = genRand.Next(maxValue2);
				if (num2 == 2)
					num2 = genRand.Next(maxValue2);

				if (num2 == 0)
					num2 = genRand.Next(maxValue2);

				if (num2 == 0)
					num2 = genRand.Next(maxValue2);

				if (num2 == 0)
					num2 = genRand.Next(maxValue2);

				switch (num2) {
					case 0:
						num2 = 0;
						break;
					case 1:
						num2 = 3;
						break;
					case 2:
						num2 = 5;
						break;
					case 3:
						num2 = 6;
						break;
				}
			}
			else {
				num = 246;
				num2 = 1;
			}

			return new Vector2(num, num2);
		}

		public static Vector2 randPictureTile() {
			int num = genRand.Next(3);
			int num2 = 0;
			if (num <= 1) {
				int maxValue = 7;
				num = 240;
				num2 = genRand.Next(maxValue);
				if (num2 == 6)
					num2 = genRand.Next(maxValue);

				switch (num2) {
					case 0:
						num2 = 12;
						break;
					case 1:
						num2 = 13;
						break;
					case 2:
						num2 = 14;
						break;
					case 3:
						num2 = 15;
						break;
					case 4:
						num2 = 18;
						break;
					case 5:
						num2 = 19;
						break;
					case 6:
						num2 = 23;
						break;
				}
			}
			else if (num == 2) {
				num = 242;
				int maxValue2 = 17;
				num2 = genRand.Next(maxValue2);
				switch (num2) {
					case 14:
						num2 = 15;
						break;
					case 15:
						num2 = 16;
						break;
					case 16:
						num2 = 30;
						break;
				}
			}

			return new Vector2(num, num2);
		}

		public static void DungeonStairs(int i, int j, ushort tileType, int wallType) {
			Vector2 zero = Vector2.Zero;
			double num = genRand.Next(5, 9);
			int num2 = 1;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num3 = genRand.Next(10, 30);
			num2 = ((i <= dEnteranceX) ? 1 : (-1));
			if (i > Main.maxTilesX - 400)
				num2 = -1;
			else if (i < 400)
				num2 = 1;

			zero.Y = -1f;
			zero.X = num2;
			if (genRand.Next(3) != 0)
				zero.X *= 1f + (float)genRand.Next(0, 200) * 0.01f;
			else if (genRand.Next(3) == 0)
				zero.X *= (float)genRand.Next(50, 76) * 0.01f;
			else if (genRand.Next(6) == 0)
				zero.Y *= 2f;

			if (dungeonX < Main.maxTilesX / 2 && zero.X < 0f && (double)zero.X < 0.5)
				zero.X = -0.5f;

			if (dungeonX > Main.maxTilesX / 2 && zero.X > 0f && (double)zero.X > 0.5)
				zero.X = -0.5f;

			while (num3 > 0) {
				num3--;
				int num4 = (int)((double)vector.X - num - 4.0 - (double)genRand.Next(6));
				int num5 = (int)((double)vector.X + num + 4.0 + (double)genRand.Next(6));
				int num6 = (int)((double)vector.Y - num - 4.0);
				int num7 = (int)((double)vector.Y + num + 4.0 + (double)genRand.Next(6));
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				int num8 = 1;
				if (vector.X > (float)(Main.maxTilesX / 2))
					num8 = -1;

				int num9 = (int)(vector.X + (float)dxStrength1 * 0.6f * (float)num8 + (float)dxStrength2 * (float)num8);
				int num10 = (int)(dyStrength2 * 0.5);
				if ((double)vector.Y < Main.worldSurface - 5.0 && Main.tile[num9, (int)((double)vector.Y - num - 6.0 + (double)num10)].wall == 0 && Main.tile[num9, (int)((double)vector.Y - num - 7.0 + (double)num10)].wall == 0 && Main.tile[num9, (int)((double)vector.Y - num - 8.0 + (double)num10)].wall == 0) {
					dSurface = true;
					TileRunner(num9, (int)((double)vector.Y - num - 6.0 + (double)num10), genRand.Next(25, 35), genRand.Next(10, 20), -1, addTile: false, 0f, -1f);
				}

				for (int k = num4; k < num5; k++) {
					for (int l = num6; l < num7; l++) {
						Main.tile[k, l].liquid = 0;
						if (!Main.wallDungeon[Main.tile[k, l].wall]) {
							Main.tile[k, l].wall = 0;
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = tileType;
						}
					}
				}

				for (int m = num4 + 1; m < num5 - 1; m++) {
					for (int n = num6 + 1; n < num7 - 1; n++) {
						Main.tile[m, n].wall = (byte)wallType;
					}
				}

				int num11 = 0;
				if (genRand.Next((int)num) == 0)
					num11 = genRand.Next(1, 3);

				num4 = (int)((double)vector.X - num * 0.5 - (double)num11);
				num5 = (int)((double)vector.X + num * 0.5 + (double)num11);
				num6 = (int)((double)vector.Y - num * 0.5 - (double)num11);
				num7 = (int)((double)vector.Y + num * 0.5 + (double)num11);
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				for (int num12 = num4; num12 < num5; num12++) {
					for (int num13 = num6; num13 < num7; num13++) {
						Main.tile[num12, num13].active(active: false);
						PlaceWall(num12, num13, wallType, mute: true);
					}
				}

				if (dSurface)
					num3 = 0;

				vector += zero;
				if ((double)vector.Y < Main.worldSurface)
					zero.Y *= 0.98f;
			}

			dungeonX = (int)vector.X;
			dungeonY = (int)vector.Y;
		}

		public static void DungeonHalls(int i, int j, ushort tileType, int wallType, bool forceX = false) {
			Vector2 zero = Vector2.Zero;
			double num = genRand.Next(4, 6);
			double num2 = num;
			Vector2 zero2 = Vector2.Zero;
			Vector2 zero3 = Vector2.Zero;
			int num3 = 1;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num4 = genRand.Next(35, 80);
			if (forceX) {
				num4 += 20;
				lastDungeonHall = Vector2.Zero;
			}
			else if (genRand.Next(5) == 0) {
				num *= 2.0;
				num4 /= 2;
			}

			bool flag = false;
			bool flag2 = false;
			bool flag3 = true;
			bool flag4 = false;
			while (!flag) {
				flag4 = false;
				if (flag3 && !forceX) {
					bool flag5 = true;
					bool flag6 = true;
					bool flag7 = true;
					bool flag8 = true;
					int num5 = num4;
					bool flag9 = false;
					for (int num6 = j; num6 > j - num5; num6--) {
						if (InWorld(i, num6) && Main.tile[i, num6].wall == wallType) {
							if (flag9) {
								flag5 = false;
								break;
							}
						}
						else {
							flag9 = true;
						}
					}

					flag9 = false;
					for (int k = j; k < j + num5; k++) {
						if (Main.tile[i, k].wall == wallType) {
							if (flag9) {
								flag6 = false;
								break;
							}
						}
						else {
							flag9 = true;
						}
					}

					flag9 = false;
					for (int num7 = i; num7 > i - num5; num7--) {
						if (Main.tile[num7, j].wall == wallType) {
							if (flag9) {
								flag7 = false;
								break;
							}
						}
						else {
							flag9 = true;
						}
					}

					flag9 = false;
					for (int l = i; l < i + num5; l++) {
						if (Main.tile[l, j].wall == wallType) {
							if (flag9) {
								flag8 = false;
								break;
							}
						}
						else {
							flag9 = true;
						}
					}

					if (!flag7 && !flag8 && !flag5 && !flag6) {
						num3 = ((genRand.Next(2) != 0) ? 1 : (-1));
						if (genRand.Next(2) == 0)
							flag4 = true;
					}
					else {
						int num8 = genRand.Next(4);
						do {
							num8 = genRand.Next(4);
						} while (!(num8 == 0 && flag5) && !(num8 == 1 && flag6) && !(num8 == 2 && flag7) && !(num8 == 3 && flag8));

						switch (num8) {
							case 0:
								num3 = -1;
								break;
							case 1:
								num3 = 1;
								break;
							default:
								flag4 = true;
								num3 = ((num8 != 2) ? 1 : (-1));
								break;
						}
					}
				}
				else {
					num3 = ((genRand.Next(2) != 0) ? 1 : (-1));
					if (genRand.Next(2) == 0)
						flag4 = true;
				}

				flag3 = false;
				if (forceX)
					flag4 = true;

				if (flag4) {
					zero2.Y = 0f;
					zero2.X = num3;
					zero3.Y = 0f;
					zero3.X = -num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0) {
						if (genRand.Next(2) == 0)
							zero.Y = -0.2f;
						else
							zero.Y = 0.2f;
					}
				}
				else {
					num += 1.0;
					zero.Y = num3;
					zero.X = 0f;
					zero2.X = 0f;
					zero2.Y = num3;
					zero3.X = 0f;
					zero3.Y = -num3;
					if (genRand.Next(3) != 0) {
						flag2 = true;
						if (genRand.Next(2) == 0)
							zero.X = (float)genRand.Next(10, 20) * 0.1f;
						else
							zero.X = (float)(-genRand.Next(10, 20)) * 0.1f;
					}
					else if (genRand.Next(2) == 0) {
						if (genRand.Next(2) == 0)
							zero.X = (float)genRand.Next(20, 40) * 0.01f;
						else
							zero.X = (float)(-genRand.Next(20, 40)) * 0.01f;
					}
					else {
						num4 /= 2;
					}
				}

				if (lastDungeonHall != zero3)
					flag = true;
			}

			int num9 = 0;
			if (!forceX) {
				if (vector.X > (float)(lastMaxTilesX - 200)) {
					num3 = -1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0) {
						if (genRand.Next(2) == 0)
							zero.Y = -0.2f;
						else
							zero.Y = 0.2f;
					}
				}
				else if (vector.X < 200f) {
					num3 = 1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0) {
						if (genRand.Next(2) == 0)
							zero.Y = -0.2f;
						else
							zero.Y = 0.2f;
					}
				}
				else if (vector.Y > (float)(lastMaxTilesY - 300)) {
					num3 = -1;
					num += 1.0;
					zero.Y = num3;
					zero.X = 0f;
					zero2.X = 0f;
					zero2.Y = num3;
					if (genRand.Next(2) == 0) {
						if (genRand.Next(2) == 0)
							zero.X = (float)genRand.Next(20, 50) * 0.01f;
						else
							zero.X = (float)(-genRand.Next(20, 50)) * 0.01f;
					}
				}
				else if ((double)vector.Y < Main.rockLayer + 100.0) {
					num3 = 1;
					num += 1.0;
					zero.Y = num3;
					zero.X = 0f;
					zero2.X = 0f;
					zero2.Y = num3;
					if (genRand.Next(3) != 0) {
						flag2 = true;
						if (genRand.Next(2) == 0)
							zero.X = (float)genRand.Next(10, 20) * 0.1f;
						else
							zero.X = (float)(-genRand.Next(10, 20)) * 0.1f;
					}
					else if (genRand.Next(2) == 0) {
						if (genRand.Next(2) == 0)
							zero.X = (float)genRand.Next(20, 50) * 0.01f;
						else
							zero.X = (float)genRand.Next(20, 50) * 0.01f;
					}
				}
				else if (vector.X < (float)(Main.maxTilesX / 2) && (double)vector.X > (double)Main.maxTilesX * 0.25) {
					num3 = -1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0) {
						if (genRand.Next(2) == 0)
							zero.Y = -0.2f;
						else
							zero.Y = 0.2f;
					}
				}
				else if (vector.X > (float)(Main.maxTilesX / 2) && (double)vector.X < (double)Main.maxTilesX * 0.75) {
					num3 = 1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0) {
						if (genRand.Next(2) == 0)
							zero.Y = -0.2f;
						else
							zero.Y = 0.2f;
					}
				}
			}

			if (zero2.Y == 0f) {
				DDoorX[numDDoors] = (int)vector.X;
				DDoorY[numDDoors] = (int)vector.Y;
				DDoorPos[numDDoors] = 0;
				numDDoors++;
			}
			else {
				DPlatX[numDPlats] = (int)vector.X;
				DPlatY[numDPlats] = (int)vector.Y;
				numDPlats++;
			}

			lastDungeonHall = zero2;
			if (Math.Abs(zero.X) > Math.Abs(zero.Y) && genRand.Next(3) != 0)
				num = (int)((double)(float)num2 * ((double)genRand.Next(110, 150) * 0.01));

			while (num4 > 0) {
				num9++;
				if (zero2.X > 0f && vector.X > (float)(Main.maxTilesX - 100))
					num4 = 0;
				else if (zero2.X < 0f && vector.X < 100f)
					num4 = 0;
				else if (zero2.Y > 0f && vector.Y > (float)(Main.maxTilesY - 100))
					num4 = 0;
				else if (zero2.Y < 0f && (double)vector.Y < Main.rockLayer + 50.0)
					num4 = 0;

				num4--;
				int num10 = (int)((double)vector.X - num - 4.0 - (double)genRand.Next(6));
				int num11 = (int)((double)vector.X + num + 4.0 + (double)genRand.Next(6));
				int num12 = (int)((double)vector.Y - num - 4.0 - (double)genRand.Next(6));
				int num13 = (int)((double)vector.Y + num + 4.0 + (double)genRand.Next(6));
				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesX)
					num11 = Main.maxTilesX;

				if (num12 < 0)
					num12 = 0;

				if (num13 > Main.maxTilesY)
					num13 = Main.maxTilesY;

				for (int m = num10; m < num11; m++) {
					for (int n = num12; n < num13; n++) {
						if (m < dMinX)
							dMinX = m;

						if (m > dMaxX)
							dMaxX = m;

						if (n > dMaxY)
							dMaxY = n;

						Main.tile[m, n].liquid = 0;
						if (!Main.wallDungeon[Main.tile[m, n].wall]) {
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = tileType;
						}
					}
				}

				for (int num14 = num10 + 1; num14 < num11 - 1; num14++) {
					for (int num15 = num12 + 1; num15 < num13 - 1; num15++) {
						Main.tile[num14, num15].wall = (byte)wallType;
					}
				}

				int num16 = 0;
				if (zero.Y == 0f && genRand.Next((int)num + 1) == 0)
					num16 = genRand.Next(1, 3);
				else if (zero.X == 0f && genRand.Next((int)num - 1) == 0)
					num16 = genRand.Next(1, 3);
				else if (genRand.Next((int)num * 3) == 0)
					num16 = genRand.Next(1, 3);

				num10 = (int)((double)vector.X - num * 0.5 - (double)num16);
				num11 = (int)((double)vector.X + num * 0.5 + (double)num16);
				num12 = (int)((double)vector.Y - num * 0.5 - (double)num16);
				num13 = (int)((double)vector.Y + num * 0.5 + (double)num16);
				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesX)
					num11 = Main.maxTilesX;

				if (num12 < 0)
					num12 = 0;

				if (num13 > Main.maxTilesY)
					num13 = Main.maxTilesY;

				for (int num17 = num10; num17 < num11; num17++) {
					for (int num18 = num12; num18 < num13; num18++) {
						Main.tile[num17, num18].active(active: false);
						Main.tile[num17, num18].wall = (byte)wallType;
					}
				}

				vector += zero;
				if (flag2 && num9 > genRand.Next(10, 20)) {
					num9 = 0;
					zero.X *= -1f;
				}
			}

			dungeonX = (int)vector.X;
			dungeonY = (int)vector.Y;
			if (zero2.Y == 0f) {
				DDoorX[numDDoors] = (int)vector.X;
				DDoorY[numDDoors] = (int)vector.Y;
				DDoorPos[numDDoors] = 0;
				numDDoors++;
			}
			else {
				DPlatX[numDPlats] = (int)vector.X;
				DPlatY[numDPlats] = (int)vector.Y;
				numDPlats++;
			}
		}

		public static void DungeonRoom(int i, int j, ushort tileType, int wallType) {
			double num = genRand.Next(15, 30);
			Vector2 vector = default(Vector2);
			vector.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector.Y = (float)genRand.Next(-10, 11) * 0.1f;
			Vector2 vector2 = default(Vector2);
			vector2.X = i;
			vector2.Y = (float)j - (float)num / 2f;
			int num2 = genRand.Next(10, 20);
			double num3 = vector2.X;
			double num4 = vector2.X;
			double num5 = vector2.Y;
			double num6 = vector2.Y;
			while (num2 > 0) {
				num2--;
				int num7 = (int)((double)vector2.X - num * 0.800000011920929 - 5.0);
				int num8 = (int)((double)vector2.X + num * 0.800000011920929 + 5.0);
				int num9 = (int)((double)vector2.Y - num * 0.800000011920929 - 5.0);
				int num10 = (int)((double)vector2.Y + num * 0.800000011920929 + 5.0);
				if (num7 < 0)
					num7 = 0;

				if (num8 > Main.maxTilesX)
					num8 = Main.maxTilesX;

				if (num9 < 0)
					num9 = 0;

				if (num10 > Main.maxTilesY)
					num10 = Main.maxTilesY;

				for (int k = num7; k < num8; k++) {
					for (int l = num9; l < num10; l++) {
						if (k < dMinX)
							dMinX = k;

						if (k > dMaxX)
							dMaxX = k;

						if (l > dMaxY)
							dMaxY = l;

						Main.tile[k, l].liquid = 0;
						if (!Main.wallDungeon[Main.tile[k, l].wall]) {
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = tileType;
						}
					}
				}

				for (int m = num7 + 1; m < num8 - 1; m++) {
					for (int n = num9 + 1; n < num10 - 1; n++) {
						Main.tile[m, n].wall = (byte)wallType;
					}
				}

				num7 = (int)((double)vector2.X - num * 0.5);
				num8 = (int)((double)vector2.X + num * 0.5);
				num9 = (int)((double)vector2.Y - num * 0.5);
				num10 = (int)((double)vector2.Y + num * 0.5);
				if (num7 < 0)
					num7 = 0;

				if (num8 > Main.maxTilesX)
					num8 = Main.maxTilesX;

				if (num9 < 0)
					num9 = 0;

				if (num10 > Main.maxTilesY)
					num10 = Main.maxTilesY;

				if ((double)num7 < num3)
					num3 = num7;

				if ((double)num8 > num4)
					num4 = num8;

				if ((double)num9 < num5)
					num5 = num9;

				if ((double)num10 > num6)
					num6 = num10;

				for (int num11 = num7; num11 < num8; num11++) {
					for (int num12 = num9; num12 < num10; num12++) {
						Main.tile[num11, num12].active(active: false);
						Main.tile[num11, num12].wall = (byte)wallType;
					}
				}

				vector2 += vector;
				vector.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector.X > 1f)
					vector.X = 1f;

				if (vector.X < -1f)
					vector.X = -1f;

				if (vector.Y > 1f)
					vector.Y = 1f;

				if (vector.Y < -1f)
					vector.Y = -1f;
			}

			dRoomX[numDRooms] = (int)vector2.X;
			dRoomY[numDRooms] = (int)vector2.Y;
			dRoomSize[numDRooms] = (int)num;
			dRoomL[numDRooms] = (int)num3;
			dRoomR[numDRooms] = (int)num4;
			dRoomT[numDRooms] = (int)num5;
			dRoomB[numDRooms] = (int)num6;
			dRoomTreasure[numDRooms] = false;
			numDRooms++;
		}

		public static void DungeonEnt(int i, int j, ushort tileType, int wallType) {
			int num = 60;
			for (int k = i - num; k < i + num; k++) {
				for (int l = j - num; l < j + num; l++) {
					Main.tile[k, l].liquid = 0;
					Main.tile[k, l].lava(lava: false);
				}
			}

			double num2 = dxStrength1;
			double num3 = dyStrength1;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j - (float)num3 / 2f;
			dMinY = (int)vector.Y;
			int num4 = 1;
			if (i > Main.maxTilesX / 2)
				num4 = -1;

			int num5 = (int)((double)vector.X - num2 * 0.6000000238418579 - (double)genRand.Next(2, 5));
			int num6 = (int)((double)vector.X + num2 * 0.6000000238418579 + (double)genRand.Next(2, 5));
			int num7 = (int)((double)vector.Y - num3 * 0.6000000238418579 - (double)genRand.Next(2, 5));
			int num8 = (int)((double)vector.Y + num3 * 0.6000000238418579 + (double)genRand.Next(8, 16));
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int m = num5; m < num6; m++) {
				for (int n = num7; n < num8; n++) {
					Main.tile[m, n].liquid = 0;
					if (Main.tile[m, n].wall != wallType) {
						Main.tile[m, n].wall = 0;
						if (m > num5 + 1 && m < num6 - 2 && n > num7 + 1 && n < num8 - 2)
							Main.tile[m, n].wall = (byte)wallType;

						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = tileType;
					}
				}
			}

			int num9 = num5;
			int num10 = num5 + 5 + genRand.Next(4);
			int num11 = num7 - 3 - genRand.Next(3);
			int num12 = num7;
			for (int num13 = num9; num13 < num10; num13++) {
				for (int num14 = num11; num14 < num12; num14++) {
					if (Main.tile[num13, num14].wall != wallType) {
						Main.tile[num13, num14].active(active: true);
						Main.tile[num13, num14].type = tileType;
					}
				}
			}

			num9 = num6 - 5 - genRand.Next(4);
			num10 = num6;
			num11 = num7 - 3 - genRand.Next(3);
			num12 = num7;
			for (int num15 = num9; num15 < num10; num15++) {
				for (int num16 = num11; num16 < num12; num16++) {
					if (Main.tile[num15, num16].wall != wallType) {
						Main.tile[num15, num16].active(active: true);
						Main.tile[num15, num16].type = tileType;
					}
				}
			}

			int num17 = 1 + genRand.Next(2);
			int num18 = 2 + genRand.Next(4);
			int num19 = 0;
			for (int num20 = num5; num20 < num6; num20++) {
				for (int num21 = num7 - num17; num21 < num7; num21++) {
					if (Main.tile[num20, num21].wall != wallType) {
						Main.tile[num20, num21].active(active: true);
						Main.tile[num20, num21].type = tileType;
					}
				}

				num19++;
				if (num19 >= num18) {
					num20 += num18;
					num19 = 0;
				}
			}

			for (int num22 = num5; num22 < num6; num22++) {
				for (int num23 = num8; (double)num23 < Main.worldSurface; num23++) {
					if (!Main.wallDungeon[Main.tile[num22, num23].wall]) {
						Main.tile[num22, num23].active(active: true);
						Main.tile[num22, num23].type = tileType;
					}

					Main.tile[num22, num23].wall = (byte)wallType;
				}
			}

			num5 = (int)((double)vector.X - num2 * 0.6000000238418579);
			num6 = (int)((double)vector.X + num2 * 0.6000000238418579);
			num7 = (int)((double)vector.Y - num3 * 0.6000000238418579);
			num8 = (int)((double)vector.Y + num3 * 0.6000000238418579);
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int num24 = num5; num24 < num6; num24++) {
				for (int num25 = num7; num25 < num8; num25++) {
					Main.tile[num24, num25].wall = (byte)wallType;
				}
			}

			num5 = (int)((double)vector.X - num2 * 0.6 - 1.0);
			num6 = (int)((double)vector.X + num2 * 0.6 + 1.0);
			num7 = (int)((double)vector.Y - num3 * 0.6 - 1.0);
			num8 = (int)((double)vector.Y + num3 * 0.6 + 1.0);
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int num26 = num5; num26 < num6; num26++) {
				for (int num27 = num7; num27 < num8; num27++) {
					Main.tile[num26, num27].wall = (byte)wallType;
				}
			}

			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num7 = (int)((double)vector.Y - num3 * 0.5);
			num8 = (int)((double)vector.Y + num3 * 0.5);
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int num28 = num5; num28 < num6; num28++) {
				for (int num29 = num7; num29 < num8; num29++) {
					Main.tile[num28, num29].active(active: false);
					Main.tile[num28, num29].wall = (byte)wallType;
				}
			}

			int num30 = (int)vector.X;
			int num31 = num8;
			for (int num32 = 0; num32 < 20; num32++) {
				num30 = (int)vector.X - num32;
				if (!Main.tile[num30, num31].active() && Main.wallDungeon[Main.tile[num30, num31].wall]) {
					DPlatX[numDPlats] = num30;
					DPlatY[numDPlats] = num31;
					numDPlats++;
					break;
				}

				num30 = (int)vector.X + num32;
				if (!Main.tile[num30, num31].active() && Main.wallDungeon[Main.tile[num30, num31].wall]) {
					DPlatX[numDPlats] = num30;
					DPlatY[numDPlats] = num31;
					numDPlats++;
					break;
				}
			}

			vector.X += (float)num2 * 0.6f * (float)num4;
			vector.Y += (float)num3 * 0.5f;
			num2 = dxStrength2;
			num3 = dyStrength2;
			vector.X += (float)num2 * 0.55f * (float)num4;
			vector.Y -= (float)num3 * 0.5f;
			num5 = (int)((double)vector.X - num2 * 0.6000000238418579 - (double)genRand.Next(1, 3));
			num6 = (int)((double)vector.X + num2 * 0.6000000238418579 + (double)genRand.Next(1, 3));
			num7 = (int)((double)vector.Y - num3 * 0.6000000238418579 - (double)genRand.Next(1, 3));
			num8 = (int)((double)vector.Y + num3 * 0.6000000238418579 + (double)genRand.Next(6, 16));
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int num33 = num5; num33 < num6; num33++) {
				for (int num34 = num7; num34 < num8; num34++) {
					if (Main.tile[num33, num34].wall == wallType)
						continue;

					bool flag = true;
					if (num4 < 0) {
						if ((double)num33 < (double)vector.X - num2 * 0.5)
							flag = false;
					}
					else if ((double)num33 > (double)vector.X + num2 * 0.5 - 1.0) {
						flag = false;
					}

					if (flag) {
						Main.tile[num33, num34].wall = 0;
						Main.tile[num33, num34].active(active: true);
						Main.tile[num33, num34].type = tileType;
					}
				}
			}

			for (int num35 = num5; num35 < num6; num35++) {
				for (int num36 = num8; (double)num36 < Main.worldSurface; num36++) {
					if (!Main.wallDungeon[Main.tile[num35, num36].wall]) {
						Main.tile[num35, num36].active(active: true);
						Main.tile[num35, num36].type = tileType;
					}

					Main.tile[num35, num36].wall = (byte)wallType;
				}
			}

			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num9 = num5;
			if (num4 < 0)
				num9++;

			num10 = num9 + 5 + genRand.Next(4);
			num11 = num7 - 3 - genRand.Next(3);
			num12 = num7;
			for (int num37 = num9; num37 < num10; num37++) {
				for (int num38 = num11; num38 < num12; num38++) {
					if (Main.tile[num37, num38].wall != wallType) {
						Main.tile[num37, num38].active(active: true);
						Main.tile[num37, num38].type = tileType;
					}
				}
			}

			num9 = num6 - 5 - genRand.Next(4);
			num10 = num6;
			num11 = num7 - 3 - genRand.Next(3);
			num12 = num7;
			for (int num39 = num9; num39 < num10; num39++) {
				for (int num40 = num11; num40 < num12; num40++) {
					if (Main.tile[num39, num40].wall != wallType) {
						Main.tile[num39, num40].active(active: true);
						Main.tile[num39, num40].type = tileType;
					}
				}
			}

			num17 = 1 + genRand.Next(2);
			num18 = 2 + genRand.Next(4);
			num19 = 0;
			if (num4 < 0)
				num6++;

			for (int num41 = num5 + 1; num41 < num6 - 1; num41++) {
				for (int num42 = num7 - num17; num42 < num7; num42++) {
					if (Main.tile[num41, num42].wall != wallType) {
						Main.tile[num41, num42].active(active: true);
						Main.tile[num41, num42].type = tileType;
					}
				}

				num19++;
				if (num19 >= num18) {
					num41 += num18;
					num19 = 0;
				}
			}

			num5 = (int)((double)vector.X - num2 * 0.6);
			num6 = (int)((double)vector.X + num2 * 0.6);
			num7 = (int)((double)vector.Y - num3 * 0.6);
			num8 = (int)((double)vector.Y + num3 * 0.6);
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int num43 = num5; num43 < num6; num43++) {
				for (int num44 = num7; num44 < num8; num44++) {
					Main.tile[num43, num44].wall = 0;
				}
			}

			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num7 = (int)((double)vector.Y - num3 * 0.5);
			num8 = (int)((double)vector.Y + num3 * 0.5);
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int num45 = num5; num45 < num6; num45++) {
				for (int num46 = num7; num46 < num8; num46++) {
					Main.tile[num45, num46].active(active: false);
					Main.tile[num45, num46].wall = 0;
				}
			}

			for (int num47 = num5; num47 < num6; num47++) {
				if (!Main.tile[num47, num8].active()) {
					Main.tile[num47, num8].active(active: true);
					Main.tile[num47, num8].type = 19;
					if (wallType == 7)
						Main.tile[num47, num8].frameY = 108;

					if (wallType == 8)
						Main.tile[num47, num8].frameY = 144;

					if (wallType == 9)
						Main.tile[num47, num8].frameY = 126;
				}
			}

			Main.dungeonX = (int)vector.X;
			Main.dungeonY = num8;
			int num48 = NPC.NewNPC(Main.dungeonX * 16 + 8, Main.dungeonY * 16, 37);
			Main.npc[num48].homeless = false;
			Main.npc[num48].homeTileX = Main.dungeonX;
			Main.npc[num48].homeTileY = Main.dungeonY;
			if (num4 == 1) {
				int num49 = 0;
				for (int num50 = num6; num50 < num6 + 50; num50++) {
					num49++;
					for (int num51 = num8 + num49; num51 < num8 + 50; num51++) {
						if (!Main.wallDungeon[Main.tile[num50, num51].wall]) {
							Main.tile[num50, num51].active(active: true);
							Main.tile[num50, num51].type = tileType;
						}
					}
				}
			}
			else {
				int num52 = 0;
				for (int num53 = num5; num53 > num5 - 50; num53--) {
					num52++;
					for (int num54 = num8 + num52; num54 < num8 + 50; num54++) {
						if (!Main.wallDungeon[Main.tile[num53, num54].wall]) {
							Main.tile[num53, num54].active(active: true);
							Main.tile[num53, num54].type = tileType;
						}
					}
				}
			}

			num17 = 1 + genRand.Next(2);
			num18 = 2 + genRand.Next(4);
			num19 = 0;
			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num5 += 2;
			num6 -= 2;
			for (int num55 = num5; num55 < num6; num55++) {
				for (int num56 = num7; num56 < num8; num56++) {
					PlaceWall(num55, num56, wallType, mute: true);
				}

				num19++;
				if (num19 >= num18) {
					num55 += num18 * 2;
					num19 = 0;
				}
			}

			vector.X -= (float)num2 * 0.6f * (float)num4;
			vector.Y += (float)num3 * 0.5f;
			num2 = 15.0;
			num3 = 3.0;
			vector.Y -= (float)num3 * 0.5f;
			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num7 = (int)((double)vector.Y - num3 * 0.5);
			num8 = (int)((double)vector.Y + num3 * 0.5);
			if (num5 < 0)
				num5 = 0;

			if (num6 > Main.maxTilesX)
				num6 = Main.maxTilesX;

			if (num7 < 0)
				num7 = 0;

			if (num8 > Main.maxTilesY)
				num8 = Main.maxTilesY;

			for (int num57 = num5; num57 < num6; num57++) {
				for (int num58 = num7; num58 < num8; num58++) {
					Main.tile[num57, num58].active(active: false);
				}
			}

			if (num4 < 0)
				vector.X -= 1f;

			PlaceTile((int)vector.X, (int)vector.Y + 1, 10, mute: true, forced: false, -1, 13);
		}

		public static bool AddBuriedChest(Point point, int contain = 0, bool notNearOtherChests = false, int Style = -1) => AddBuriedChest(point.X, point.Y, contain, notNearOtherChests, Style);

		public static bool AddBuriedChest(int i, int j, int contain = 0, bool notNearOtherChests = false, int Style = -1) {
			bool flag = false;
			bool flag2 = false;
			for (int k = j; k < Main.maxTilesY; k++) {
				if (!SolidTile(i, k))
					continue;

				bool flag3 = false;
				int num = k;
				int num2 = -1;
				int num3 = 0;
				if ((double)num >= Main.worldSurface + 25.0 || contain > 0) {
					num3 = 1;
					if (Style == 10 || contain == 211 || contain == 212 || contain == 213 || contain == 753) {
						num3 = 10;
						flag2 = true;
					}
				}

				if (Style >= 0)
					num3 = Style;

				if (num3 == 11 || (num3 != 99 && contain == 0 && (double)num >= Main.worldSurface + 25.0 && num <= Main.maxTilesY - 205 && (Main.tile[i, k].type == 147 || Main.tile[i, k].type == 161 || Main.tile[i, k].type == 162))) {
					flag = true;
					num3 = 11;
					switch (genRand.Next(6)) {
						case 0:
							contain = 670;
							break;
						case 1:
							contain = 724;
							break;
						case 2:
							contain = 950;
							break;
						case 3:
							contain = 1319;
							break;
						case 4:
							contain = 987;
							break;
						default:
							contain = 1579;
							break;
					}

					if (genRand.Next(20) == 0)
						contain = 997;

					if (genRand.Next(50) == 0)
						contain = 669;
				}

				if ((num > Main.maxTilesY - 205 || num3 == 99) && contain == 0) {
					if (hellChest == hellChestItem[0]) {
						contain = 274;
						num3 = 4;
						flag3 = true;
					}
					else if (hellChest == hellChestItem[1]) {
						contain = 220;
						num3 = 4;
						flag3 = true;
					}
					else if (hellChest == hellChestItem[2]) {
						contain = 112;
						num3 = 4;
						flag3 = true;
					}
					else if (hellChest == hellChestItem[3]) {
						contain = 218;
						num3 = 4;
						flag3 = true;
					}
					else {
						contain = 3019;
						num3 = 4;
						flag3 = true;
					}
				}

				num2 = PlaceChest(i - 1, num - 1, 21, notNearOtherChests, num3);
				if (num2 >= 0) {
					if (flag3) {
						hellChest++;
						if (hellChest > 4)
							hellChest = 0;
					}

					int num4 = 0;
					while (num4 == 0) {
						if ((num3 == 0 && (double)num < Main.worldSurface + 25.0) || contain == 848) {
							if (contain > 0) {
								Main.chest[num2].item[num4].SetDefaults(contain);
								Main.chest[num2].item[num4].Prefix(-1);
								switch (contain) {
									case 848:
										num4++;
										Main.chest[num2].item[num4].SetDefaults(866);
										break;
									case 832:
										num4++;
										Main.chest[num2].item[num4].SetDefaults(933);
										break;
								}

								num4++;
							}
							else {
								int num5 = genRand.Next(11);
								if (num5 == 0) {
									Main.chest[num2].item[num4].SetDefaults(280);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 1) {
									Main.chest[num2].item[num4].SetDefaults(281);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 2) {
									Main.chest[num2].item[num4].SetDefaults(284);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 3) {
									Main.chest[num2].item[num4].SetDefaults(282);
									Main.chest[num2].item[num4].stack = genRand.Next(40, 75);
								}

								if (num5 == 4) {
									Main.chest[num2].item[num4].SetDefaults(279);
									Main.chest[num2].item[num4].stack = genRand.Next(70, 150);
								}

								if (num5 == 5) {
									Main.chest[num2].item[num4].SetDefaults(285);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 6) {
									Main.chest[num2].item[num4].SetDefaults(953);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 7) {
									Main.chest[num2].item[num4].SetDefaults(946);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 8) {
									Main.chest[num2].item[num4].SetDefaults(3068);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 9) {
									Main.chest[num2].item[num4].SetDefaults(3069);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num5 == 10) {
									Main.chest[num2].item[num4].SetDefaults(3084);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								num4++;
							}

							if (genRand.Next(6) == 0) {
								Main.chest[num2].item[num4].SetDefaults(3093);
								Main.chest[num2].item[num4].stack = 1;
								if (genRand.Next(5) == 0)
									Main.chest[num2].item[num4].stack += genRand.Next(2);

								if (genRand.Next(10) == 0)
									Main.chest[num2].item[num4].stack += genRand.Next(3);

								num4++;
							}

							if (genRand.Next(3) == 0) {
								Main.chest[num2].item[num4].SetDefaults(168);
								Main.chest[num2].item[num4].stack = genRand.Next(3, 6);
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num6 = genRand.Next(2);
								int stack = genRand.Next(8) + 3;
								if (num6 == 0)
									Main.chest[num2].item[num4].SetDefaults(copperBar);

								if (num6 == 1)
									Main.chest[num2].item[num4].SetDefaults(ironBar);

								Main.chest[num2].item[num4].stack = stack;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int stack2 = genRand.Next(50, 101);
								Main.chest[num2].item[num4].SetDefaults(965);
								Main.chest[num2].item[num4].stack = stack2;
								num4++;
							}

							if (genRand.Next(3) != 0) {
								int num7 = genRand.Next(2);
								int stack3 = genRand.Next(26) + 25;
								if (num7 == 0)
									if (Main.setting.IsCopper == 3) WorldGen.copperBar = WorldGen.genRand.NextBool() ? 20 : 703;
									Main.chest[num2].item[num4].SetDefaults(copperBar, false);

								if (num7 == 1)
									if (Main.setting.IsIron == 3) WorldGen.ironBar = WorldGen.genRand.NextBool() ? 22 : 704;
									Main.chest[num2].item[num4].SetDefaults(ironBar, false);

								Main.chest[num2].item[num4].stack = stack3;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num8 = genRand.Next(1);
								int stack4 = genRand.Next(3) + 3;
								if (num8 == 0)
									Main.chest[num2].item[num4].SetDefaults(28);

								Main.chest[num2].item[num4].stack = stack4;
								num4++;
							}

							if (genRand.Next(3) != 0) {
								Main.chest[num2].item[num4].SetDefaults(2350);
								Main.chest[num2].item[num4].stack = genRand.Next(2, 5);
								num4++;
							}

							if (genRand.Next(3) > 0) {
								int num9 = genRand.Next(6);
								int stack5 = genRand.Next(1, 3);
								if (num9 == 0)
									Main.chest[num2].item[num4].SetDefaults(292);

								if (num9 == 1)
									Main.chest[num2].item[num4].SetDefaults(298);

								if (num9 == 2)
									Main.chest[num2].item[num4].SetDefaults(299);

								if (num9 == 3)
									Main.chest[num2].item[num4].SetDefaults(290);

								if (num9 == 4)
									Main.chest[num2].item[num4].SetDefaults(2322);

								if (num9 == 5)
									Main.chest[num2].item[num4].SetDefaults(2325);

								Main.chest[num2].item[num4].stack = stack5;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num10 = genRand.Next(2);
								int stack6 = genRand.Next(11) + 10;
								if (num10 == 0)
									Main.chest[num2].item[num4].SetDefaults(8);

								if (num10 == 1)
									Main.chest[num2].item[num4].SetDefaults(31);

								Main.chest[num2].item[num4].stack = stack6;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								Main.chest[num2].item[num4].SetDefaults(72);
								Main.chest[num2].item[num4].stack = genRand.Next(10, 30);
								num4++;
							}
						}
						else if ((double)num < Main.rockLayer) {
							if (contain > 0) {
								if (contain == 832) {
									Main.chest[num2].item[num4].SetDefaults(933);
									num4++;
								}

								Main.chest[num2].item[num4].SetDefaults(contain);
								Main.chest[num2].item[num4].Prefix(-1);
								num4++;
							}
							else {
								int num11 = genRand.Next(7);
								if (genRand.Next(20) == 0) {
									Main.chest[num2].item[num4].SetDefaults(997);
									Main.chest[num2].item[num4].Prefix(-1);
								}
								else {
									if (num11 == 0) {
										Main.chest[num2].item[num4].SetDefaults(49);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num11 == 1) {
										Main.chest[num2].item[num4].SetDefaults(50);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num11 == 2) {
										Main.chest[num2].item[num4].SetDefaults(53);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num11 == 3) {
										Main.chest[num2].item[num4].SetDefaults(54);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num11 == 4) {
										Main.chest[num2].item[num4].SetDefaults(55);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num11 == 5) {
										Main.chest[num2].item[num4].SetDefaults(975);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num11 == 6) {
										Main.chest[num2].item[num4].SetDefaults(930);
										Main.chest[num2].item[num4].Prefix(-1);
										num4++;
										Main.chest[num2].item[num4].SetDefaults(931);
										Main.chest[num2].item[num4].stack = genRand.Next(26) + 25;
									}
								}

								num4++;
							}

							if (genRand.Next(3) == 0) {
								Main.chest[num2].item[num4].SetDefaults(166);
								Main.chest[num2].item[num4].stack = genRand.Next(10, 20);
								num4++;
							}

							if (genRand.Next(5) == 0) {
								Main.chest[num2].item[num4].SetDefaults(52);
								num4++;
							}

							if (genRand.Next(3) == 0) {
								int stack7 = genRand.Next(50, 101);
								Main.chest[num2].item[num4].SetDefaults(965);
								Main.chest[num2].item[num4].stack = stack7;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num12 = genRand.Next(2);
								int stack8 = genRand.Next(10) + 5;
								if (num12 == 0)
									Main.chest[num2].item[num4].SetDefaults(ironBar);

								if (num12 == 1)
									Main.chest[num2].item[num4].SetDefaults(silverBar);

								Main.chest[num2].item[num4].stack = stack8;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num13 = genRand.Next(2);
								int stack9 = genRand.Next(25) + 25;
								if (num13 == 0)
									Main.chest[num2].item[num4].SetDefaults(40);

								if (num13 == 1)
									Main.chest[num2].item[num4].SetDefaults(42);

								Main.chest[num2].item[num4].stack = stack9;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num14 = genRand.Next(1);
								int stack10 = genRand.Next(3) + 3;
								if (num14 == 0)
									Main.chest[num2].item[num4].SetDefaults(28);

								Main.chest[num2].item[num4].stack = stack10;
								num4++;
							}

							if (genRand.Next(3) > 0) {
								int num15 = genRand.Next(9);
								int stack11 = genRand.Next(1, 3);
								if (num15 == 0)
									Main.chest[num2].item[num4].SetDefaults(289);

								if (num15 == 1)
									Main.chest[num2].item[num4].SetDefaults(298);

								if (num15 == 2)
									Main.chest[num2].item[num4].SetDefaults(299);

								if (num15 == 3)
									Main.chest[num2].item[num4].SetDefaults(290);

								if (num15 == 4)
									Main.chest[num2].item[num4].SetDefaults(303);

								if (num15 == 5)
									Main.chest[num2].item[num4].SetDefaults(291);

								if (num15 == 6)
									Main.chest[num2].item[num4].SetDefaults(304);

								if (num15 == 7)
									Main.chest[num2].item[num4].SetDefaults(2322);

								if (num15 == 8)
									Main.chest[num2].item[num4].SetDefaults(2329);

								Main.chest[num2].item[num4].stack = stack11;
								num4++;
							}

							if (genRand.Next(3) != 0) {
								int stack12 = genRand.Next(1, 3);
								Main.chest[num2].item[num4].SetDefaults(2350);
								Main.chest[num2].item[num4].stack = stack12;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int stack13 = genRand.Next(11) + 10;
								if (num3 == 11)
									Main.chest[num2].item[num4].SetDefaults(974);
								else
									Main.chest[num2].item[num4].SetDefaults(8);

								Main.chest[num2].item[num4].stack = stack13;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								Main.chest[num2].item[num4].SetDefaults(72);
								Main.chest[num2].item[num4].stack = genRand.Next(50, 90);
								num4++;
							}
						}
						else if (num < Main.maxTilesY - 250) {
							if (contain > 0) {
								Main.chest[num2].item[num4].SetDefaults(contain);
								Main.chest[num2].item[num4].Prefix(-1);
								num4++;
								if (flag && genRand.Next(5) == 0) {
									Main.chest[num2].item[num4].SetDefaults(3199);
									num4++;
								}

								if (flag2 && genRand.Next(6) == 0) {
									Main.chest[num2].item[num4++].SetDefaults(3360);
									Main.chest[num2].item[num4++].SetDefaults(3361);
								}
							}
							else {
								int num16 = genRand.Next(7);
								if (genRand.Next(40) == 0) {
									Main.chest[num2].item[num4].SetDefaults(906);
									Main.chest[num2].item[num4].Prefix(-1);
								}
								else if (genRand.Next(15) == 0) {
									Main.chest[num2].item[num4].SetDefaults(997);
									Main.chest[num2].item[num4].Prefix(-1);
								}
								else {
									if (num16 == 0) {
										Main.chest[num2].item[num4].SetDefaults(49);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num16 == 1) {
										Main.chest[num2].item[num4].SetDefaults(50);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num16 == 2) {
										Main.chest[num2].item[num4].SetDefaults(53);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num16 == 3) {
										Main.chest[num2].item[num4].SetDefaults(54);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num16 == 4) {
										Main.chest[num2].item[num4].SetDefaults(55);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num16 == 5) {
										Main.chest[num2].item[num4].SetDefaults(975);
										Main.chest[num2].item[num4].Prefix(-1);
									}

									if (num16 == 6) {
										Main.chest[num2].item[num4].SetDefaults(930);
										Main.chest[num2].item[num4].Prefix(-1);
										num4++;
										Main.chest[num2].item[num4].SetDefaults(931);
										Main.chest[num2].item[num4].stack = genRand.Next(26) + 25;
									}
								}

								num4++;
							}

							if (genRand.Next(5) == 0) {
								Main.chest[num2].item[num4].SetDefaults(43);
								num4++;
							}

							if (genRand.Next(3) == 0) {
								Main.chest[num2].item[num4].SetDefaults(167);
								num4++;
							}

							if (genRand.Next(4) == 0) {
								Main.chest[num2].item[num4].SetDefaults(51);
								Main.chest[num2].item[num4].stack = genRand.Next(26) + 25;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num17 = genRand.Next(2);
								int stack14 = genRand.Next(8) + 3;
								if (num17 == 0)
									Main.chest[num2].item[num4].SetDefaults(goldBar);

								if (num17 == 1)
									Main.chest[num2].item[num4].SetDefaults(silverBar);

								Main.chest[num2].item[num4].stack = stack14;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num18 = genRand.Next(2);
								int stack15 = genRand.Next(26) + 25;
								if (num18 == 0)
									if (Main.setting.IsGold == 3) WorldGen.goldBar = WorldGen.genRand.NextBool() ? 19 : 706;
									Main.chest[num2].item[num4].SetDefaults(goldBar, false);

								if (num18 == 1)
									if (Main.setting.IsSilver == 3) WorldGen.silverBar = WorldGen.genRand.NextBool() ? 21 : 705;
									Main.chest[num2].item[num4].SetDefaults(silverBar, false);

								Main.chest[num2].item[num4].stack = stack15;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num19 = genRand.Next(1);
								int stack16 = genRand.Next(3) + 3;
								if (num19 == 0)
									Main.chest[num2].item[num4].SetDefaults(188);

								Main.chest[num2].item[num4].stack = stack16;
								num4++;
							}

							if (genRand.Next(3) > 0) {
								int num20 = genRand.Next(6);
								int stack17 = genRand.Next(1, 3);
								if (num20 == 0)
									Main.chest[num2].item[num4].SetDefaults(296);

								if (num20 == 1)
									Main.chest[num2].item[num4].SetDefaults(295);

								if (num20 == 2)
									Main.chest[num2].item[num4].SetDefaults(299);

								if (num20 == 3)
									Main.chest[num2].item[num4].SetDefaults(302);

								if (num20 == 4)
									Main.chest[num2].item[num4].SetDefaults(303);

								if (num20 == 5)
									Main.chest[num2].item[num4].SetDefaults(305);

								Main.chest[num2].item[num4].stack = stack17;
								num4++;
							}

							if (genRand.Next(3) > 1) {
								int num21 = genRand.Next(7);
								int stack18 = genRand.Next(1, 3);
								if (num21 == 0)
									Main.chest[num2].item[num4].SetDefaults(301);

								if (num21 == 1)
									Main.chest[num2].item[num4].SetDefaults(302);

								if (num21 == 2)
									Main.chest[num2].item[num4].SetDefaults(297);

								if (num21 == 3)
									Main.chest[num2].item[num4].SetDefaults(304);

								if (num21 == 4)
									Main.chest[num2].item[num4].SetDefaults(2329);

								if (num21 == 5)
									Main.chest[num2].item[num4].SetDefaults(2351);

								if (num21 == 6)
									Main.chest[num2].item[num4].SetDefaults(2329);

								Main.chest[num2].item[num4].stack = stack18;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int stack19 = genRand.Next(1, 3);
								Main.chest[num2].item[num4].SetDefaults(2350);
								Main.chest[num2].item[num4].stack = stack19;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num22 = genRand.Next(2);
								int stack20 = genRand.Next(15) + 15;
								if (num22 == 0) {
									if (num3 == 11)
										Main.chest[num2].item[num4].SetDefaults(974);
									else
										Main.chest[num2].item[num4].SetDefaults(8);
								}

								if (num22 == 1)
									Main.chest[num2].item[num4].SetDefaults(282);

								Main.chest[num2].item[num4].stack = stack20;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								Main.chest[num2].item[num4].SetDefaults(73);
								Main.chest[num2].item[num4].stack = genRand.Next(1, 3);
								num4++;
							}
						}
						else {
							if (contain > 0) {
								Main.chest[num2].item[num4].SetDefaults(contain);
								Main.chest[num2].item[num4].Prefix(-1);
								num4++;
							}
							else {
								int num23 = genRand.Next(4);
								if (num23 == 0) {
									Main.chest[num2].item[num4].SetDefaults(49);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num23 == 1) {
									Main.chest[num2].item[num4].SetDefaults(50);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num23 == 2) {
									Main.chest[num2].item[num4].SetDefaults(53);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								if (num23 == 3) {
									Main.chest[num2].item[num4].SetDefaults(54);
									Main.chest[num2].item[num4].Prefix(-1);
								}

								num4++;
							}

							if (genRand.Next(3) == 0) {
								Main.chest[num2].item[num4].SetDefaults(167);
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num24 = genRand.Next(2);
								int stack21 = genRand.Next(15) + 15;
								if (num24 == 0)
									Main.chest[num2].item[num4].SetDefaults(117);

								if (num24 == 1) {
									if (Main.setting.IsGold == 3) WorldGen.goldBar = WorldGen.genRand.NextBool() ? 19 : 706;
									Main.chest[num2].item[num4].SetDefaults(goldBar);
								}

								Main.chest[num2].item[num4].stack = stack21;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num25 = genRand.Next(2);
								int stack22 = genRand.Next(25) + 50;
								if (num25 == 0)
									Main.chest[num2].item[num4].SetDefaults(265);

								if (num25 == 1)
									Main.chest[num2].item[num4].SetDefaults(278);

								Main.chest[num2].item[num4].stack = stack22;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num26 = genRand.Next(2);
								int stack23 = genRand.Next(6) + 15;
								if (num26 == 0)
									Main.chest[num2].item[num4].SetDefaults(226);

								if (num26 == 1)
									Main.chest[num2].item[num4].SetDefaults(227);

								Main.chest[num2].item[num4].stack = stack23;
								num4++;
							}

							if (genRand.Next(4) > 0) {
								int num27 = genRand.Next(8);
								int stack24 = genRand.Next(1, 3);
								if (num27 == 0)
									Main.chest[num2].item[num4].SetDefaults(296);

								if (num27 == 1)
									Main.chest[num2].item[num4].SetDefaults(295);

								if (num27 == 2)
									Main.chest[num2].item[num4].SetDefaults(293);

								if (num27 == 3)
									Main.chest[num2].item[num4].SetDefaults(288);

								if (num27 == 4)
									Main.chest[num2].item[num4].SetDefaults(294);

								if (num27 == 5)
									Main.chest[num2].item[num4].SetDefaults(297);

								if (num27 == 6)
									Main.chest[num2].item[num4].SetDefaults(304);

								if (num27 == 7)
									Main.chest[num2].item[num4].SetDefaults(2323);

								Main.chest[num2].item[num4].stack = stack24;
								num4++;
							}

							if (genRand.Next(3) > 0) {
								int num28 = genRand.Next(8);
								int stack25 = genRand.Next(1, 3);
								if (num28 == 0)
									Main.chest[num2].item[num4].SetDefaults(305);

								if (num28 == 1)
									Main.chest[num2].item[num4].SetDefaults(301);

								if (num28 == 2)
									Main.chest[num2].item[num4].SetDefaults(302);

								if (num28 == 3)
									Main.chest[num2].item[num4].SetDefaults(288);

								if (num28 == 4)
									Main.chest[num2].item[num4].SetDefaults(300);

								if (num28 == 5)
									Main.chest[num2].item[num4].SetDefaults(2351);

								if (num28 == 6)
									Main.chest[num2].item[num4].SetDefaults(2348);

								if (num28 == 7)
									Main.chest[num2].item[num4].SetDefaults(2345);

								Main.chest[num2].item[num4].stack = stack25;
								num4++;
							}

							if (genRand.Next(3) == 0) {
								int stack26 = genRand.Next(1, 3);
								Main.chest[num2].item[num4].SetDefaults(2350);
								Main.chest[num2].item[num4].stack = stack26;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								int num29 = genRand.Next(2);
								int stack27 = genRand.Next(15) + 15;
								if (num29 == 0)
									Main.chest[num2].item[num4].SetDefaults(8);

								if (num29 == 1)
									Main.chest[num2].item[num4].SetDefaults(282);

								Main.chest[num2].item[num4].stack = stack27;
								num4++;
							}

							if (genRand.Next(2) == 0) {
								Main.chest[num2].item[num4].SetDefaults(73);
								Main.chest[num2].item[num4].stack = genRand.Next(2, 5);
								num4++;
							}
						}

						if (num4 <= 0)
							continue;

						if (num3 == 10 && genRand.Next(4) == 0) {
							Main.chest[num2].item[num4].SetDefaults(2204);
							num4++;
						}

						if (num3 == 11 && genRand.Next(7) == 0) {
							Main.chest[num2].item[num4].SetDefaults(2198);
							num4++;
						}

						if (num3 == 12 && genRand.Next(2) == 0) {
							Main.chest[num2].item[num4].SetDefaults(2196);
							num4++;
						}

						if (num3 == 13 && genRand.Next(3) == 0) {
							Main.chest[num2].item[num4].SetDefaults(2197);
							num4++;
						}

						if (num3 == 16) {
							Main.chest[num2].item[num4].SetDefaults(2195);
							num4++;
						}

						if (Main.wallDungeon[Main.tile[i, k].wall] && genRand.Next(8) == 0) {
							Main.chest[num2].item[num4].SetDefaults(2192);
							num4++;
						}

						if (num3 == 16) {
							if (genRand.Next(5) == 0) {
								Main.chest[num2].item[num4].SetDefaults(2767);
								num4++;
							}
							else {
								Main.chest[num2].item[num4].SetDefaults(2766);
								Main.chest[num2].item[num4].stack = genRand.Next(3, 8);
								num4++;
							}
						}
					}

					return true;
				}

				return false;
			}

			return false;
		}

		public static void UnlockDoor(int i, int j) {
			int num = j;
			if (Main.tile[i, num] == null)
				return;

			while (Main.tile[i, num].frameY != 594) {
				num--;
				if (Main.tile[i, num].frameY < 594 || num <= 0)
					return;
			}

			Main.PlaySound(22, i * 16, num * 16 + 16);
			for (int k = num; k <= num + 2; k++) {
				if (Main.tile[i, k] == null)
					Main.tile[i, k] = new Tile();

				Main.tile[i, k].frameY += 54;
				for (int l = 0; l < 4; l++) {
					Dust.NewDust(new Vector2(i * 16, k * 16), 16, 16, 11);
				}
			}
		}

		public static bool OpenDoor(int i, int j, int direction) {
			int num = 0;
			if (Main.tile[i, j - 1] == null)
				Main.tile[i, j - 1] = new Tile();

			if (Main.tile[i, j - 2] == null)
				Main.tile[i, j - 2] = new Tile();

			if (Main.tile[i, j + 1] == null)
				Main.tile[i, j + 1] = new Tile();

			if (Main.tile[i, j] == null)
				Main.tile[i, j] = new Tile();

			Tile tile = Main.tile[i, j];
			if (TileLoader.OpenDoorID(Main.tile[i, j]) < 0)
				return false;

			short num2 = 0;
			int num3 = tile.frameY;
			int num4 = 0;
			while (num3 >= 54) {
				num3 -= 54;
				num4++;
			}

			if (tile.frameX >= 54) {
				int num5 = tile.frameX / 54;
				num4 += 36 * num5;
				num2 = (short)(num2 + (short)(72 * num5));
			}

			num = j - num3 / 18;
			int num6 = i;
			byte color = Main.tile[num6, num].color();
			if (Main.tile[num6, num + 1] == null)
				Main.tile[num6, num + 1] = new Tile();

			byte color2 = Main.tile[num6, num + 1].color();
			if (Main.tile[num6, num + 2] == null)
				Main.tile[num6, num + 2] = new Tile();

			byte color3 = Main.tile[num6, num + 2].color();
			int num7;
			if (direction == -1) {
				num6 = i - 1;
				num2 = (short)(num2 + 36);
				num7 = i - 1;
			}
			else {
				num6 = i;
				num7 = i + 1;
			}

			for (int k = num; k < num + 3; k++) {
				if (Main.tile[num7, k] == null)
					Main.tile[num7, k] = new Tile();

				if (Main.tile[num7, k].active()) {
					if (!Main.tileCut[Main.tile[num7, k].type] && Main.tile[num7, k].type != 3 && Main.tile[num7, k].type != 24 && Main.tile[num7, k].type != 52 && Main.tile[num7, k].type != 61 && Main.tile[num7, k].type != 62 && Main.tile[num7, k].type != 69 && Main.tile[num7, k].type != 71 && Main.tile[num7, k].type != 73 && Main.tile[num7, k].type != 74 && Main.tile[num7, k].type != 110 && Main.tile[num7, k].type != 113 && Main.tile[num7, k].type != 115)
						return false;

					KillTile(num7, k);
				}
			}

			if (Main.netMode != 1 && Wiring.running) {
				Wiring.SkipWire(num6, num);
				Wiring.SkipWire(num6, num + 1);
				Wiring.SkipWire(num6, num + 2);
				Wiring.SkipWire(num6 + 1, num);
				Wiring.SkipWire(num6 + 1, num + 1);
				Wiring.SkipWire(num6 + 1, num + 2);
			}

			int num8 = num4 % 36 * 54;
			Main.PlaySound(8, i * 16, j * 16);
			ushort openDoorID = (ushort)TileLoader.OpenDoorID(Main.tile[i, j]);
			Main.tile[num6, num].active(active: true);
			Main.tile[num6, num].type = openDoorID;
			Main.tile[num6, num].frameY = (short)num8;
			Main.tile[num6, num].frameX = num2;
			Main.tile[num6, num].color(color);
			if (Main.tile[num6 + 1, num] == null)
				Main.tile[num6 + 1, num] = new Tile();

			Main.tile[num6 + 1, num].active(active: true);
			Main.tile[num6 + 1, num].type = openDoorID;
			Main.tile[num6 + 1, num].frameY = (short)num8;
			Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num].color(color);
			if (Main.tile[num6, num + 1] == null)
				Main.tile[num6, num + 1] = new Tile();

			Main.tile[num6, num + 1].active(active: true);
			Main.tile[num6, num + 1].type = openDoorID;
			Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
			Main.tile[num6, num + 1].frameX = num2;
			Main.tile[num6, num + 1].color(color2);
			if (Main.tile[num6 + 1, num + 1] == null)
				Main.tile[num6 + 1, num + 1] = new Tile();

			Main.tile[num6 + 1, num + 1].active(active: true);
			Main.tile[num6 + 1, num + 1].type = openDoorID;
			Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
			Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num + 1].color(color2);
			if (Main.tile[num6, num + 2] == null)
				Main.tile[num6, num + 2] = new Tile();

			Main.tile[num6, num + 2].active(active: true);
			Main.tile[num6, num + 2].type = openDoorID;
			Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
			Main.tile[num6, num + 2].frameX = num2;
			Main.tile[num6, num + 2].color(color3);
			if (Main.tile[num6 + 1, num + 2] == null)
				Main.tile[num6 + 1, num + 2] = new Tile();

			Main.tile[num6 + 1, num + 2].active(active: true);
			Main.tile[num6 + 1, num + 2].type = openDoorID;
			Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
			Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num + 2].color(color3);
			for (int l = num6 - 1; l <= num6 + 2; l++) {
				for (int m = num - 1; m <= num + 2; m++) {
					TileFrame(l, m);
				}
			}

			return true;
		}

		public static void Check1xX(int x, int j, short type) {
			if (destroyObject)
				return;

			int frameX = Main.tile[x, j].frameX;
			int num = 3;
			if (type == 92)
				num = 6;

			int num2 = Main.tile[x, j].frameY;
			int num3 = 0;
			while (num2 >= 18 * num) {
				num2 -= 18 * num;
				num3++;
			}

			int num4 = Main.tile[x, j].frameX / 18;
			int num5 = j - num2 / 18;
			bool flag = false;
			for (int i = 0; i < num; i++) {
				if (Main.tile[x, num5 + i] == null)
					Main.tile[x, num5 + i] = new Tile();

				if (!Main.tile[x, num5 + i].active())
					flag = true;
				else if (Main.tile[x, num5 + i].type != type)
					flag = true;
				else if (Main.tile[x, num5 + i].frameY != i * 18 + num3 * num * 18)
					flag = true;
				else if (Main.tile[x, num5 + i].frameX != frameX)
					flag = true;
			}

			if (Main.tile[x, num5 + num] == null)
				Main.tile[x, num5 + num] = new Tile();

			if (!SolidTileAllowBottomSlope(x, num5 + num))
				flag = true;

			if (!flag)
				return;

			destroyObject = true;
			for (int k = 0; k < num; k++) {
				if (Main.tile[x, num5 + k].type == type)
					KillTile(x, num5 + k);
			}

			if (!TileLoader.Drop(x, j, type))
				goto skipDrop;

			if (type == 92)
				Item.NewItem(x * 16, j * 16, 32, 32, 341);

			if (type == 453) {
				int num6 = 0;
				num6 = ((num4 < 2) ? 3744 : ((num4 >= 4) ? 3743 : 3745));
				Item.NewItem(x * 16, j * 16, 16, 32, num6);
			}

			if (type == 93) {
				int type2 = 0;
				switch (num3) {
					case 0:
						type2 = 342;
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
					case 9:
					case 10:
						type2 = 2082 + num3 - 1;
						break;
					default:
						if (num3 >= 11 && num3 <= 16) {
							type2 = 2129 + num3 - 11;
							break;
						}
						switch (num3) {
							case 17:
								type2 = 2225;
								break;
							case 18:
								type2 = 2533;
								break;
							case 19:
								type2 = 2547;
								break;
							case 20:
								type2 = 2563;
								break;
							case 21:
								type2 = 2578;
								break;
							case 22:
								type2 = 2643;
								break;
							case 23:
								type2 = 2644;
								break;
							case 24:
								type2 = 2645;
								break;
							case 25:
								type2 = 2646;
								break;
							case 26:
								type2 = 2647;
								break;
							case 27:
								type2 = 2819;
								break;
							case 28:
								type2 = 3135;
								break;
							case 29:
								type2 = 3137;
								break;
							case 30:
								type2 = 3136;
								break;
							case 31:
								type2 = 3892;
								break;
						}
						break;
				}

				Item.NewItem(x * 16, j * 16, 32, 32, type2);
			}

			skipDrop:
			destroyObject = false;
		}

		public static void Check2xX(int i, int j, ushort type) {
			if (destroyObject)
				return;

			int num = i;
			int num2;
			for (num2 = Main.tile[i, j].frameX; num2 >= 36; num2 -= 36) {
			}

			if (num2 == 18)
				num--;

			if (Main.tile[num, j] == null)
				Main.tile[num, j] = new Tile();

			int num3 = Main.tile[num, j].frameY / 18;
			int num4 = 3;
			if (type == 104)
				num4 = 5;

			if (type == 207)
				num4 = 4;

			int num5 = 0;
			while (num3 >= num4) {
				num3 -= num4;
				num5 += num4 * 18;
			}

			int num6 = j - num3;
			if (type == 410 && num5 != 0)
				num5 += 2;

			if (Main.tile[num, num6] == null)
				Main.tile[num, num6] = new Tile();

			int frameX = Main.tile[num, j].frameX;
			int frameY = Main.tile[num, j].frameY;
			bool flag = false;
			for (int k = 0; k < num4; k++) {
				if (Main.tile[num, num6 + k] == null)
					Main.tile[num, num6 + k] = new Tile();

				if (!Main.tile[num, num6 + k].active())
					flag = true;
				else if (Main.tile[num, num6 + k].type != type)
					flag = true;
				else if (Main.tile[num, num6 + k].frameY != k * 18 + num5)
					flag = true;
				else if (Main.tile[num, num6 + k].frameX != frameX)
					flag = true;

				if (Main.tile[num + 1, num6 + k] == null)
					Main.tile[num + 1, num6 + k] = new Tile();

				if (!Main.tile[num + 1, num6 + k].active())
					flag = true;
				else if (Main.tile[num + 1, num6 + k].type != type)
					flag = true;
				else if (Main.tile[num + 1, num6 + k].frameY != k * 18 + num5)
					flag = true;
				else if (Main.tile[num + 1, num6 + k].frameX != frameX + 18)
					flag = true;
			}

			if (type == 465) {
				for (int l = 0; l < 2; l++) {
					if (Main.tile[num + l, num6 - 1] == null)
						Main.tile[num + l, num6 - 1] = new Tile();

					if (!Main.tile[num + l, num6 - 1].nactive() || !Main.tileSolid[Main.tile[num + l, num6 - 1].type] || Main.tileSolidTop[Main.tile[num + l, num6 - 1].type]) {
						flag = true;
						break;
					}
				}
			}
			else {
				if (!SolidTileAllowBottomSlope(num, num6 + num4))
					flag = true;

				if (!SolidTileAllowBottomSlope(num + 1, num6 + num4))
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = 0; m < num4; m++) {
				if (Main.tile[num, num6 + m].type == type)
					KillTile(num, num6 + m);

				if (Main.tile[num + 1, num6 + m].type == type)
					KillTile(num + 1, num6 + m);
			}

			if (!TileLoader.Drop(num, j, type))
				goto skipDrop;

			if (type == 104) {
				int num7 = frameX / 36;
				int num8 = 0;
				if (num7 >= 1 && num7 <= 5) {
					num8 = 2237 + num7 - 1;
				}
				else {
					switch (num7) {
						case 6:
							num8 = 2560;
							break;
						case 7:
							num8 = 2575;
							break;
						case 8:
						case 9:
						case 10:
						case 11:
						case 12:
						case 13:
						case 14:
						case 15:
						case 16:
						case 17:
						case 18:
						case 19:
						case 20:
						case 21:
						case 22:
						case 23:
							num8 = 2591 + num7 - 8;
							break;
						default:
							switch (num7) {
								case 24:
									num8 = 2809;
									break;
								case 25:
									num8 = 3126;
									break;
								case 26:
									num8 = 3128;
									break;
								case 27:
									num8 = 3127;
									break;
								case 28:
									num8 = 3898;
									break;
								case 29:
									num8 = 3899;
									break;
								case 30:
									num8 = 3900;
									break;
								case 31:
									num8 = 3901;
									break;
								case 32:
									num8 = 3902;
									break;
								default:
									num8 = 359;
									break;
							}
							break;
					}
				}

				Item.NewItem(num * 16, j * 16, 32, 32, num8);
			}

			if (type == 105) {
				int num9 = frameX / 36;
				num9 += frameY / 54 * 55;
				switch (num9) {
					case 0:
						num9 = 360;
						break;
					case 1:
						num9 = 52;
						break;
					case 43:
						num9 = 1152;
						break;
					case 44:
						num9 = 1153;
						break;
					case 45:
						num9 = 1154;
						break;
					case 46:
						num9 = 1408;
						break;
					case 47:
						num9 = 1409;
						break;
					case 48:
						num9 = 1410;
						break;
					case 49:
						num9 = 1462;
						break;
					case 50:
						num9 = 2672;
						break;
					case 51:
					case 52:
					case 53:
					case 54:
					case 55:
					case 56:
					case 57:
					case 58:
					case 59:
					case 60:
					case 61:
					case 62:
						num9 = 3651 + num9 - 51;
						break;
					default:
						num9 = ((num9 < 63 || num9 > 75) ? (438 + num9 - 2) : (3708 + num9 - 63));
						break;
				}

				Item.NewItem(num * 16, j * 16, 32, 32, num9);
			}

			if (type == 356)
				Item.NewItem(num * 16, j * 16, 32, 32, 3064);

			if (type == 456)
				Item.NewItem(num * 16, j * 16, 32, 32, 3748);

			if (type == 337) {
				int num10 = frameX / 36;
				Item.NewItem(num * 16, j * 16, 32, 32, 2702 + num10);
			}

			if (type == 207) {
				int num11 = frameX / 36;
				switch (num11) {
					case 0:
						num11 = 909;
						break;
					case 1:
						num11 = 910;
						break;
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
						num11 = 938 + num11;
						break;
				}

				Item.NewItem(num * 16, j * 16, 32, 32, num11);
			}

			if (type == 410) {
				int num12 = frameX / 36;
				Item.NewItem(num * 16, j * 16, 32, 32, num12 + 3536);
			}

			if (type == 320)
				Item.NewItem(num * 16, j * 16, 32, 32, 2496);

			if (type == 349)
				Item.NewItem(num * 16, j * 16, 32, 32, 470);

			if (type == 465)
				Item.NewItem(num * 16, j * 16, 32, 32, 3815);

			if (type == 378) {
				Item.NewItem(num * 16, j * 16, 32, 48, 3202);
				TETrainingDummy.Kill(num, num6);
			}

			skipDrop:
			destroyObject = false;
		}

		public static void PlaceTight(int x, int y, ushort type = 165, bool spiders = false) {
			if (Main.tile[x, y - 1] == null)
				Main.tile[x, y - 1] = new Tile();

			if (Main.tile[x, y] == null)
				Main.tile[x, y] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (SolidTile(x, y - 1) && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active()) {
				if (spiders) {
					int num = 108 + genRand.Next(3) * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num;
					Main.tile[x, y + 1].frameY = 18;
				}
				else {
					if (Main.tile[x, y - 1].type == 147 || Main.tile[x, y - 1].type == 161 || Main.tile[x, y - 1].type == 163 || Main.tile[x, y - 1].type == 164 || Main.tile[x, y - 1].type == 200) {
						if (genRand.Next(2) == 0) {
							int num2 = genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num2;
							Main.tile[x, y].frameY = 72;
						}
						else {
							int num3 = genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num3;
							Main.tile[x, y].frameY = 0;
							Main.tile[x, y + 1].type = type;
							Main.tile[x, y + 1].active(active: true);
							Main.tile[x, y + 1].frameX = (short)num3;
							Main.tile[x, y + 1].frameY = 18;
						}
					}

					if (Main.tile[x, y - 1].type == 1 || Main.tileMoss[Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203) {
						if (genRand.Next(2) == 0) {
							int num4 = 54 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num4;
							Main.tile[x, y].frameY = 72;
						}
						else {
							int num5 = 54 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num5;
							Main.tile[x, y].frameY = 0;
							Main.tile[x, y + 1].type = type;
							Main.tile[x, y + 1].active(active: true);
							Main.tile[x, y + 1].frameX = (short)num5;
							Main.tile[x, y + 1].frameY = 18;
						}
					}

					if (Main.tile[x, y - 1].type == 225) {
						int num6 = 162 + genRand.Next(3) * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num6;
						Main.tile[x, y].frameY = 72;
					}

					if (Main.tile[x, y - 1].type == 396 || Main.tile[x, y - 1].type == 397) {
						if (genRand.Next(2) == 0) {
							int num7 = 378 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num7;
							Main.tile[x, y].frameY = 72;
						}
						else {
							int num8 = 378 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num8;
							Main.tile[x, y].frameY = 0;
							Main.tile[x, y + 1].type = type;
							Main.tile[x, y + 1].active(active: true);
							Main.tile[x, y + 1].frameX = (short)num8;
							Main.tile[x, y + 1].frameY = 18;
						}
					}

					if (Main.tile[x, y - 1].type == 368) {
						if (genRand.Next(2) == 0) {
							int num9 = 432 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num9;
							Main.tile[x, y].frameY = 72;
						}
						else {
							int num10 = 432 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num10;
							Main.tile[x, y].frameY = 0;
							Main.tile[x, y + 1].type = type;
							Main.tile[x, y + 1].active(active: true);
							Main.tile[x, y + 1].frameX = (short)num10;
							Main.tile[x, y + 1].frameY = 18;
						}
					}

					if (Main.tile[x, y - 1].type == 367) {
						if (genRand.Next(2) == 0) {
							int num11 = 486 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num11;
							Main.tile[x, y].frameY = 72;
						}
						else {
							int num12 = 486 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num12;
							Main.tile[x, y].frameY = 0;
							Main.tile[x, y + 1].type = type;
							Main.tile[x, y + 1].active(active: true);
							Main.tile[x, y + 1].frameX = (short)num12;
							Main.tile[x, y + 1].frameY = 18;
						}
					}
				}
			}
			else {
				if (spiders)
					return;

				if (SolidTile(x, y + 1) && !Main.tile[x, y].active() && !Main.tile[x, y - 1].active()) {
					if (Main.tile[x, y + 1].type == 1 || Main.tileMoss[Main.tile[x, y + 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203) {
						if (genRand.Next(2) == 0) {
							int num13 = 54 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num13;
							Main.tile[x, y].frameY = 90;
						}
						else {
							int num14 = 54 + genRand.Next(3) * 18;
							Main.tile[x, y - 1].type = type;
							Main.tile[x, y - 1].active(active: true);
							Main.tile[x, y - 1].frameX = (short)num14;
							Main.tile[x, y - 1].frameY = 36;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num14;
							Main.tile[x, y].frameY = 54;
						}
					}

					if (Main.tile[x, y + 1].type == 225) {
						int num15 = 162 + genRand.Next(3) * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num15;
						Main.tile[x, y].frameY = 90;
					}

					if (Main.tile[x, y + 1].type == 396 || Main.tile[x, y + 1].type == 397) {
						if (genRand.Next(2) == 0) {
							int num16 = 378 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num16;
							Main.tile[x, y].frameY = 90;
						}
						else {
							int num17 = 378 + genRand.Next(3) * 18;
							Main.tile[x, y - 1].type = type;
							Main.tile[x, y - 1].active(active: true);
							Main.tile[x, y - 1].frameX = (short)num17;
							Main.tile[x, y - 1].frameY = 36;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num17;
							Main.tile[x, y].frameY = 54;
						}
					}

					if (Main.tile[x, y + 1].type == 368) {
						if (genRand.Next(2) == 0) {
							int num18 = 432 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num18;
							Main.tile[x, y].frameY = 90;
						}
						else {
							int num19 = 432 + genRand.Next(3) * 18;
							Main.tile[x, y - 1].type = type;
							Main.tile[x, y - 1].active(active: true);
							Main.tile[x, y - 1].frameX = (short)num19;
							Main.tile[x, y - 1].frameY = 36;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num19;
							Main.tile[x, y].frameY = 54;
						}
					}

					if (Main.tile[x, y + 1].type == 367) {
						if (genRand.Next(2) == 0) {
							int num20 = 486 + genRand.Next(3) * 18;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num20;
							Main.tile[x, y].frameY = 90;
						}
						else {
							int num21 = 486 + genRand.Next(3) * 18;
							Main.tile[x, y - 1].type = type;
							Main.tile[x, y - 1].active(active: true);
							Main.tile[x, y - 1].frameX = (short)num21;
							Main.tile[x, y - 1].frameY = 36;
							Main.tile[x, y].type = type;
							Main.tile[x, y].active(active: true);
							Main.tile[x, y].frameX = (short)num21;
							Main.tile[x, y].frameY = 54;
						}
					}
				}
			}

			if (Main.tile[x, y].type == 165)
				CheckTight(x, y);
		}

		public static void TightBiome(int x, int j) {
			if (Main.netMode == 1 || Main.tile[x, j] == null)
				return;

			int num = j;
			int num2 = 0;
			int num3 = 0;
			int num4 = 1;
			if (Main.tile[x, num].frameX >= 0 && Main.tile[x, num].frameX <= 36) {
				num2 = 7;
			}
			else if (Main.tile[x, num].frameX >= 54 && Main.tile[x, num].frameX <= 90) {
				num2 = 0;
			}
			else if (Main.tile[x, num].frameX >= 216 && Main.tile[x, num].frameX <= 252) {
				num2 = 1;
			}
			else if (Main.tile[x, num].frameX >= 270 && Main.tile[x, num].frameX <= 306) {
				num2 = 2;
			}
			else if (Main.tile[x, num].frameX >= 324 && Main.tile[x, num].frameX <= 360) {
				num2 = 3;
			}
			else if (Main.tile[x, num].frameX >= 378 && Main.tile[x, num].frameX <= 414) {
				num2 = 4;
			}
			else if (Main.tile[x, num].frameX >= 432 && Main.tile[x, num].frameX <= 468) {
				num2 = 5;
			}
			else {
				if (Main.tile[x, num].frameX < 486 || Main.tile[x, num].frameX > 522)
					return;

				num2 = 6;
			}

			if (Main.tile[x, num].frameY == 72) {
				num3 = Main.tile[x, num - 1].type;
			}
			else if (Main.tile[x, num].frameY == 90) {
				num3 = Main.tile[x, num + 1].type;
			}
			else if (Main.tile[x, num].frameY >= 36) {
				if (Main.tile[x, num].frameY == 54)
					num--;

				num4 = 2;
				num3 = Main.tile[x, num + 2].type;
			}
			else {
				if (Main.tile[x, num].frameY == 18)
					num--;

				num4 = 2;
				num3 = Main.tile[x, num - 1].type;
			}

			switch (num3) {
				default:
					return;
				case 1:
					num3 = 0;
					break;
				case 117:
				case 164:
				case 402:
				case 403:
					num3 = 1;
					break;
				case 25:
				case 163:
				case 398:
				case 400:
					num3 = 2;
					break;
				case 200:
				case 203:
				case 399:
				case 401:
					num3 = 3;
					break;
				case 396:
				case 397:
					num3 = 4;
					break;
				case 367:
					num3 = 6;
					break;
				case 368:
					num3 = 5;
					break;
				case 161:
					num3 = 7;
					break;
			}

			if (num2 != num3) {
				int num5 = genRand.Next(3) * 18;
				switch (num3) {
					case 0:
						num5 += 54;
						break;
					case 1:
						num5 += 216;
						break;
					case 2:
						num5 += 270;
						break;
					case 3:
						num5 += 324;
						break;
					case 4:
						num5 += 378;
						break;
					case 5:
						num5 += 432;
						break;
					case 6:
						num5 += 486;
						break;
					case 7:
						num5 = num5;
						break;
				}

				for (int i = num; i < num + num4; i++) {
					Main.tile[x, i].frameX = (short)num5;
				}

				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, x, num, 2);
			}
		}

		public static void CheckTight(int x, int j) {
			if (Main.tile[x, j] == null)
				return;

			int num = j;
			if (Main.tile[x, num].frameY == 72) {
				if (Main.tile[x, num - 1] == null)
					Main.tile[x, num - 1] = new Tile();

				if (Main.tile[x, num] == null)
					Main.tile[x, num] = new Tile();

				if (Main.tile[x, num + 1] == null)
					Main.tile[x, num + 1] = new Tile();

				bool flag = false;
				if (!SolidTile(x, num - 1))
					flag = true;

				if (flag) {
					if (Main.tile[x, num].type == Main.tile[x, j].type)
						KillTile(x, num);
				}
				else {
					TightBiome(x, num);
				}

				return;
			}

			if (Main.tile[x, num].frameY == 90) {
				if (Main.tile[x, num - 1] == null)
					Main.tile[x, num - 1] = new Tile();

				if (Main.tile[x, num] == null)
					Main.tile[x, num] = new Tile();

				if (Main.tile[x, num + 1] == null)
					Main.tile[x, num + 1] = new Tile();

				bool flag2 = false;
				if (!SolidTile(x, num + 1))
					flag2 = true;

				if (flag2) {
					if (Main.tile[x, num].type == Main.tile[x, j].type)
						KillTile(x, num);
				}
				else {
					TightBiome(x, num);
				}

				return;
			}

			if (Main.tile[x, num].frameY >= 36) {
				if (Main.tile[x, num].frameY == 54)
					num--;

				if (Main.tile[x, num] == null)
					Main.tile[x, num] = new Tile();

				if (Main.tile[x, num + 1] == null)
					Main.tile[x, num + 1] = new Tile();

				if (Main.tile[x, num + 2] == null)
					Main.tile[x, num + 2] = new Tile();

				bool flag3 = false;
				if (!SolidTile(x, num + 2))
					flag3 = true;

				if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
					flag3 = true;

				if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
					flag3 = true;

				if (flag3) {
					if (Main.tile[x, num].type == Main.tile[x, j].type)
						KillTile(x, num);

					if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
						KillTile(x, num + 1);
				}
				else {
					TightBiome(x, num);
				}

				return;
			}

			if (Main.tile[x, num].frameY == 18)
				num--;

			if (Main.tile[x, num - 1] == null)
				Main.tile[x, num - 1] = new Tile();

			if (Main.tile[x, num] == null)
				Main.tile[x, num] = new Tile();

			if (Main.tile[x, num + 1] == null)
				Main.tile[x, num + 1] = new Tile();

			bool flag4 = false;
			if (!SolidTile(x, num - 1))
				flag4 = true;

			if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
				flag4 = true;

			if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
				flag4 = true;

			if (flag4) {
				if (Main.tile[x, num].type == Main.tile[x, j].type)
					KillTile(x, num);

				if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
					KillTile(x, num + 1);
			}
			else {
				TightBiome(x, num);
			}
		}

		public static void Place1xX(int x, int y, ushort type, int style = 0) {
			int num = style * 18;
			int num2 = 3;
			if (type == 92)
				num2 = 6;

			bool flag = true;
			for (int i = y - num2 + 1; i < y + 1; i++) {
				if (Main.tile[x, i] == null)
					Main.tile[x, i] = new Tile();

				if (Main.tile[x, i].active())
					flag = false;

				if (type == 93 && Main.tile[x, i].liquid > 0)
					flag = false;
			}

			if (flag && SolidTile2(x, y + 1)) {
				for (int j = 0; j < num2; j++) {
					Main.tile[x, y - num2 + 1 + j].active(active: true);
					Main.tile[x, y - num2 + 1 + j].frameY = (short)(j * 18 + num2 * num);
					Main.tile[x, y - num2 + 1 + j].frameX = 0;
					Main.tile[x, y - num2 + 1 + j].type = type;
				}
			}
		}

		public static int checkXmasTreeDrop(int x, int y, int obj) {
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10) {
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}

			int num3 = 0;
			if ((Main.tile[num, num2].frameY & 1) == 1)
				num3++;

			if ((Main.tile[num, num2].frameY & 2) == 2)
				num3 += 2;

			if ((Main.tile[num, num2].frameY & 4) == 4)
				num3 += 4;

			int num4 = 0;
			if ((Main.tile[num, num2].frameY & 8) == 8)
				num4++;

			if ((Main.tile[num, num2].frameY & 0x10) == 16)
				num4 += 2;

			if ((Main.tile[num, num2].frameY & 0x20) == 32)
				num4 += 4;

			int num5 = 0;
			if ((Main.tile[num, num2].frameY & 0x40) == 64)
				num5++;

			if ((Main.tile[num, num2].frameY & 0x80) == 128)
				num5 += 2;

			if ((Main.tile[num, num2].frameY & 0x100) == 256)
				num5 += 4;

			if ((Main.tile[num, num2].frameY & 0x200) == 512)
				num5 += 8;

			int num6 = 0;
			if ((Main.tile[num, num2].frameY & 0x400) == 1024)
				num6++;

			if ((Main.tile[num, num2].frameY & 0x800) == 2048)
				num6 += 2;

			if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
				num6 += 4;

			if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
				num6 += 8;

			if (obj == 0 && num3 > 0)
				return num3;

			if (obj == 1 && num4 > 0)
				return num4;

			if (obj == 2 && num5 > 0)
				return num5;

			if (obj == 3 && num6 > 0)
				return num6;

			return -1;
		}

		public static void dropXmasTree(int x, int y, int obj) {
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10) {
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}

			int num3 = 0;
			if ((Main.tile[num, num2].frameY & 1) == 1)
				num3++;

			if ((Main.tile[num, num2].frameY & 2) == 2)
				num3 += 2;

			if ((Main.tile[num, num2].frameY & 4) == 4)
				num3 += 4;

			int num4 = 0;
			if ((Main.tile[num, num2].frameY & 8) == 8)
				num4++;

			if ((Main.tile[num, num2].frameY & 0x10) == 16)
				num4 += 2;

			if ((Main.tile[num, num2].frameY & 0x20) == 32)
				num4 += 4;

			int num5 = 0;
			if ((Main.tile[num, num2].frameY & 0x40) == 64)
				num5++;

			if ((Main.tile[num, num2].frameY & 0x80) == 128)
				num5 += 2;

			if ((Main.tile[num, num2].frameY & 0x100) == 256)
				num5 += 4;

			if ((Main.tile[num, num2].frameY & 0x200) == 512)
				num5 += 8;

			int num6 = 0;
			if ((Main.tile[num, num2].frameY & 0x400) == 1024)
				num6++;

			if ((Main.tile[num, num2].frameY & 0x800) == 2048)
				num6 += 2;

			if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
				num6 += 4;

			if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
				num6 += 8;

			if (obj == 0 && num3 > 0) {
				int number = Item.NewItem(x * 16, y * 16, 16, 16, 1874 + num3 - 1);
				if (Main.netMode == 1)
					NetMessage.SendData(21, -1, -1, null, number, 1f);
			}
			else if (obj == 1 && num4 > 0) {
				int number2 = Item.NewItem(x * 16, y * 16, 16, 16, 1878 + num4 - 1);
				if (Main.netMode == 1)
					NetMessage.SendData(21, -1, -1, null, number2, 1f);
			}
			else if (obj == 2 && num5 > 0) {
				int number3 = Item.NewItem(x * 16, y * 16, 16, 16, 1884 + num5 - 1);
				if (Main.netMode == 1)
					NetMessage.SendData(21, -1, -1, null, number3, 1f);
			}
			else if (obj == 3 && num6 > 0) {
				int number4 = Item.NewItem(x * 16, y * 16, 16, 16, 1895 + num6 - 1);
				if (Main.netMode == 1)
					NetMessage.SendData(21, -1, -1, null, number4, 1f);
			}
		}

		public static void setXmasTree(int x, int y, int obj, int style) {
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10) {
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}

			if (obj == 0) {
				if ((style & 1) == 1)
					Main.tile[num, num2].frameY |= 1;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2);

				if ((style & 2) == 2)
					Main.tile[num, num2].frameY |= 2;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -3);

				if ((style & 4) == 4)
					Main.tile[num, num2].frameY |= 4;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -5);
			}

			if (obj == 1) {
				if ((style & 1) == 1)
					Main.tile[num, num2].frameY |= 8;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -9);

				if ((style & 2) == 2)
					Main.tile[num, num2].frameY |= 16;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -17);

				if ((style & 4) == 4)
					Main.tile[num, num2].frameY |= 32;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -33);
			}

			if (obj == 2) {
				if ((style & 1) == 1)
					Main.tile[num, num2].frameY |= 64;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -65);

				if ((style & 2) == 2)
					Main.tile[num, num2].frameY |= 128;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -129);

				if ((style & 4) == 4)
					Main.tile[num, num2].frameY |= 256;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -257);

				if ((style & 8) == 8)
					Main.tile[num, num2].frameY |= 512;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -513);
			}

			if (obj == 3) {
				if ((style & 1) == 1)
					Main.tile[num, num2].frameY |= 1024;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -1025);

				if ((style & 2) == 2)
					Main.tile[num, num2].frameY |= 2048;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2049);

				if ((style & 4) == 4)
					Main.tile[num, num2].frameY |= 4096;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -4097);

				if ((style & 8) == 8)
					Main.tile[num, num2].frameY |= 8192;
				else
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -8193);
			}
		}

		public static int PlaceXmasTree_Direct(int x, int y, int type, int style, int dir) {
			for (short num = 0; num < 4; num = (short)(num + 1)) {
				for (short num2 = 0; num2 < 8; num2 = (short)(num2 + 1)) {
					Tile tile = Main.tile[x + num, y + num2];
					tile.active(active: true);
					tile.type = (ushort)type;
					if (num == 0 && num2 == 0) {
						tile.frameX = 10;
						tile.frameY = 0;
					}
					else {
						tile.frameX = num;
						tile.frameY = num2;
					}
				}
			}

			return 0;
		}

		public static void PlaceXmasTree(int x, int y, ushort type = 171) {
			bool flag = true;
			int num = x - 1;
			int num2 = y - 7;
			for (int i = num; i < num + 4; i++) {
				for (int j = num2; j < num2 + 8; j++) {
					if (Main.tile[i, j].active())
						flag = false;
				}

				if (i > num && i < num + 3 && !SolidTile(i, num2 + 8))
					flag = false;
			}

			if (!flag)
				return;

			int num3 = 0;
			for (int k = num; k < num + 4; k++) {
				int num4 = 0;
				for (int l = num2; l < num2 + 8; l++) {
					Main.tile[k, l].active(active: true);
					if (num3 == 0 && num4 == 0) {
						Main.tile[k, l].frameX = 10;
						Main.tile[k, l].frameY = 0;
					}
					else {
						Main.tile[k, l].frameX = (short)num3;
						Main.tile[k, l].frameY = (short)num4;
					}

					Main.tile[k, l].type = type;
					Main.tile[k, l].active(active: true);
					num4++;
				}

				num3++;
			}
		}

		public static void CheckXmasTree(int x, int y) {
			if (destroyObject)
				return;

			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10) {
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}

			bool flag = false;
			int num3 = 0;
			for (int i = num; i < num + 4; i++) {
				int num4 = 0;
				for (int j = num2; j < num2 + 8; j++) {
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 171) {
						if (num3 != 0 && num4 != 0 && Main.tile[i, j].frameX != num3 && Main.tile[i, j].frameY != num4)
							flag = true;
					}
					else {
						flag = true;
					}

					num4++;
				}

				num3++;
				if (i > num && i < num + 3 && !SolidTile2(i, num2 + 8))
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int k = num; k < num + 4; k++) {
				for (int l = num2; l < num2 + 8; l++) {
					if (Main.tile[k, l].type == 171)
						KillTile(k, l);
				}
			}

			if (TileLoader.Drop(x, y, TileID.ChristmasTree))
				Item.NewItem(x * 16, y * 16, 32, 32, 1873);
			destroyObject = false;
		}

		public static void Place2xX(int x, int y, ushort type, int style = 0) {
			int num = style * 36;
			int num2 = 0;
			int num3 = 3;
			if (type == 105 && style == 34) {
				type = 349;
				style = 0;
				num = 0;
			}

			if (type == 105) {
				int num4 = style / 55;
				num -= 1980 * num4;
				num2 += 54 * num4;
			}

			if (type == 104)
				num3 = 5;

			if (type == 207)
				num3 = 4;

			bool flag = true;
			for (int i = y - num3 + 1; i < y + 1; i++) {
				if (Main.tile[x, i] == null)
					Main.tile[x, i] = new Tile();

				if (Main.tile[x, i].active())
					flag = false;

				if (Main.tile[x + 1, i] == null)
					Main.tile[x + 1, i] = new Tile();

				if (Main.tile[x + 1, i].active())
					flag = false;
			}

			if (flag && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1)) {
				for (int j = 0; j < num3; j++) {
					Main.tile[x, y - num3 + 1 + j].active(active: true);
					Main.tile[x, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
					Main.tile[x, y - num3 + 1 + j].frameX = (short)num;
					Main.tile[x, y - num3 + 1 + j].type = type;
					Main.tile[x + 1, y - num3 + 1 + j].active(active: true);
					Main.tile[x + 1, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
					Main.tile[x + 1, y - num3 + 1 + j].frameX = (short)(num + 18);
					Main.tile[x + 1, y - num3 + 1 + j].type = type;
				}
			}
		}

		public static void Check1x2(int x, int j, ushort type) {
			if (destroyObject)
				return;

			int num = j;
			bool flag = true;
			if (Main.tile[x, num] == null)
				Main.tile[x, num] = new Tile();

			if (Main.tile[x, num + 1] == null)
				Main.tile[x, num + 1] = new Tile();

			int num2 = Main.tile[x, num].frameY;
			int num3 = 0;
			while (num2 >= 40) {
				num2 -= 40;
				num3++;
			}

			if (num2 == 18)
				num--;

			if (Main.tile[x, num] == null)
				Main.tile[x, num] = new Tile();

			if (Main.tile[x, num].frameY == 40 * num3 && Main.tile[x, num + 1].frameY == 40 * num3 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
				flag = false;

			if (Main.tile[x, num + 2] == null)
				Main.tile[x, num + 2] = new Tile();

			if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
				flag = true;

			if (TileLoader.IsSapling(Main.tile[x, num].type)) {
				int originalType = Main.tile[x, num].type;
				int newType = TileID.Saplings;
				int num4 = Main.tile[x, num].frameX / 54;
				int type2 = Main.tile[x, num + 2].type;
				int num5 = -1;
				switch (type2) {
					case 2:
						num5 = 0;
						break;
					case 147:
						num5 = 1;
						break;
					case 60:
						num5 = 2;
						break;
					case 23:
						num5 = 3;
						break;
					case 199:
						num5 = 4;
						break;
					case 109:
						num5 = 5;
						break;
					case 53:
						num5 = 6;
						break;
					case 116:
						num5 = 7;
						break;
					case 234:
						num5 = 8;
						break;
					case 112:
						num5 = 9;
						break;
					case int _ when TileLoader.SaplingGrowthType(type2, ref newType, ref num5):
						break;
					default:
						flag = true;
						break;
				}

				if (!flag && (originalType != newType || num4 != num5)) {
					Main.tile[x, num].type = (ushort)newType;
					Main.tile[x, num + 1].type = (ushort)newType;
					int num6 = 54 * num5;
					num6 += genRand.Next(3) * 18;
					Main.tile[x, num].frameX = (short)num6;
					Main.tile[x, num + 1].frameX = (short)num6;
				}
			}

			if (!flag)
				return;

			destroyObject = true;
			if (Main.tile[x, num].type == type)
				KillTile(x, num);

			if (Main.tile[x, num + 1].type == type)
				KillTile(x, num + 1);

			if (!TileLoader.Drop(x, num, type))
				goto skipDrop;

			if (type == 216)
				Item.NewItem(x * 16, num * 16, 32, 32, 970 + num3);

			if (type == 338)
				Item.NewItem(x * 16, num * 16, 32, 32, 2738);

			if (type == 390)
				Item.NewItem(x * 16, num * 16, 16, 32, 3253);

			switch (type) {
				case 15: {
						int type3;
						if (num3 >= 18 && num3 <= 23) {
							type3 = 1703 + num3 - 18;
						}
						else {
							switch (num3) {
								case 5:
									type3 = 806;
									break;
								case 6:
									type3 = 807;
									break;
								case 7:
									type3 = 808;
									break;
								case 8:
									type3 = 809;
									break;
								case 9:
									type3 = 810;
									break;
								case 10:
									type3 = 826;
									break;
								case 11:
									type3 = 915;
									break;
								case 13:
									type3 = 1396;
									break;
								case 14:
									type3 = 1399;
									break;
								case 15:
									type3 = 1402;
									break;
								case 12:
									type3 = 1143;
									break;
								case 4:
									type3 = 630;
									break;
								case 3:
									type3 = 629;
									break;
								case 2:
									type3 = 628;
									break;
								case 17:
									type3 = 1509;
									break;
								case 1:
									type3 = 358;
									break;
								case 24:
									type3 = 1792;
									break;
								case 25:
									type3 = 1814;
									break;
								case 16:
									type3 = 1459;
									break;
								case 26:
									type3 = 1925;
									break;
								case 27:
									type3 = 2228;
									break;
								case 28:
									type3 = 2288;
									break;
								case 29:
									type3 = 2524;
									break;
								case 30:
									type3 = 2557;
									break;
								case 31:
									type3 = 2572;
									break;
								case 32:
									type3 = 2812;
									break;
								case 33:
									type3 = 3174;
									break;
								case 34:
									type3 = 3176;
									break;
								case 35:
									type3 = 3175;
									break;
								case 36:
									type3 = 3889;
									break;
								default:
									type3 = 34;
									break;
							}
						}

						Item.NewItem(x * 16, num * 16, 32, 32, type3);
						break;
					}
				case 134:
					if (num3 == 1)
						Item.NewItem(x * 16, num * 16, 32, 32, 1220);
					else
						Item.NewItem(x * 16, num * 16, 32, 32, 525);
					break;
			}

			skipDrop:
			destroyObject = false;
		}

		public static void CheckOnTable1x1(int x, int y, int type) {
			if (Main.tile[x, y + 1] == null || (Main.tile[x, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].topSlope() && !Main.tile[x, y + 1].halfBrick()))
				return;

			if (type == 78) {
				if (!SolidTile2(x, y + 1))
					KillTile(x, y);
			}
			else {
				KillTile(x, y);
			}
		}

		public static void CheckSign(int x, int y, ushort type) {
			if (destroyObject)
				return;

			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0 || num2 > Main.maxTilesX || num3 < 0 || num4 > Main.maxTilesY)
				return;

			bool flag = false;
			for (int i = num; i < num2; i++) {
				for (int j = num3; j < num4; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();
				}
			}

			int num5 = Main.tile[x, y].frameX / 18;
			int num6 = Main.tile[x, y].frameY / 18;
			num5 %= 2;
			int num7 = x - num5;
			int num8 = y - num6;
			int num9 = Main.tile[num7, num8].frameX / 18 / 2;
			int num10 = Main.tile[x, y].frameX / 18;
			int num11 = 0;
			while (num10 > 1) {
				num10 -= 2;
				num11++;
			}

			num = num7;
			num2 = num7 + 2;
			num3 = num8;
			num4 = num8 + 2;
			num5 = 0;
			for (int k = num; k < num2; k++) {
				num6 = 0;
				for (int l = num3; l < num4; l++) {
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type) {
						flag = true;
						break;
					}

					if (Main.tile[k, l].frameX / 18 != num5 + num9 * 2 || Main.tile[k, l].frameY / 18 != num6) {
						flag = true;
						break;
					}

					num6++;
				}

				num5++;
			}

			if (!flag) {
				if (type == 85) {
					if (Main.tile[num7, num8 + 2].active() && (Main.tileSolid[Main.tile[num7, num8 + 2].type] || Main.tileSolidTop[Main.tile[num7, num8 + 2].type]) && Main.tile[num7 + 1, num8 + 2].active() && (Main.tileSolid[Main.tile[num7 + 1, num8 + 2].type] || Main.tileSolidTop[Main.tile[num7 + 1, num8 + 2].type]))
						num9 = num11;
					else
						flag = true;
				}
				else if (Main.tile[num7, num8 + 2].active() && (Main.tileSolid[Main.tile[num7, num8 + 2].type] || (Main.tileSolidTop[Main.tile[num7, num8 + 2].type] && !Main.tileNoAttach[Main.tile[num7, num8 + 2].type])) && Main.tile[num7 + 1, num8 + 2].active() && (Main.tileSolid[Main.tile[num7 + 1, num8 + 2].type] || (Main.tileSolidTop[Main.tile[num7 + 1, num8 + 2].type] && !Main.tileNoAttach[Main.tile[num7 + 1, num8 + 2].type]))) {
					num9 = 0;
				}
				else if (Main.tile[num7, num8 - 1].nactive() && Main.tileSolid[Main.tile[num7, num8 - 1].type] && !Main.tileSolidTop[Main.tile[num7, num8 - 1].type] && !Main.tileNoAttach[Main.tile[num7, num8 - 1].type] && Main.tile[num7 + 1, num8 - 1].nactive() && Main.tileSolid[Main.tile[num7 + 1, num8 - 1].type] && !Main.tileSolidTop[Main.tile[num7 + 1, num8 - 1].type] && !Main.tileNoAttach[Main.tile[num7 + 1, num8 - 1].type]) {
					num9 = 1;
				}
				else if (Main.tile[num7 - 1, num8].nactive() && Main.tileSolid[Main.tile[num7 - 1, num8].type] && !Main.tileSolidTop[Main.tile[num7 - 1, num8].type] && !Main.tileNoAttach[Main.tile[num7 - 1, num8].type] && Main.tile[num7 - 1, num8 + 1].nactive() && Main.tileSolid[Main.tile[num7 - 1, num8 + 1].type] && !Main.tileSolidTop[Main.tile[num7 - 1, num8 + 1].type] && !Main.tileNoAttach[Main.tile[num7 - 1, num8 + 1].type]) {
					num9 = 2;
				}
				else if (Main.tile[num7 + 2, num8].nactive() && Main.tileSolid[Main.tile[num7 + 2, num8].type] && !Main.tileSolidTop[Main.tile[num7 + 2, num8].type] && !Main.tileNoAttach[Main.tile[num7 + 2, num8].type] && Main.tile[num7 + 2, num8 + 1].nactive() && Main.tileSolid[Main.tile[num7 + 2, num8 + 1].type] && !Main.tileSolidTop[Main.tile[num7 + 2, num8 + 1].type] && !Main.tileNoAttach[Main.tile[num7 + 2, num8 + 1].type]) {
					num9 = 3;
				}
				else if (Main.tile[num7, num8].wall > 0 && Main.tile[num7 + 1, num8].wall > 0 && Main.tile[num7, num8 + 1].wall > 0 && Main.tile[num7 + 1, num8 + 1].wall > 0) {
					num9 = 4;
				}
				else {
					flag = true;
				}
			}

			if (flag) {
				if (type == 395) {
					int num12 = TEItemFrame.Find(num7, num8);
					if (num12 != -1 && ((TEItemFrame)TileEntity.ByID[num12]).item.stack > 0) {
						((TEItemFrame)TileEntity.ByID[num12]).DropItem();
						if (Main.netMode != 2)
							Main.blockMouse = true;

						return;
					}
				}

				destroyObject = true;
				for (int m = num; m < num2; m++) {
					for (int n = num3; n < num4; n++) {
						if (Main.tile[m, n].type == type)
							KillTile(m, n);
					}
				}

				if (type != 395)
					Sign.KillSign(num7, num8);

				if (!TileLoader.Drop(x, y, type))
					goto skipDrop;

				switch (type) {
					case 85: {
							int type2 = 321;
							if (num11 >= 6 && num11 <= 10)
								type2 = 3229 + num11 - 6;
							else if (num11 >= 1 && num11 <= 5)
								type2 = 1173 + num11 - 1;

							Item.NewItem(x * 16, y * 16, 32, 32, type2);
							break;
						}
					case 395:
						Item.NewItem(num7 * 16, num8 * 16, 32, 32, 3270);
						TEItemFrame.Kill(num7, num8);
						break;
					case 425:
						Item.NewItem(num7 * 16, num8 * 16, 32, 32, 3617);
						break;
					default:
						Item.NewItem(x * 16, y * 16, 32, 32, 171);
						break;
				}

				skipDrop:
				destroyObject = false;
				return;
			}

			int num13 = 36 * num9;
			for (int num14 = 0; num14 < 2; num14++) {
				for (int num15 = 0; num15 < 2; num15++) {
					Main.tile[num7 + num14, num8 + num15].active(active: true);
					Main.tile[num7 + num14, num8 + num15].type = type;
					Main.tile[num7 + num14, num8 + num15].frameX = (short)(num13 + 18 * num14);
					Main.tile[num7 + num14, num8 + num15].frameY = (short)(18 * num15);
				}
			}
		}

		public static bool PlaceSign(int x, int y, ushort type, int Style = 0) {
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0)
				return false;

			if (num2 > Main.maxTilesX)
				return false;

			if (num3 < 0)
				return false;

			if (num4 > Main.maxTilesY)
				return false;

			for (int i = num; i < num2; i++) {
				for (int j = num3; j < num4; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();
				}
			}

			int num5 = x;
			int num6 = y;
			int num7 = 0;
			if (type == 55 || type == 425) {
				if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1)) {
					num6--;
					num7 = 0;
				}
				else if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && Main.tile[x + 1, y - 1].nactive() && Main.tileSolid[Main.tile[x + 1, y - 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y - 1].type]) {
					num7 = 1;
				}
				else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type] && !Main.tileNoAttach[Main.tile[x - 1, y].type] && Main.tile[x - 1, y + 1].nactive() && Main.tileSolid[Main.tile[x - 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x - 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x - 1, y + 1].type]) {
					num7 = 2;
				}
				else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type] && !Main.tileNoAttach[Main.tile[x + 1, y].type] && Main.tile[x + 1, y + 1].nactive() && Main.tileSolid[Main.tile[x + 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x + 1, y + 1].type]) {
					num5--;
					num7 = 3;
				}
				else {
					if (Main.tile[num5, num6].wall <= 0 || Main.tile[num5 + 1, num6].wall <= 0 || Main.tile[num5, num6 + 1].wall <= 0 || Main.tile[num5 + 1, num6 + 1].wall <= 0)
						return false;

					num7 = 4;
				}
			}

			if (Main.tile[num5, num6].active() || Main.tile[num5 + 1, num6].active() || Main.tile[num5, num6 + 1].active() || Main.tile[num5 + 1, num6 + 1].active())
				return false;

			int num8 = 36 * num7;
			for (int k = 0; k < 2; k++) {
				for (int l = 0; l < 2; l++) {
					Main.tile[num5 + k, num6 + l].active(active: true);
					Main.tile[num5 + k, num6 + l].type = type;
					Main.tile[num5 + k, num6 + l].frameX = (short)(num8 + 18 * k);
					Main.tile[num5 + k, num6 + l].frameY = (short)(18 * l);
				}
			}

			return true;
		}

		public static bool Place2x2Horizontal(int x, int y, ushort type, int Style = 0) {
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0)
				return false;

			if (num2 > Main.maxTilesX)
				return false;

			if (num3 < 0)
				return false;

			if (num4 > Main.maxTilesY)
				return false;

			for (int i = num; i < num2; i++) {
				for (int j = num3; j < num4; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();
				}
			}

			int num5 = y;
			int num6 = 0;
			if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1)) {
				num5--;
				num6 = Style;
				if (Main.tile[x, num5].active() || Main.tile[x + 1, num5].active() || Main.tile[x, num5 + 1].active() || Main.tile[x + 1, num5 + 1].active())
					return false;

				int num7 = 36 * num6;
				for (int k = 0; k < 2; k++) {
					for (int l = 0; l < 2; l++) {
						Main.tile[x + k, num5 + l].active(active: true);
						Main.tile[x + k, num5 + l].type = type;
						Main.tile[x + k, num5 + l].frameX = (short)(num7 + 18 * k);
						Main.tile[x + k, num5 + l].frameY = (short)(18 * l);
					}
				}

				return true;
			}

			return false;
		}

		public static Color paintColor(int color) {
			Color white = Color.White;
			if (color == 1 || color == 13) {
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = 0;
			}

			if (color == 2 || color == 14) {
				white.R = byte.MaxValue;
				white.G = 127;
				white.B = 0;
			}

			if (color == 3 || color == 15) {
				white.R = byte.MaxValue;
				white.G = byte.MaxValue;
				white.B = 0;
			}

			if (color == 4 || color == 16) {
				white.R = 127;
				white.G = byte.MaxValue;
				white.B = 0;
			}

			if (color == 5 || color == 17) {
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = 0;
			}

			if (color == 6 || color == 18) {
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = 127;
			}

			if (color == 7 || color == 19) {
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = byte.MaxValue;
			}

			if (color == 8 || color == 20) {
				white.R = 0;
				white.G = 127;
				white.B = byte.MaxValue;
			}

			if (color == 9 || color == 21) {
				white.R = 0;
				white.G = 0;
				white.B = byte.MaxValue;
			}

			if (color == 10 || color == 22) {
				white.R = 127;
				white.G = 0;
				white.B = byte.MaxValue;
			}

			if (color == 11 || color == 23) {
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = byte.MaxValue;
			}

			if (color == 12 || color == 24) {
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = 127;
			}

			if (color == 25) {
				white.R = 75;
				white.G = 75;
				white.B = 75;
			}

			if (color == 26) {
				white.R = byte.MaxValue;
				white.G = byte.MaxValue;
				white.B = byte.MaxValue;
			}

			if (color == 27) {
				white.R = 175;
				white.G = 175;
				white.B = 175;
			}

			if (color == 28) {
				white.R = byte.MaxValue;
				white.G = 178;
				white.B = 125;
			}

			if (color == 29) {
				white.R = 25;
				white.G = 25;
				white.B = 25;
			}

			if (color == 30) {
				white.R = 200;
				white.G = 200;
				white.B = 200;
				white.A = 150;
			}

			return white;
		}

		public static void paintEffect(int x, int y, byte color, byte oldColor) {
			int color2 = color;
			if (color == 0)
				color2 = oldColor;

			Color newColor = paintColor(color2);
			for (int i = 0; i < 10; i++) {
				int num = Dust.NewDust(new Vector2(x * 16, y * 16), 16, 16, 143, 0f, 0f, 50, newColor);
				if (genRand.Next(2) == 0) {
					Main.dust[num].noGravity = true;
					Main.dust[num].scale *= 1.2f;
				}
				else {
					Main.dust[num].scale *= 0.5f;
				}
			}
		}

		public static bool paintTile(int x, int y, byte color, bool broadCast = false) {
			if (Main.tile[x, y] == null || !Main.tile[x, y].active())
				return false;

			byte oldColor = Main.tile[x, y].color();
			Main.tile[x, y].color(color);
			if (broadCast)
				NetMessage.SendData(63, -1, -1, null, x, y, (int)color);

			paintEffect(x, y, color, oldColor);
			return true;
		}

		public static bool paintWall(int x, int y, byte color, bool broadCast = false) {
			if (Main.tile[x, y] == null || Main.tile[x, y].wall == 0)
				return false;

			byte oldColor = Main.tile[x, y].wallColor();
			Main.tile[x, y].wallColor(color);
			if (broadCast)
				NetMessage.SendData(64, -1, -1, null, x, y, (int)color);

			paintEffect(x, y, color, oldColor);
			return true;
		}

		public static void Place3x3Wall(int x, int y, ushort type, int style) {
			int num = x - 1;
			int num2 = y - 1;
			bool flag = true;
			for (int i = num; i < num + 3; i++) {
				for (int j = num2; j < num2 + 3; j++) {
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0) {
						flag = false;
						break;
					}
				}
			}

			if (!flag)
				return;

			int num3 = 0;
			while (style > 35) {
				num3++;
				style -= 36;
			}

			int num4 = style * 54;
			int num5 = num3 * 54;
			for (int k = num; k < num + 3; k++) {
				for (int l = num2; l < num2 + 3; l++) {
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
				}
			}
		}

		public static void Check3x3Wall(int x, int y) {
			if (destroyObject)
				return;

			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = 0;
			int num3 = Main.tile[x, y].frameX / 18;
			while (num3 >= 3) {
				num3 -= 3;
				num++;
			}

			int num4 = x - num3;
			int num5 = Main.tile[x, y].frameY / 18;
			while (num5 >= 3) {
				num5 -= 3;
				num2++;
			}

			int num6 = y - num5;
			num5 = num2 * 54;
			num3 = num * 54;
			for (int i = num4; i < num4 + 3; i++) {
				for (int j = num6; j < num6 + 3; j++) {
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameX != num3 + (i - num4) * 18 || Main.tile[i, j].frameY != num5 + (j - num6) * 18) {
						flag = true;
						break;
					}
				}
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int k = num4; k < num4 + 3; k++) {
				for (int l = num6; l < num6 + 3; l++) {
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
						KillTile(k, l);
				}
			}

			switch (type) {
				case 240:
					num += num2 * 36;
					switch (num) {
						case 37:
							Item.NewItem(x * 16, y * 16, 32, 32, 1856);
							break;
						case 36:
							Item.NewItem(x * 16, y * 16, 32, 32, 1855);
							break;
						case 38:
							Item.NewItem(x * 16, y * 16, 32, 32, 1960);
							break;
						case 39:
							Item.NewItem(x * 16, y * 16, 32, 32, 1961);
							break;
						case 40:
							Item.NewItem(x * 16, y * 16, 32, 32, 1962);
							break;
						case 33:
							Item.NewItem(x * 16, y * 16, 32, 32, 1574);
							break;
						case 34:
							Item.NewItem(x * 16, y * 16, 32, 32, 1575);
							break;
						case 35:
							Item.NewItem(x * 16, y * 16, 32, 32, 1576);
							break;
						case 18:
							Item.NewItem(x * 16, y * 16, 32, 32, 1419);
							break;
						case 19:
							Item.NewItem(x * 16, y * 16, 32, 32, 1420);
							break;
						case 20:
							Item.NewItem(x * 16, y * 16, 32, 32, 1427);
							break;
						case 21:
							Item.NewItem(x * 16, y * 16, 32, 32, 1428);
							break;
						case 54:
							Item.NewItem(x * 16, y * 16, 32, 32, 2489);
							break;
						case 55:
							Item.NewItem(x * 16, y * 16, 32, 32, 2589);
							break;
						case 56:
							Item.NewItem(x * 16, y * 16, 32, 32, 3357);
							break;
						case 57:
							Item.NewItem(x * 16, y * 16, 32, 32, 3358);
							break;
						case 58:
							Item.NewItem(x * 16, y * 16, 32, 32, 3359);
							break;
						case 59:
							Item.NewItem(x * 16, y * 16, 32, 32, 3595);
							break;
						case 60:
							Item.NewItem(x * 16, y * 16, 32, 32, 3867);
							break;
						case 61:
							Item.NewItem(x * 16, y * 16, 32, 32, 3866);
							break;
						case 62:
							Item.NewItem(x * 16, y * 16, 32, 32, 3868);
							break;
						case 41:
						case 42:
						case 43:
						case 44:
						case 45:
							Item.NewItem(x * 16, y * 16, 32, 32, 2114 + num - 41);
							break;
						default:
							if (num >= 46 && num <= 53)
								Item.NewItem(x * 16, y * 16, 32, 32, 2442 + num - 46);
							else if (num >= 22 && num <= 25)
								Item.NewItem(x * 16, y * 16, 32, 32, 1440 + num - 22);
							else if (num >= 26 && num <= 29)
								Item.NewItem(x * 16, y * 16, 32, 32, 1496 + num - 26);
							else if (num >= 30 && num <= 32)
								Item.NewItem(x * 16, y * 16, 32, 32, 1538 + num - 30);
							else
								Item.NewItem(x * 16, y * 16, 32, 32, 1360 + num);
							break;
					}
					break;
				case 440: {
						int num7 = -1;
						int num8 = -1;
						switch (num) {
							case 0:
								num7 = 3644;
								num8 = 1526;
								break;
							case 1:
								num7 = 3645;
								num8 = 1524;
								break;
							case 2:
								num7 = 3646;
								num8 = 1525;
								break;
							case 3:
								num7 = 3647;
								num8 = 1523;
								break;
							case 4:
								num7 = 3648;
								num8 = 1522;
								break;
							case 5:
								num7 = 3649;
								num8 = 1527;
								break;
							case 6:
								num7 = 3650;
								num8 = 3643;
								break;
						}

						if (num7 != -1)
							Item.NewItem(x * 16, y * 16, 32, 32, num7);

						if (num8 != -1 && num2 == 1)
							Item.NewItem(x * 16, y * 16, 32, 32, num8);

						break;
					}
			}

			destroyObject = false;
		}

		public static void Place2x3Wall(int x, int y, ushort type, int style) {
			int num = y - 1;
			bool flag = true;
			for (int i = x; i < x + 2; i++) {
				for (int j = num; j < num + 3; j++) {
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0) {
						flag = false;
						break;
					}
				}
			}

			if (!flag)
				return;

			int num2 = style * 36;
			int num3 = 0;
			for (int k = x; k < x + 2; k++) {
				for (int l = num; l < num + 3; l++) {
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num2 + 18 * (k - x));
					Main.tile[k, l].frameY = (short)(num3 + 18 * (l - num));
				}
			}
		}

		public static void Check2x3Wall(int x, int y) {
			if (destroyObject)
				return;

			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameX / 18;
			while (num2 >= 2) {
				num2 -= 2;
				num++;
			}

			int num3 = x - num2;
			int num4 = y - Main.tile[x, y].frameY / 18;
			num2 = num * 36;
			for (int i = num3; i < num3 + 2; i++) {
				for (int j = num4; j < num4 + 3; j++) {
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameX != num2 + (i - num3) * 18 || Main.tile[i, j].frameY != (j - num4) * 18) {
						flag = true;
						break;
					}
				}
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int k = num3; k < num3 + 2; k++) {
				for (int l = num4; l < num4 + 3; l++) {
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
						KillTile(k, l);
				}
			}

			if (type == 245) {
				switch (num) {
					case 6:
						Item.NewItem(x * 16, y * 16, 32, 32, 1577);
						break;
					case 5:
						Item.NewItem(x * 16, y * 16, 32, 32, 1495);
						break;
					default:
						Item.NewItem(x * 16, y * 16, 32, 32, 1474 + num);
						break;
				}
			}

			destroyObject = false;
		}

		public static void Place3x2Wall(int x, int y, ushort type, int style) {
			int num = x - 1;
			bool flag = true;
			for (int i = num; i < num + 3; i++) {
				for (int j = y; j < y + 2; j++) {
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0) {
						flag = false;
						break;
					}
				}
			}

			if (!flag)
				return;

			int num2 = 0;
			int num3 = style * 36;
			for (int k = num; k < num + 3; k++) {
				for (int l = y; l < y + 2; l++) {
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num2 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num3 + 18 * (l - y));
				}
			}
		}

		public static void Check3x2Wall(int x, int y) {
			if (destroyObject)
				return;

			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			while (num2 >= 2) {
				num2 -= 2;
				num++;
			}

			int num3 = y - num2;
			int num4 = x - Main.tile[x, y].frameX / 18;
			num2 = num * 36;
			for (int i = num4; i < num4 + 3; i++) {
				for (int j = num3; j < num3 + 2; j++) {
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18) {
						flag = true;
						break;
					}
				}
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int k = num4; k < num4 + 3; k++) {
				for (int l = num3; l < num3 + 2; l++) {
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
						KillTile(k, l);
				}
			}

			if (type == 246) {
				switch (num) {
					case 16:
						Item.NewItem(x * 16, y * 16, 32, 32, 1541);
						break;
					case 17:
						Item.NewItem(x * 16, y * 16, 32, 32, 1542);
						break;
					case 18:
						Item.NewItem(x * 16, y * 16, 32, 32, 1908);
						break;
					default:
						Item.NewItem(x * 16, y * 16, 32, 32, 1479 + num);
						break;
				}
			}

			destroyObject = false;
		}

		public static void Place4x3Wall(int x, int y, ushort type, int style) {
			int num = x - 1;
			int num2 = y - 1;
			bool flag = true;
			for (int i = num; i < num + 4; i++) {
				for (int j = num2; j < num2 + 3; j++) {
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0) {
						flag = false;
						break;
					}
				}
			}

			if (!flag)
				return;

			int num3 = 0;
			int num4 = style * 54;
			for (int k = num; k < num + 4; k++) {
				for (int l = num2; l < num2 + 3; l++) {
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num3 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num4 + 18 * (l - num2));
				}
			}
		}

		public static void Check4x3Wall(int x, int y) {
			if (destroyObject)
				return;

			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			while (num2 >= 3) {
				num2 -= 3;
				num++;
			}

			int num3 = y - num2;
			int num4 = x - Main.tile[x, y].frameX / 18;
			num2 = num * 54;
			for (int i = num4; i < num4 + 4; i++) {
				for (int j = num3; j < num3 + 3; j++) {
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18) {
						flag = true;
						break;
					}
				}
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int k = num4; k < num4 + 4; k++) {
				for (int l = num3; l < num3 + 3; l++) {
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
						KillTile(k, l);
				}
			}

			if (type == 241)
				Item.NewItem(x * 16, y * 16, 32, 32, 1417);

			destroyObject = false;
		}

		public static void Place6x4Wall(int x, int y, ushort type, int style) {
			int num = x - 2;
			int num2 = y - 2;
			bool flag = true;
			for (int i = num; i < num + 6; i++) {
				for (int j = num2; j < num2 + 4; j++) {
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0) {
						flag = false;
						break;
					}
				}
			}

			if (!flag)
				return;

			int num3 = 27;
			int num4 = style / num3 * 108;
			int num5 = style % num3 * 72;
			for (int k = num; k < num + 6; k++) {
				for (int l = num2; l < num2 + 4; l++) {
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
				}
			}
		}

		public static void Check6x4Wall(int x, int y) {
			if (destroyObject)
				return;

			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			int num3 = Main.tile[x, y].frameX / 18;
			num = 27 * (num3 / 6) + (num2 >> 2);
			num2 %= 4;
			num3 %= 6;
			int num4 = y - num2;
			int num5 = x - Main.tile[x, y].frameX / 18 % 6;
			num2 = num % 27 * 72;
			num3 = num / 27 * 108;
			for (int i = num5; i < num5 + 6; i++) {
				for (int j = num4; j < num4 + 4; j++) {
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num4) * 18 || Main.tile[i, j].frameX != num3 + (i - num5) * 18) {
						flag = true;
						break;
					}
				}
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int k = num5; k < num5 + 6; k++) {
				for (int l = num4; l < num4 + 4; l++) {
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
						KillTile(k, l);
				}
			}

			if (type == 242) {
				switch (num) {
					case 30:
						Item.NewItem(x * 16, y * 16, 32, 32, 2995);
						break;
					case 31:
					case 32:
					case 33:
					case 34:
					case 35:
						Item.NewItem(x * 16, y * 16, 32, 32, 3055 + num - 31);
						break;
					default:
						if (num >= 27 && num <= 29)
							Item.NewItem(x * 16, y * 16, 32, 32, 2865 + num - 27);
						else if (num == 36)
							Item.NewItem(x * 16, y * 16, 32, 32, 3596);
						else if (num == 26)
							Item.NewItem(x * 16, y * 16, 32, 32, 2497);
						else if (num == 25)
							Item.NewItem(x * 16, y * 16, 32, 32, 2495);
						else if (num >= 22)
							Item.NewItem(x * 16, y * 16, 32, 32, 2281 + num - 22);
						else if (num >= 17)
							Item.NewItem(x * 16, y * 16, 32, 32, 1846 + num - 17);
						else if (num == 16)
							Item.NewItem(x * 16, y * 16, 32, 32, 1573);
						else if (num >= 13)
							Item.NewItem(x * 16, y * 16, 32, 32, 1500 + num - 13);
						else if (num >= 6)
							Item.NewItem(x * 16, y * 16, 32, 32, 1433 + num - 6);
						else
							Item.NewItem(x * 16, y * 16, 32, 32, 1421 + num);
						break;
				}
			}

			destroyObject = false;
		}

		public static void Place1x1(int x, int y, int type, int style = 0) {
			Tile tile = Main.tile[x, y];
			if (Main.tile[x, y] == null) {
				tile = new Tile();
				Main.tile[x, y] = tile;
			}

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (type == 324) {
				if (SolidTile2(x, y + 1) || (Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type])) {
					tile.active(active: true);
					tile.type = (ushort)type;
					tile.frameX = (short)(22 * genRand.Next(2));
					tile.frameY = (short)(22 * style);
				}
			}
			else if (SolidTile2(x, y + 1) && !tile.active()) {
				tile.active(active: true);
				tile.type = (ushort)type;
				switch (type) {
					case 324:
						tile.frameX = (short)(22 * genRand.Next(2));
						tile.frameY = (short)(22 * style);
						break;
					case 36:
					case 144:
					case 239:
						tile.frameX = (short)(style * 18);
						tile.frameY = 0;
						break;
					default:
						tile.frameY = (short)(style * 18);
						break;
				}
			}
		}

		public static void Check1x1(int x, int y, int type) {
			if (Main.tile[x, y + 1] != null && !SolidTileAllowBottomSlope(x, y + 1))
				KillTile(x, y);
		}

		public static void CheckLogicTiles(int x, int y, int type) {
			if (type == 419) {
				Tile tile = Main.tile[x, y + 1];
				if (tile != null && (!tile.active() || (tile.type != 420 && tile.type != 419))) {
					KillTile(x, y);
					return;
				}
			}

			Tile tile2 = Main.tile[x, y];
			bool flag = false;
			if (tile2.frameX % 18 != 0)
				flag = true;

			if (tile2.frameY % 18 != 0)
				flag = true;

			if (flag)
				KillTile(x, y);
		}

		public static void PlaceLogicTiles(int x, int y, int type, int style = 0) {
			Tile tile = Main.tile[x, y];
			if (Main.tile[x, y] == null) {
				tile = new Tile();
				Main.tile[x, y] = tile;
			}

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (type == 419) {
				if (Main.tile[x, y + 1].active() && (Main.tile[x, y + 1].type == 419 || Main.tile[x, y + 1].type == 420)) {
					tile.active(active: true);
					tile.type = (ushort)type;
					tile.frameX = (short)(style * 18);
					tile.frameY = 0;
				}
			}
			else if (!tile.active()) {
				tile.active(active: true);
				tile.type = (ushort)type;
				tile.frameX = 0;
				tile.frameY = (short)(18 * style);
			}
		}

		public static void PlaceOnTable1x1(int x, int y, int type, int style = 0) {
			bool flag = false;
			if (Main.tile[x, y] == null)
				Main.tile[x, y] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type])
				flag = true;

			if (type == 78 && !Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
				flag = true;

			if (flag) {
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].type = (ushort)type;
				if (type == 33) {
					Main.tile[x, y].frameX = 0;
					Main.tile[x, y].frameY = (short)(style * 22);
				}
				else {
					Main.tile[x, y].frameX = (short)(style * 18);
					Main.tile[x, y].frameY = 0;
				}

				if (type == 50)
					Main.tile[x, y].frameX = (short)(18 * genRand.Next(5));
			}
		}

		public static bool PlaceAlch(int x, int y, int style) {
			if (Main.tile[x, y] == null)
				Main.tile[x, y] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0) {
				bool flag = false;
				switch (style) {
					case 0:
						if (Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 109)
							flag = true;
						if (Main.tile[x, y].liquid > 0)
							flag = true;
						break;
					case 1:
						if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0)
							flag = true;
						break;
					case 2:
						if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0)
							flag = true;
						break;
					case 3:
						if (Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0)
							flag = true;
						break;
					case 4:
						if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
					case 5:
						if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && !Main.tile[x, y].lava())
							flag = true;
						break;
					case 6:
						if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
				}

				if (!flag) {
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].type = 82;
					Main.tile[x, y].frameX = (short)(18 * style);
					Main.tile[x, y].frameY = 0;
					return true;
				}
			}

			return false;
		}

		public static void GrowSpike(int i, int j, ushort spikeType, ushort landType) {
			int num = i;
			int num2 = j;
			int num3 = 0;
			if (Main.tile[num + 1, num2].active() && Main.tile[num + 1, num2].type == spikeType)
				num3++;

			if (Main.tile[num - 1, num2].active() && Main.tile[num - 1, num2].type == spikeType)
				num3++;

			if (Main.tile[num, num2 + 1].active() && Main.tile[num, num2 + 1].type == spikeType)
				num3++;

			if (Main.tile[num, num2 - 1].active() && Main.tile[num, num2 - 1].type == spikeType)
				num3++;

			if (num3 >= 3 && Main.tile[i, j].type != landType)
				return;

			switch (genRand.Next(4)) {
				case 0:
					num2--;
					break;
				case 1:
					num2++;
					break;
				case 2:
					num--;
					break;
				case 3:
					num++;
					break;
			}

			if (Main.tile[num, num2].active())
				return;

			num3 = 0;
			if (Main.tile[num + 1, num2].active() && Main.tile[num + 1, num2].type == spikeType)
				num3++;

			if (Main.tile[num - 1, num2].active() && Main.tile[num - 1, num2].type == spikeType)
				num3++;

			if (Main.tile[num, num2 + 1].active() && Main.tile[num, num2 + 1].type == spikeType)
				num3++;

			if (Main.tile[num, num2 - 1].active() && Main.tile[num, num2 - 1].type == spikeType)
				num3++;

			if (num3 >= 2)
				return;

			int num4 = 7;
			int num5 = num - num4;
			int num6 = num + num4;
			int num7 = num2 - num4;
			int num8 = num2 + num4;
			bool flag = false;
			for (int k = num5; k < num6; k++) {
				for (int l = num7; l < num8; l++) {
					if (Math.Abs(k - num) * 2 + Math.Abs(l - num2) < 9 && Main.tile[k, l].active() && Main.tile[k, l].type == landType && Main.tile[k, l - 1].active() && Main.tile[k, l - 1].type == spikeType && Main.tile[k, l - 1].liquid == 0) {
						flag = true;
						break;
					}
				}
			}

			if (flag) {
				Main.tile[num, num2].type = spikeType;
				Main.tile[num, num2].active(active: true);
				SquareTileFrame(num, num2);
				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, num, num2, 3);
			}
		}

		public static void GrowAlch(int x, int y) {
			if (!Main.tile[x, y].active())
				return;

			if (Main.tile[x, y].type == 82 && genRand.Next(50) == 0) {
				bool flag = false;
				if (Main.tile[x, y].frameX == 108) {
					if (genRand.Next(3) != 0)
						flag = true;
				}
				else {
					flag = true;
				}

				if (flag) {
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, x, y, 1);

					SquareTileFrame(x, y);
				}
			}
			else if (Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 0 && genRand.Next(50) == 0) {
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, x, y, 1);

				SquareTileFrame(x, y);
			}
			else if (!Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 18 && genRand.Next(50) == 0) {
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, x, y, 1);

				SquareTileFrame(x, y);
			}
			else if (Main.tile[x, y].frameX == 36 && genRand.Next(3) != 0) {
				if (Main.tile[x, y].type == 83) {
					if (genRand.Next(2) == 0) {
						Main.tile[x, y].type = 84;
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, x, y, 1);
					}
				}
				else if (genRand.Next(5) == 0 || Main.tile[x, y].type == 84) {
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, x, y, 1);
				}
			}
			else if (Main.tile[x, y].frameX == 108 && Main.tile[x, y].type == 83 && genRand.Next(80) == 0) {
				Main.tile[x, y].type = 84;
				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, x, y, 1);

				SquareTileFrame(x, y);
			}
		}

		public static void PlantAlch() {
			int num = genRand.Next(20, Main.maxTilesX - 20);
			int num2 = 0;
			for (num2 = ((genRand.Next(40) == 0) ? genRand.Next((int)(Main.rockLayer + (double)Main.maxTilesY) / 2, Main.maxTilesY - 20) : ((genRand.Next(10) != 0) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20) : genRand.Next(0, Main.maxTilesY - 20))); num2 < Main.maxTilesY - 20 && !Main.tile[num, num2].active(); num2++) {
			}

			if (!Main.tile[num, num2].nactive() || Main.tile[num, num2 - 1].active() || Main.tile[num, num2 - 1].liquid != 0)
				return;

			int num3 = 15;
			int num4 = 5;
			int num5 = 0;
			num3 = (int)((float)num3 * ((float)Main.maxTilesX / 4200f));
			int num6 = Utils.Clamp(num - num3, 4, Main.maxTilesX - 4);
			int num7 = Utils.Clamp(num + num3, 4, Main.maxTilesX - 4);
			int num8 = Utils.Clamp(num2 - num3, 4, Main.maxTilesY - 4);
			int num9 = Utils.Clamp(num2 + num3, 4, Main.maxTilesY - 4);
			for (int i = num6; i <= num7; i++) {
				for (int j = num8; j <= num9; j++) {
					if (Main.tileAlch[Main.tile[i, j].type])
						num5++;
				}
			}

			if (num5 < num4) {
				if (Main.tile[num, num2].type == 2 || Main.tile[num, num2].type == 109)
					PlaceAlch(num, num2 - 1, 0);

				if (Main.tile[num, num2].type == 60)
					PlaceAlch(num, num2 - 1, 1);

				if (Main.tile[num, num2].type == 0 || Main.tile[num, num2].type == 59)
					PlaceAlch(num, num2 - 1, 2);

				if (Main.tile[num, num2].type == 23 || Main.tile[num, num2].type == 25 || Main.tile[num, num2].type == 203 || Main.tile[num, num2].type == 199)
					PlaceAlch(num, num2 - 1, 3);

				if (Main.tile[num, num2].type == 53 || Main.tile[num, num2].type == 116)
					PlaceAlch(num, num2 - 1, 4);

				if (Main.tile[num, num2].type == 57)
					PlaceAlch(num, num2 - 1, 5);

				if (Main.tile[num, num2].type == 147 || Main.tile[num, num2].type == 163 || Main.tile[num, num2].type == 164 || Main.tile[num, num2].type == 161 || Main.tile[num, num2].type == 200)
					PlaceAlch(num, num2 - 1, 6);

				if (Main.tile[num, num2 - 1].active() && Main.netMode == 2)
					NetMessage.SendTileSquare(-1, num, num2 - 1, 1);
			}
		}

		public static void CheckAlch(int x, int y) {
			if (Main.tile[x, y] == null)
				Main.tile[x, y] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			bool flag = false;
			if (!Main.tile[x, y + 1].active())
				flag = true;

			if (Main.tile[x, y + 1].halfBrick())
				flag = true;

			int num = Main.tile[x, y].frameX / 18;
			Main.tile[x, y].frameY = 0;
			if (!flag) {
				switch (num) {
					case 0:
						if (Main.tile[x, y + 1].type != 109 && Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
					case 1:
						if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
					case 2:
						if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
					case 3:
						if (Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
					case 4:
						if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
					case 5:
						if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && !Main.tile[x, y].lava())
							flag = true;
						if (Main.tile[x, y].type == 82 || !Main.tile[x, y].lava() || Main.tile[x, y].type == 82 || !Main.tile[x, y].lava() || Main.netMode == 1)
							break;
						if (Main.tile[x, y].liquid > 16) {
							if (Main.tile[x, y].type == 83) {
								Main.tile[x, y].type = 84;
								if (Main.netMode == 2)
									NetMessage.SendTileSquare(-1, x, y, 1);
							}
						}
						else if (Main.tile[x, y].type == 84) {
							Main.tile[x, y].type = 83;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, x, y, 1);
						}
						break;
					case 6:
						if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
							flag = true;
						if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
							flag = true;
						break;
				}
			}

			if (flag)
				KillTile(x, y);
		}

		public static void CheckBanner(int x, int j, byte type) {
			if (destroyObject)
				return;

			int num = Main.tile[x, j].frameY / 18;
			int num2 = 0;
			while (num >= 3) {
				num -= 3;
				num2++;
			}

			num = j - num;
			int frameX = Main.tile[x, j].frameX;
			bool flag = false;
			for (int i = 0; i < 3; i++) {
				if (Main.tile[x, num + i] == null)
					Main.tile[x, num + i] = new Tile();

				if (!Main.tile[x, num + i].active())
					flag = true;
				else if (Main.tile[x, num + i].type != type)
					flag = true;
				else if (Main.tile[x, num + i].frameY != i * 18 + num2 * 18 * 3)
					flag = true;
				else if (Main.tile[x, num + i].frameX != frameX)
					flag = true;
			}

			if (Main.tile[x, num - 1] == null)
				Main.tile[x, num - 1] = new Tile();

			if (!Main.tile[x, num - 1].nactive())
				flag = true;

			if ((!Main.tile[x, num - 1].topSlope() && !Main.tile[x, num - 1].halfBrick() && !Main.tileSolid[Main.tile[x, num - 1].type]) || (Main.tileSolidTop[Main.tile[x, num - 1].type] && (!TileID.Sets.Platforms[Main.tile[x, num - 1].type] || (!Main.tile[x, num - 1].halfBrick() && !Main.tile[x, num - 1].topSlope()))) || TileID.Sets.NotReallySolid[Main.tile[x, num - 1].type] || Main.tile[x, num - 1].bottomSlope())
				flag = true;

			if (!flag)
				return;

			destroyObject = true;
			for (int k = 0; k < 3; k++) {
				if (Main.tile[x, num + k].type == type)
					KillTile(x, num + k);
			}

			if (!TileLoader.Drop(x, num + 1, type))
				goto skipDrop;

			if (type == 91) {
				int num3 = frameX / 18;
				num3 += num2 * 111;
				if (num3 >= 278)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3559 + num3);
				else if (num3 >= 273)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3516 + num3);
				else if (num3 >= 272)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3780);
				else if (num3 >= 270)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3323 + num3);
				else if (num3 >= 207)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3183 + num3);
				else if (num3 >= 109)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 2788 + num3);
				else if (num3 >= 22)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 1593 + num3);
				else if (num3 >= 10 && num3 <= 15)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 1441 + num3);
				else if (num3 >= 16 && num3 <= 21)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 1448 + num3);
				else if (num3 >= 7 && num3 <= 9)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 838 + num3);
				else if (num3 >= 4 && num3 <= 6)
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 785 + num3);
				else
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 337 + num3);
			}

			skipDrop:
			destroyObject = false;
		}

		public static void PlaceBanner(int x, int y, ushort type, int style = 0) {
			int num = style * 18;
			int num2 = 0;
			if (style >= 90) {
				num -= 1620;
				num2 += 54;
			}

			if (Main.tile[x, y - 1] == null)
				Main.tile[x, y - 1] = new Tile();

			if (Main.tile[x, y] == null)
				Main.tile[x, y] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (Main.tile[x, y + 2] == null)
				Main.tile[x, y + 2] = new Tile();

			if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active() && !Main.tile[x, y + 2].active()) {
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)num2;
				Main.tile[x, y].frameX = (short)num;
				Main.tile[x, y].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].frameY = (short)(num2 + 18);
				Main.tile[x, y + 1].frameX = (short)num;
				Main.tile[x, y + 1].type = type;
				Main.tile[x, y + 2].active(active: true);
				Main.tile[x, y + 2].frameY = (short)(num2 + 36);
				Main.tile[x, y + 2].frameX = (short)num;
				Main.tile[x, y + 2].type = type;
			}
		}

		public static void PlaceMan(int i, int j, int dir) {
			for (int k = i; k <= i + 1; k++) {
				for (int l = j - 2; l <= j; l++) {
					if (Main.tile[k, l].active())
						return;
				}
			}

			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1)) {
				byte b = 0;
				if (dir == 1)
					b = 36;

				Main.tile[i, j - 2].active(active: true);
				Main.tile[i, j - 2].frameY = 0;
				Main.tile[i, j - 2].frameX = b;
				Main.tile[i, j - 2].type = 128;
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].frameY = 18;
				Main.tile[i, j - 1].frameX = b;
				Main.tile[i, j - 1].type = 128;
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = 36;
				Main.tile[i, j].frameX = b;
				Main.tile[i, j].type = 128;
				Main.tile[i + 1, j - 2].active(active: true);
				Main.tile[i + 1, j - 2].frameY = 0;
				Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 2].type = 128;
				Main.tile[i + 1, j - 1].active(active: true);
				Main.tile[i + 1, j - 1].frameY = 18;
				Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 1].type = 128;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = 36;
				Main.tile[i + 1, j].frameX = (byte)(18 + b);
				Main.tile[i + 1, j].type = 128;
			}
		}

		public static void PlaceWoman(int i, int j, int dir) {
			for (int k = i; k <= i + 1; k++) {
				for (int l = j - 2; l <= j; l++) {
					if (Main.tile[k, l].active())
						return;
				}
			}

			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1)) {
				byte b = 0;
				if (dir == 1)
					b = 36;

				Main.tile[i, j - 2].active(active: true);
				Main.tile[i, j - 2].frameY = 0;
				Main.tile[i, j - 2].frameX = b;
				Main.tile[i, j - 2].type = 269;
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].frameY = 18;
				Main.tile[i, j - 1].frameX = b;
				Main.tile[i, j - 1].type = 269;
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = 36;
				Main.tile[i, j].frameX = b;
				Main.tile[i, j].type = 269;
				Main.tile[i + 1, j - 2].active(active: true);
				Main.tile[i + 1, j - 2].frameY = 0;
				Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 2].type = 269;
				Main.tile[i + 1, j - 1].active(active: true);
				Main.tile[i + 1, j - 1].frameY = 18;
				Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 1].type = 269;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = 36;
				Main.tile[i + 1, j].frameX = (byte)(18 + b);
				Main.tile[i + 1, j].type = 269;
			}
		}

		public static void CheckWeaponsRack(int i, int j) {
			if (destroyObject)
				return;

			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3 = Main.tile[i, j].frameX;
			int num4 = 0;
			while (num3 >= 5000) {
				num3 -= 5000;
				num4++;
			}

			if (num4 != 0)
				num3 = (num4 - 1) * 18;

			num3 %= 54;
			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k < 3; k++) {
				for (int l = 0; l < 3; l++) {
					int num5 = num + k;
					int num6 = num2 + l;
					int num7 = Main.tile[num5, num6].frameX;
					int num8 = 0;
					while (num7 >= 5000) {
						num7 -= 5000;
						num8++;
					}

					if (num8 != 0)
						num7 = (num8 - 1) * 18;

					num7 %= 54;
					if (!Main.tile[num5, num6].active() || Main.tile[num5, num6].type != 334 || Main.tile[num5, num6].wall <= 0 || Main.tile[num5, num6].frameY != l * 18 || num7 != k * 18)
						flag = true;
				}
			}

			if (!flag)
				return;

			destroyObject = true;
			if (TileLoader.Drop(i, j, TileID.WeaponsRack))
				Item.NewItem(i * 16, j * 16, 48, 48, 2699);
			for (int m = 0; m < 3; m++) {
				for (int n = 0; n < 3; n++) {
					int num9 = num + m;
					int num10 = num2 + n;
					if (Main.tile[num9, num10].active() && Main.tile[num9, num10].type == 334)
						KillTile(num9, num10);
				}
			}

			destroyObject = false;
		}

		public static void ToggleGemLock(int i, int j, bool on) {
			Tile tileSafely = Framing.GetTileSafely(i, j);
			if (!tileSafely.active() || tileSafely.type != 440 || (tileSafely.frameY < 54 && !on))
				return;

			bool flag = false;
			int num = -1;
			if (tileSafely.frameY >= 54)
				flag = true;

			int num2 = Main.tile[i, j].frameX / 54;
			int num3 = Main.tile[i, j].frameX % 54 / 18;
			int num4 = Main.tile[i, j].frameY % 54 / 18;
			switch (num2) {
				case 0:
					num = 1526;
					break;
				case 1:
					num = 1524;
					break;
				case 2:
					num = 1525;
					break;
				case 3:
					num = 1523;
					break;
				case 4:
					num = 1522;
					break;
				case 5:
					num = 1527;
					break;
				case 6:
					num = 3643;
					break;
			}

			for (int k = i - num3; k < i - num3 + 3; k++) {
				for (int l = j - num4; l < j - num4 + 3; l++) {
					Main.tile[k, l].frameY = (short)((on ? 54 : 0) + (l - j + num4) * 18);
				}
			}

			if (num != -1 && flag)
				Item.NewItem(i * 16, j * 16, 32, 32, num);

			SquareTileFrame(i, j);
			NetMessage.SendTileSquare(-1, i - num3 + 1, j - num4 + 1, 3);
			Wiring.HitSwitch(i - num3, j - num4);
			NetMessage.SendData(59, -1, -1, null, i - num3, j - num4);
		}

		public static void CheckMan(int i, int j) {
			if (destroyObject)
				return;

			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3;
			for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100) {
			}

			while (num3 >= 36) {
				num3 -= 36;
			}

			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k <= 1; k++) {
				for (int l = 0; l <= 2; l++) {
					int num4 = num + k;
					int num5 = num2 + l;
					int num6;
					for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100) {
					}

					if (num6 >= 36)
						num6 -= 36;

					if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 128 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
						flag = true;
				}
			}

			if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
				flag = true;

			if (!flag)
				return;

			destroyObject = true;
			if (TileLoader.Drop(i, j, TileID.Mannequin))
				Item.NewItem(i * 16, j * 16, 32, 32, 498);

			for (int m = 0; m <= 1; m++) {
				for (int n = 0; n <= 2; n++) {
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 128)
						KillTile(num7, num8);
				}
			}

			destroyObject = false;
		}

		public static void CheckWoman(int i, int j) {
			if (destroyObject)
				return;

			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3;
			for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100) {
			}

			while (num3 >= 36) {
				num3 -= 36;
			}

			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k <= 1; k++) {
				for (int l = 0; l <= 2; l++) {
					int num4 = num + k;
					int num5 = num2 + l;
					int num6;
					for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100) {
					}

					if (num6 >= 36)
						num6 -= 36;

					if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 269 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
						flag = true;
				}
			}

			if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
				flag = true;

			if (!flag)
				return;

			destroyObject = true;
			if (TileLoader.Drop(i, j, TileID.Womannequin))
				Item.NewItem(i * 16, j * 16, 32, 32, 1989);

			for (int m = 0; m <= 1; m++) {
				for (int n = 0; n <= 2; n++) {
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 269)
						KillTile(num7, num8);
				}
			}

			destroyObject = false;
		}

		public static void Place1x2(int x, int y, ushort type, int style) {
			short frameX = 0;
			if (TileLoader.IsSapling(type))
				frameX = (short)(genRand.Next(3) * 18);

			if (Main.tile[x, y - 1] == null)
				Main.tile[x, y - 1] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (SolidTile2(x, y + 1) & !Main.tile[x, y - 1].active()) {
				short num = (short)(style * 40);
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = num;
				Main.tile[x, y - 1].frameX = frameX;
				Main.tile[x, y - 1].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num + 18);
				Main.tile[x, y].frameX = frameX;
				Main.tile[x, y].type = type;
			}
		}

		public static void Place1x2Top(int x, int y, ushort type, int style) {
			short frameX = 0;
			if (Main.tile[x, y - 1] == null)
				Main.tile[x, y - 1] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y + 1].active()) {
				short num = (short)(style * 36);
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = num;
				Main.tile[x, y].frameX = frameX;
				Main.tile[x, y].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].frameY = (short)(num + 18);
				Main.tile[x, y + 1].frameX = frameX;
				Main.tile[x, y + 1].type = type;
			}
		}

		public static void Check1x2Top(int x, int j, ushort type) {
			if (destroyObject)
				return;

			int num = j;
			bool flag = true;
			int num2 = Main.tile[x, num].frameY / 18;
			int num3 = 0;
			while (num2 >= 2) {
				num2 -= 2;
				num3++;
			}

			num -= num2;
			num2 = num3 * 36;
			if (Main.tile[x, num] == null)
				Main.tile[x, num] = new Tile();

			if (Main.tile[x, num + 1] == null)
				Main.tile[x, num + 1] = new Tile();

			if (Main.tile[x, num] == null)
				Main.tile[x, num] = new Tile();

			if (Main.tile[x, num].frameY == num2 && Main.tile[x, num + 1].frameY == num2 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
				flag = false;

			if (Main.tile[x, num - 1] == null)
				Main.tile[x, num - 1] = new Tile();

			if (!Main.tile[x, num - 1].nactive() || !Main.tileSolid[Main.tile[x, num - 1].type] || Main.tileSolidTop[Main.tile[x, num - 1].type])
				flag = true;

			if (!flag)
				return;

			destroyObject = true;
			if (Main.tile[x, num].type == type)
				KillTile(x, num);

			if (Main.tile[x, num + 1].type == type)
				KillTile(x, num + 1);

			if (!TileLoader.Drop(x, num, type))
				goto skipDrop;

			switch (type) {
				case 42: {
						int type2 = 0;
						if (num3 == 0) {
							type2 = 136;
						}
						else if (num3 == 7) {
							type2 = 1431;
						}
						else if (num3 == 8) {
							type2 = 1808;
						}
						else if (num3 == 9) {
							type2 = 1859;
						}
						else if (num3 < 10) {
							type2 = 1389 + num3;
						}
						else {
							switch (num3) {
								case 10:
									type2 = 2032;
									break;
								case 11:
									type2 = 2033;
									break;
								case 12:
									type2 = 2034;
									break;
								case 13:
									type2 = 2035;
									break;
								case 14:
									type2 = 2036;
									break;
								case 15:
									type2 = 2037;
									break;
								case 16:
									type2 = 2038;
									break;
								case 17:
									type2 = 2039;
									break;
								case 18:
									type2 = 2040;
									break;
								case 19:
									type2 = 2041;
									break;
								case 20:
									type2 = 2042;
									break;
								case 21:
									type2 = 2043;
									break;
								case 22:
								case 23:
								case 24:
								case 25:
									type2 = 2145 + num3 - 22;
									break;
								default:
									switch (num3) {
										case 26:
											type2 = 2226;
											break;
										case 27:
											type2 = 2530;
											break;
										case 28:
											type2 = 2546;
											break;
										case 29:
											type2 = 2564;
											break;
										case 30:
											type2 = 2579;
											break;
										case 31:
											type2 = 2641;
											break;
										case 32:
											type2 = 2642;
											break;
										case 33:
											type2 = 2820;
											break;
										case 34:
											type2 = 3138;
											break;
										case 35:
											type2 = 3140;
											break;
										case 36:
											type2 = 3139;
											break;
										case 37:
											type2 = 3891;
											break;
									}
									break;
							}
						}

						Item.NewItem(x * 16, num * 16, 32, 32, type2);
						break;
					}
				case 270:
					Item.NewItem(x * 16, num * 16, 32, 32, 1993);
					break;
				case 271:
					Item.NewItem(x * 16, num * 16, 32, 32, 2005);
					break;
			}

			skipDrop:
			destroyObject = false;
		}

		public static bool PlaceSmallPile(int i, int j, int X, int Y, ushort type = 185) {
			short frameY = (short)(Y * 18);
			short frameX = (short)(X * 18);
			if (Main.tile[i, j] == null)
				Main.tile[i, j] = new Tile();

			if (Main.tile[i + 1, j] == null)
				Main.tile[i + 1, j] = new Tile();

			if (Main.tile[i, j + 1] == null)
				Main.tile[i, j + 1] = new Tile();

			if (Main.tile[i + 1, j + 1] == null)
				Main.tile[i + 1, j + 1] = new Tile();

			if (Main.tile[i, j].lava())
				return false;

			if (Y == 1) {
				frameX = (short)(X * 36);
				bool flag = false;
				if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1) && !Main.tile[i, j].active() && !Main.tile[i + 1, j].active())
					flag = true;

				if (flag) {
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].frameY = frameY;
					Main.tile[i, j].frameX = frameX;
					Main.tile[i, j].type = type;
					Main.tile[i + 1, j].active(active: true);
					Main.tile[i + 1, j].frameY = frameY;
					Main.tile[i + 1, j].frameX = (short)(frameX + 18);
					Main.tile[i + 1, j].type = type;
					return true;
				}
			}
			else if (SolidTile2(i, j + 1) && !Main.tile[i, j].active()) {
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = frameY;
				Main.tile[i, j].frameX = frameX;
				Main.tile[i, j].type = type;
				return true;
			}

			return false;
		}

		public static void CheckPile(int i, int y) {
			if (Main.tile[i, y] == null)
				Main.tile[i, y] = new Tile();

			if (Main.tile[i + 1, y] == null)
				Main.tile[i + 1, y] = new Tile();

			if (Main.tile[i, y + 1] == null)
				Main.tile[i, y + 1] = new Tile();

			if (Main.tile[i + 1, y + 1] == null)
				Main.tile[i + 1, y + 1] = new Tile();

			if (Main.tile[i, y].frameY == 18)
				Check2x1(i, y, Main.tile[i, y].type);
			else if (!SolidTile(i, y + 1))
				KillTile(i, y);
		}

		public static void Check2x1(int i, int y, ushort type) {
			if (destroyObject)
				return;

			int num = i;
			bool flag = true;
			if (Main.tile[num, y] == null)
				Main.tile[num, y] = new Tile();

			int num2 = Main.tile[num, y].frameX / 18;
			int num3 = num2 >> 1;
			num2 %= 2;
			num -= num2;
			if (Main.tile[num, y] == null)
				Main.tile[num, y] = new Tile();

			if (Main.tile[num + 1, y] == null)
				Main.tile[num + 1, y] = new Tile();

			if (Main.tile[num, y + 1] == null)
				Main.tile[num, y + 1] = new Tile();

			if (Main.tile[num + 1, y + 1] == null)
				Main.tile[num + 1, y + 1] = new Tile();

			if (Main.tile[num + 1, y].frameX == Main.tile[num, y].frameX + 18 && Main.tile[num, y].type == type && Main.tile[num + 1, y].type == type)
				flag = false;

			if (type == 29 || type == 103 || type == 462) {
				if (!Main.tile[num, y + 1].active() || !Main.tileTable[Main.tile[num, y + 1].type])
					flag = true;

				if (!Main.tile[num + 1, y + 1].active() || !Main.tileTable[Main.tile[num + 1, y + 1].type])
					flag = true;
			}
			else {
				if (!SolidTileAllowBottomSlope(num, y + 1))
					flag = true;

				if (!SolidTileAllowBottomSlope(num + 1, y + 1))
					flag = true;
			}

			if (type == 185 && Main.tile[num, y].frameX >= 1368 && Main.tile[num, y].frameX <= 1458 && Main.tile[num, y + 1].type != 2 && Main.tile[num + 1, y + 1].type != 2) {
				Main.tile[num, y].frameX -= 1368;
				Main.tile[num + 1, y].frameX -= 1368;
			}

			if (!flag)
				return;

			int frameX = Main.tile[num, y].frameX;
			if (!Main.tile[num, y].active())
				frameX = Main.tile[num + 1, y].frameX;

			destroyObject = true;
			if (Main.tile[num, y].type == type)
				KillTile(num, y);

			if (Main.tile[num + 1, y].type == type)
				KillTile(num + 1, y);

			if (!TileLoader.Drop(num3, y, type))
				goto skipDrop;

			if (type == 16) {
				if (num3 == 1)
					Item.NewItem(num * 16, y * 16, 32, 32, 716);
				else
					Item.NewItem(num * 16, y * 16, 32, 32, 35);
			}

			if (type == 18) {
				int type2 = 36;
				if (num3 >= 1 && num3 <= 3) {
					type2 = 634 + num3;
				}
				else if (num3 >= 4 && num3 <= 8) {
					type2 = 807 + num3;
				}
				else {
					switch (num3) {
						case 9:
							type2 = 916;
							break;
						case 10:
							type2 = 1145;
							break;
						case 11:
							type2 = 1398;
							break;
						case 12:
							type2 = 1401;
							break;
						case 13:
							type2 = 1404;
							break;
						case 14:
							type2 = 1461;
							break;
						case 15:
							type2 = 1511;
							break;
						case 16:
							type2 = 1795;
							break;
						case 17:
							type2 = 1817;
							break;
						case 18:
							type2 = 2229;
							break;
						case 19:
							type2 = 2251;
							break;
						case 20:
							type2 = 2252;
							break;
						case 21:
							type2 = 2253;
							break;
						case 22:
							type2 = 2534;
							break;
						case 23:
							type2 = 673;
							break;
						case 24:
							type2 = 2631;
							break;
						case 25:
							type2 = 2632;
							break;
						case 26:
							type2 = 2633;
							break;
						case 27:
							type2 = 2826;
							break;
						case 28:
							type2 = 3156;
							break;
						case 29:
							type2 = 3158;
							break;
						case 30:
							type2 = 3157;
							break;
						case 31:
							type2 = 3909;
							break;
						case 32:
							type2 = 3910;
							break;
					}
				}

				Item.NewItem(num * 16, y * 16, 32, 32, type2);
			}

			if (type == 185) {
				if (frameX >= 576 && frameX <= 610) {
					Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					if (genRand.Next(3) != 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));

					if (genRand.Next(3) != 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));

					if (genRand.Next(2) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));

					if (genRand.Next(2) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));

					if (genRand.Next(3) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));

					if (genRand.Next(3) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));

					if (genRand.Next(4) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));

					if (genRand.Next(4) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));

					if (genRand.Next(5) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));

					if (genRand.Next(5) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
				}

				if (frameX >= 612 && frameX <= 646) {
					Item.NewItem(num * 16, y * 16, 32, 32, 72, genRand.Next(10, 100));
					if (genRand.Next(2) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 72, genRand.Next(20, 100));

					if (genRand.Next(3) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 72, genRand.Next(30, 100));
				}

				if (frameX >= 648 && frameX <= 682) {
					Item.NewItem(num * 16, y * 16, 32, 32, 73, genRand.Next(1, 6));
					if (genRand.Next(2) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 73, genRand.Next(2, 6));

					if (genRand.Next(3) == 0)
						Item.NewItem(num * 16, y * 16, 32, 32, 73, genRand.Next(3, 6));
				}

				if (frameX >= 684 && frameX <= 718)
					Item.NewItem(num * 16, y * 16, 32, 32, 181, genRand.Next(1, 4));

				if (frameX >= 720 && frameX <= 754)
					Item.NewItem(num * 16, y * 16, 32, 32, 180, genRand.Next(1, 4));

				if (frameX >= 756 && frameX <= 790)
					Item.NewItem(num * 16, y * 16, 32, 32, 177, genRand.Next(1, 4));

				if (frameX >= 792 && frameX <= 826)
					Item.NewItem(num * 16, y * 16, 32, 32, 179, genRand.Next(1, 4));

				if (frameX >= 828 && frameX <= 862)
					Item.NewItem(num * 16, y * 16, 32, 32, 178, genRand.Next(1, 4));

				if (frameX >= 864 && frameX <= 898)
					Item.NewItem(num * 16, y * 16, 32, 32, 182, genRand.Next(1, 4));
			}

			if (type == 462)
				Item.NewItem(num * 16, y * 16, 32, 32, 3795);

			if (type == 29) {
				Item.NewItem(num * 16, y * 16, 32, 32, 87);
				Main.PlaySound(13, i * 16, y * 16);
			}

			switch (type) {
				case 103: {
						int type3 = 356;
						if (num3 == 1)
							type3 = 2235;

						if (num3 == 2)
							type3 = 2242;

						if (num3 == 3)
							type3 = 2243;

						Item.NewItem(num * 16, y * 16, 32, 32, type3);
						Main.PlaySound(13, i * 16, y * 16);
						break;
					}
				case 134:
					if (num3 == 1)
						Item.NewItem(num * 16, y * 16, 32, 32, 1220);
					else
						Item.NewItem(num * 16, y * 16, 32, 32, 525);
					break;
			}

			skipDrop:
			destroyObject = false;
			SquareTileFrame(num, y);
			SquareTileFrame(num + 1, y);
		}

		public static void Place2x1(int x, int y, ushort type, int style = 0) {
			if (Main.tile[x, y] == null)
				Main.tile[x, y] = new Tile();

			if (Main.tile[x + 1, y] == null)
				Main.tile[x + 1, y] = new Tile();

			if (Main.tile[x, y + 1] == null)
				Main.tile[x, y + 1] = new Tile();

			if (Main.tile[x + 1, y + 1] == null)
				Main.tile[x + 1, y + 1] = new Tile();

			bool flag = false;
			if (type != 29 && type != 103 && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1) && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
				flag = true;
			else if ((type == 29 || type == 103) && Main.tile[x, y + 1].active() && Main.tile[x + 1, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && Main.tileTable[Main.tile[x + 1, y + 1].type] && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
				flag = true;

			if (flag) {
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(36 * style);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(36 * style + 18);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Check4x2(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = i;
			num += Main.tile[i, j].frameX / 18 * -1;
			if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
				num += 4;

			int num2 = Main.tile[i, j].frameY / 18;
			int num3 = 0;
			while (num2 > 1) {
				num2 -= 2;
				num3++;
			}

			num2 = j - num2;
			for (int k = num; k < num + 4; k++) {
				for (int l = num2; l < num2 + 2; l++) {
					int num4 = (k - num) * 18;
					if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
						num4 = (k - num + 4) * 18;

					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num4 || Main.tile[k, l].frameY != (l - num2) * 18 + num3 * 36)
						flag = true;
				}

				if (Main.tile[k, num2 + 2] == null)
					Main.tile[k, num2 + 2] = new Tile();

				if (!SolidTileAllowBottomSlope(k, num2 + 2) && (!Main.tile[k, num2 + 2].active() || !TileID.Sets.Platforms[Main.tile[k, num2 + 2].type]))
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + 4; m++) {
				for (int n = num2; n < num2 + 3; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;
			if (type == 79) {
				int num5 = 0;
				switch (num3) {
					case 0:
						num5 = 224;
						break;
					case 4:
						num5 = 920;
						break;
					case 9:
					case 10:
					case 11:
					case 12:
						num5 = 1710 + num3;
						break;
					default:
						if (num3 >= 5 && num3 <= 8) {
							num5 = 1465 + num3;
							break;
						}
						if (num3 >= 13 && num3 <= 18) {
							num5 = 2066 + num3 - 13;
							break;
						}
						switch (num3) {
							case 19:
								num5 = 2139;
								break;
							case 20:
								num5 = 2140;
								break;
							case 21:
								num5 = 2231;
								break;
							case 22:
								num5 = 2520;
								break;
							case 23:
								num5 = 2538;
								break;
							case 24:
								num5 = 2553;
								break;
							case 25:
								num5 = 2568;
								break;
							case 26:
								num5 = 2669;
								break;
							case 27:
								num5 = 2811;
								break;
							case 28:
								num5 = 3162;
								break;
							case 29:
								num5 = 3164;
								break;
							case 30:
								num5 = 3163;
								break;
							case 31:
								num5 = 3897;
								break;
							default:
								num5 = num3 + 643;
								break;
						}
						break;
				}

				Item.NewItem(i * 16, j * 16, 32, 32, num5);
			}

			if (type == 90) {
				int type2 = 0;
				switch (num3) {
					case 0:
						type2 = 336;
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
					case 9:
					case 10:
						type2 = 2072 + num3 - 1;
						break;
					default:
						if (num3 >= 11 && num3 <= 15) {
							type2 = 2124 + num3 - 11;
							break;
						}
						switch (num3) {
							case 16:
								type2 = 2232;
								break;
							case 17:
								type2 = 2519;
								break;
							case 18:
								type2 = 2537;
								break;
							case 19:
								type2 = 2552;
								break;
							case 20:
								type2 = 2567;
								break;
							case 21:
								type2 = 2658;
								break;
							case 22:
								type2 = 2659;
								break;
							case 23:
								type2 = 2660;
								break;
							case 24:
								type2 = 2661;
								break;
							case 25:
								type2 = 2662;
								break;
							case 26:
								type2 = 2663;
								break;
							case 27:
								type2 = 2810;
								break;
							case 28:
								type2 = 3159;
								break;
							case 29:
								type2 = 3161;
								break;
							case 30:
								type2 = 3160;
								break;
							case 31:
								type2 = 3895;
								break;
						}
						break;
				}

				Item.NewItem(i * 16, j * 16, 32, 32, type2);
			}

			skipDrop:
			destroyObject = false;
			for (int num6 = num - 1; num6 < num + 4; num6++) {
				for (int num7 = num2 - 1; num7 < num2 + 4; num7++) {
					TileFrame(num6, num7);
				}
			}
		}

		public static void PlaceJunglePlant(int X2, int Y2, ushort type, int styleX, int styleY) {
			if (styleY > 0 || type == 236 || type == 238) {
				int num = Y2;
				if (type == 95 || type == 126)
					num++;

				if (X2 < 5 || X2 > Main.maxTilesX - 5 || num < 5 || num > Main.maxTilesY - 5)
					return;

				bool flag = true;
				for (int i = X2 - 1; i < X2 + 1; i++) {
					for (int j = num - 1; j < num + 1; j++) {
						if (Main.tile[i, j] == null)
							Main.tile[i, j] = new Tile();

						if (Main.tile[i, j].active() && Main.tile[i, j].type != 61 && Main.tile[i, j].type != 62 && Main.tile[i, j].type != 69 && Main.tile[i, j].type != 74 && (type != 236 || Main.tile[i, j].type != 233) && (type != 238 || Main.tile[i, j].type != 233) && (Main.tile[i, j].type != 185 || Main.tile[i, j].frameY != 0))
							flag = false;

						if (type == 98 && Main.tile[i, j].liquid > 0)
							flag = false;
					}

					if (Main.tile[i, num + 1] == null)
						Main.tile[i, num + 1] = new Tile();

					if (!SolidTile(i, num + 1) || Main.tile[i, num + 1].type != 60)
						flag = false;
				}

				if (flag) {
					short num2 = 36;
					if (type == 236 || type == 238)
						num2 = 0;

					short num3 = (short)(36 * styleX);
					Main.tile[X2 - 1, num - 1].active(active: true);
					Main.tile[X2 - 1, num - 1].frameY = num2;
					Main.tile[X2 - 1, num - 1].frameX = num3;
					Main.tile[X2 - 1, num - 1].type = type;
					Main.tile[X2, num - 1].active(active: true);
					Main.tile[X2, num - 1].frameY = num2;
					Main.tile[X2, num - 1].frameX = (short)(18 + num3);
					Main.tile[X2, num - 1].type = type;
					Main.tile[X2 - 1, num].active(active: true);
					Main.tile[X2 - 1, num].frameY = (short)(num2 + 18);
					Main.tile[X2 - 1, num].frameX = num3;
					Main.tile[X2 - 1, num].type = type;
					Main.tile[X2, num].active(active: true);
					Main.tile[X2, num].frameY = (short)(num2 + 18);
					Main.tile[X2, num].frameX = (short)(18 + num3);
					Main.tile[X2, num].type = type;
				}
			}
			else {
				if (X2 < 5 || X2 > Main.maxTilesX - 5 || Y2 < 5 || Y2 > Main.maxTilesY - 5)
					return;

				bool flag2 = true;
				for (int k = X2 - 1; k < X2 + 2; k++) {
					for (int l = Y2 - 1; l < Y2 + 1; l++) {
						if (Main.tile[k, l] == null)
							Main.tile[k, l] = new Tile();

						if (Main.tile[k, l].active() && Main.tile[k, l].type != 61 && Main.tile[k, l].type != 62 && Main.tile[k, l].type != 69 && Main.tile[k, l].type != 74 && (Main.tile[k, l].type != 185 || Main.tile[k, l].frameY != 0))
							flag2 = false;
					}

					if (Main.tile[k, Y2 + 1] == null)
						Main.tile[k, Y2 + 1] = new Tile();

					if (!SolidTile(k, Y2 + 1) || Main.tile[k, Y2 + 1].type != 60)
						flag2 = false;
				}

				if (flag2) {
					short num4 = (short)(54 * styleX);
					Main.tile[X2 - 1, Y2 - 1].active(active: true);
					Main.tile[X2 - 1, Y2 - 1].frameY = 0;
					Main.tile[X2 - 1, Y2 - 1].frameX = num4;
					Main.tile[X2 - 1, Y2 - 1].type = type;
					Main.tile[X2, Y2 - 1].active(active: true);
					Main.tile[X2, Y2 - 1].frameY = 0;
					Main.tile[X2, Y2 - 1].frameX = (short)(num4 + 18);
					Main.tile[X2, Y2 - 1].type = type;
					Main.tile[X2 + 1, Y2 - 1].active(active: true);
					Main.tile[X2 + 1, Y2 - 1].frameY = 0;
					Main.tile[X2 + 1, Y2 - 1].frameX = (short)(num4 + 36);
					Main.tile[X2 + 1, Y2 - 1].type = type;
					Main.tile[X2 - 1, Y2].active(active: true);
					Main.tile[X2 - 1, Y2].frameY = 18;
					Main.tile[X2 - 1, Y2].frameX = num4;
					Main.tile[X2 - 1, Y2].type = type;
					Main.tile[X2, Y2].active(active: true);
					Main.tile[X2, Y2].frameY = 18;
					Main.tile[X2, Y2].frameX = (short)(num4 + 18);
					Main.tile[X2, Y2].type = type;
					Main.tile[X2 + 1, Y2].active(active: true);
					Main.tile[X2 + 1, Y2].frameY = 18;
					Main.tile[X2 + 1, Y2].frameX = (short)(num4 + 36);
					Main.tile[X2 + 1, Y2].type = type;
				}
			}
		}

		public static void CheckJunglePlant(int i, int j, int type) {
			if (destroyObject)
				return;

			if (Main.tile[i, j].frameY >= 36 || Main.tile[i, j].type == 236 || Main.tile[i, j].type == 238) {
				bool flag = false;
				int num = Main.tile[i, j].frameX / 18;
				int num2 = 0;
				while (num > 1) {
					num -= 2;
					num2++;
				}

				num = i - num;
				int num3 = 36;
				if (type == 236 || type == 238)
					num3 = 0;

				int num4;
				for (num4 = Main.tile[i, j].frameY / 18; num4 > 1; num4 -= 2) {
				}

				num4 = j - num4;
				int num5 = num2 * 36;
				for (int k = num; k < num + 2; k++) {
					for (int l = num4; l < num4 + 2; l++) {
						if (Main.tile[k, l] == null)
							Main.tile[k, l] = new Tile();

						if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num5 || Main.tile[k, l].frameY != (l - num4) * 18 + num3)
							flag = true;
					}

					if (Main.tile[k, num4 + 2] == null)
						Main.tile[k, num4 + 2] = new Tile();

					if (!SolidTile(k, num4 + 2) || Main.tile[k, num4 + 2].type != 60)
						flag = true;
				}

				if (!flag)
					return;

				if (!TileLoader.Drop(i, j, type))
					goto skipDrop; // do not know the size for this
				if (type == 238) {
					float num6 = i * 16;
					float num7 = j * 16;
					float num8 = -1f;
					int plr = 0;
					for (int m = 0; m < 255; m++) {
						float num9 = Math.Abs(Main.player[m].position.X - num6) + Math.Abs(Main.player[m].position.Y - num7);
						if (num9 < num8 || num8 == -1f) {
							plr = m;
							num8 = num9;
						}
					}

					if (num8 / 16f < 50f)
						NPC.SpawnOnPlayer(plr, 262);
				}

				if (type == 236)
					Item.NewItem(i * 16, j * 16, 32, 32, 1291);

				skipDrop:
				_ = Main.tile[i, j].frameX;
				destroyObject = true;
				for (int n = num; n < num + 2; n++) {
					for (int num10 = num4; num10 < num4 + 2; num10++) {
						if (Main.tile[n, num10] == null)
							Main.tile[n, num10] = new Tile();

						if (Main.tile[n, num10].type == type && Main.tile[n, num10].active())
							KillTile(n, num10);
					}
				}

				return;
			}

			bool flag2 = false;
			int num11 = j;
			num11 += Main.tile[i, j].frameY / 18 * -1;
			int num12 = Main.tile[i, j].frameX / 18;
			int num13 = 0;
			while (num12 > 2) {
				num12 -= 3;
				num13++;
			}

			num12 = i - num12;
			int num14 = num13 * 54;
			for (int num15 = num12; num15 < num12 + 3; num15++) {
				for (int num16 = num11; num16 < num11 + 2; num16++) {
					if (Main.tile[num15, num16] == null)
						Main.tile[num15, num16] = new Tile();

					if (!Main.tile[num15, num16].active() || Main.tile[num15, num16].type != type || Main.tile[num15, num16].frameX != (num15 - num12) * 18 + num14 || Main.tile[num15, num16].frameY != (num16 - num11) * 18)
						flag2 = true;
				}

				if (Main.tile[num15, num11 + 2] == null)
					Main.tile[num15, num11 + 2] = new Tile();

				if (!SolidTile(num15, num11 + 2) || Main.tile[num15, num11 + 2].type != 60)
					flag2 = true;
			}

			if (!flag2)
				return;

			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int num17 = num12; num17 < num12 + 3; num17++) {
				for (int num18 = num11; num18 < num11 + 3; num18++) {
					if (Main.tile[num17, num18] == null)
						Main.tile[num17, num18] = new Tile();

					if (Main.tile[num17, num18].type == type && Main.tile[num17, num18].active())
						KillTile(num17, num18);
				}
			}
		}

		public static void CheckSuper(int x, int y, int type) {
			if (destroyObject)
				return;

			Tile tile = Main.tile[x, y];
			int num = 0;
			if (type == 376)
				num = tile.frameX / 36;

			if (type == 443)
				num = tile.frameX / 36;

			bool flag = type == 376;
			bool flag2 = type == 443;
			bool flag3 = type == 444;
			TileObjectData tileData = TileObjectData.GetTileData(type, num);
			bool styleHorizontal = tileData.StyleHorizontal;
			int width = tileData.Width;
			int height = tileData.Height;
			int num2 = x;
			int num3 = y;
			num2 -= tile.frameX / 18 % width;
			num3 -= tile.frameY / 18 % height;
			int num4 = 0;
			int num5 = 0;
			if (styleHorizontal)
				num4 = tile.frameX / tileData.CoordinateFullWidth;
			else
				num5 = tile.frameY / tileData.CoordinateFullHeight;

			bool flag4 = false;
			bool flag5 = false;
			for (int i = 0; i < width; i++) {
				for (int j = 0; j < height; j++) {
					Tile tileSafely = Framing.GetTileSafely(num2 + i, num3 + j);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != num4 * tileData.CoordinateFullWidth + i * (tileData.CoordinateWidth + 2) || tileSafely.frameY != num5 * tileData.CoordinateFullHeight + j * (tileData.CoordinateHeights[0] + 2))
						flag4 = true;
				}
			}

			if (flag) {
				for (int k = 0; k < width; k++) {
					Tile tileSafely = Framing.GetTileSafely(num2 + k, num3 + height);
					if (!tileSafely.active() || (!Main.tileSolid[tileSafely.type] && !Main.tileTable[tileSafely.type]))
						flag4 = true;

					if (tileSafely.halfBrick())
						flag4 = true;
				}
			}

			if (flag2) {
				bool flag6 = true;
				bool flag7 = true;
				for (int l = 0; l < width; l++) {
					if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 + height), AnchorType.SolidTile | AnchorType.SolidWithTop | AnchorType.SolidSide))
						flag7 = false;

					if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 - 1), AnchorType.SolidBottom))
						flag6 = false;
				}

				if (!flag6 && !flag7)
					flag4 = true;

				if (!flag4) {
					int num6 = 0;
					if (Main.netMode != 1) {
						if (flag7) {
							for (int m = 0; m < width; m++) {
								Framing.GetTileSafely(num2 + m, num3).frameX = (short)(m * 18 + num / 2 * 36 + num6 * 36);
							}
						}
						else {
							for (int n = 0; n < width; n++) {
								Framing.GetTileSafely(num2 + n, num3).frameX = (short)(n * 18 + (num - 2) / 2 * 36 + 72 + num6 * 36);
							}
						}
					}
				}
			}

			if (flag3) {
				bool flag8 = true;
				for (int num7 = 0; num7 < width; num7++) {
					if (!AnchorValid(Framing.GetTileSafely(num2 + num7, num3 - 1), AnchorType.SolidTile))
						flag8 = false;
				}

				if (!flag8)
					flag4 = true;

				for (int num8 = 0; num8 < width; num8++) {
					for (int num9 = 0; num9 < height; num9++) {
						Tile tileSafely = Framing.GetTileSafely(num2 + num8, num3 + num9);
						if (tileSafely.liquid > 0) {
							flag4 = true;
							flag5 = true;
						}
					}
				}
			}

			if (!flag4)
				return;

			destroyObject = true;
			for (int num10 = 0; num10 < width; num10++) {
				for (int num11 = 0; num11 < height; num11++) {
					if (Main.tile[num2 + num10, num3 + num11].type == type && Main.tile[num2 + num10, num3 + num11].active())
						KillTile(num2 + num10, num3 + num11);
				}
			}

			int num12 = 0;
			if (type == 376)
				num12 = ((num <= 2) ? (2334 + num) : (3203 + num - 3));

			if (type == 443)
				num12 = 3722;

			if (type == 444 && Main.netMode != 1 && !flag5)
				Projectile.NewProjectile(num2 * 16 + 16, num3 * 16 + 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);

			// FishingCrate, GeyserTrap, and BeeHive
			// geyser is 2x1
			if (TileLoader.Drop(num2, num3, type) && num12 != 0)
				Item.NewItem(num2 * 16, num3 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, num12);

			destroyObject = false;
			for (int num13 = -1; num13 < width + 1; num13++) {
				for (int num14 = -1; num14 < height + 1; num14++) {
					TileFrame(num2 + num13, num3 + num14);
				}
			}
		}

		public static void Check2x2(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = 0;
			int num2 = Main.tile[i, j].frameX / 18 * -1;
			if (num2 < -1) {
				num2 += 2;
				num = 36;
			}

			num2 += i;
			int num3 = (type == 172) ? 38 : 36;
			int num4 = Main.tile[i, j].frameY;
			int num5 = 0;
			while (num4 >= num3) {
				num4 -= num3;
				num5++;
			}

			int num6 = j - num4 / 18;
			for (int k = num2; k < num2 + 2; k++) {
				for (int l = num6; l < num6 + 2; l++) {
					Tile tileSafely = Framing.GetTileSafely(k, l);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != (k - num2) * 18 + num || tileSafely.frameY != (l - num6) * 18 + num5 * num3)
						flag = true;
				}

				switch (type) {
					case 95:
					case 126:
						Framing.GetTileSafely(k, num6 - 1);
						if (!Main.tile[k, num6 - 1].active() || !Main.tileSolid[Main.tile[k, num6 - 1].type] || Main.tileSolidTop[Main.tile[k, num6 - 1].type])
							flag = true;
						continue;
					case 132:
					case 138:
						continue;
				}

				Tile tileSafely2 = Framing.GetTileSafely(k, num6 + 2);
				if (!tileSafely2.active() || (!Main.tileSolid[tileSafely2.type] && !Main.tileTable[tileSafely2.type]))
					flag = true;

				if (tileSafely2.halfBrick())
					flag = true;
			}

			switch (type) {
				case 138: {
						ushort type4 = Main.tile[num2, num6 - 1].type;
						ushort type5 = Main.tile[num2 + 1, num6 - 1].type;
						if (!TileID.Sets.BasicChest[type4] && !TileID.Sets.BasicChest[type5] && !TileLoader.IsDresser(type4) && !TileLoader.IsDresser(type5) && !TileID.Sets.BasicChestFake[type4] && !TileID.Sets.BasicChestFake[type5] && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
							flag = true;

						break;
					}
				case 132: {
						flag = false;
						num6 = Main.tile[i, j].frameY / 18 * -1;
						num6 += j;
						num = 0;
						num2 = Main.tile[i, j].frameX / 18 * -1;
						while (num2 < -1) {
							num2 += 2;
							num += 36;
						}

						num2 += i;
						for (int m = num2; m < num2 + 2; m++) {
							for (int n = num6; n < num6 + 2; n++) {
								if (Main.tile[m, n] == null)
									Main.tile[m, n] = new Tile();

								if (!Main.tile[m, n].active() || Main.tile[m, n].type != type || Main.tile[m, n].frameX != (m - num2) * 18 + num || Main.tile[m, n].frameY != (n - num6) * 18)
									flag = true;
							}
						}

						if (Main.tile[num2, num6 + 2] == null)
							Main.tile[num2, num6 + 2] = new Tile();

						if (Main.tile[num2 + 1, num6 + 2] == null)
							Main.tile[num2 + 1, num6 + 2] = new Tile();

						bool flag2 = false;
						ushort type2 = Main.tile[num2, num6 + 2].type;
						ushort type3 = Main.tile[num2 + 1, num6 + 2].type;
						if (!Main.tile[num2, num6 + 2].active() || (!Main.tileSolid[type2] && !Main.tileSolidTop[type2]) || Main.tile[num2, num6 + 2].halfBrick() || (Main.tile[num2, num6 + 2].slope() != 0 && !Main.tile[num2, num6 + 2].bottomSlope()))
							flag2 = true;

						if (!Main.tile[num2 + 1, num6 + 2].active() || (!Main.tileSolid[type3] && !Main.tileSolidTop[type3]) || Main.tile[num2 + 1, num6 + 2].halfBrick() || (Main.tile[num2 + 1, num6 + 2].slope() != 0 && !Main.tile[num2 + 1, num6 + 2].bottomSlope()))
							flag2 = true;

						if (flag2) {
							if (Main.tile[num2, num6].wall < 1 || Main.tile[num2 + 1, num6].wall < 1 || Main.tile[num2, num6 + 1].wall < 1 || Main.tile[num2 + 1, num6 + 1].wall < 1) {
								flag = true;
							}
							else {
								if (num >= 72)
									break;

								for (int num7 = num2; num7 < num2 + 2; num7++) {
									for (int num8 = num6; num8 < num6 + 2; num8++) {
										Main.tile[num7, num8].frameX += 72;
									}
								}
							}
						}
						else {
							if (num < 72)
								break;

							for (int num9 = num2; num9 < num2 + 2; num9++) {
								for (int num10 = num6; num10 < num6 + 2; num10++) {
									Main.tile[num9, num10].frameX -= 72;
								}
							}
						}

						break;
					}
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int num11 = num2; num11 < num2 + 2; num11++) {
				for (int num12 = num6; num12 < num6 + 2; num12++) {
					if (Main.tile[num11, num12].type == type && Main.tile[num11, num12].active())
						KillTile(num11, num12);
				}
			}

			int num13 = 0;
			if (type == 360)
				num13 = 3072;

			if (type >= 288 && type <= 295)
				num13 = 2178 + type - 288;

			if (type >= 316 && type <= 318)
				num13 = 2439 + type - 316;

			if (type == 85)
				num13 = 321;

			if (type == 94)
				num13 = 352;

			if (type == 95)
				num13 = 344;

			if (type == 96)
				num13 = 345;

			if (type == 97)
				num13 = 346;

			if (type == 98)
				num13 = 347;

			if (type == 99)
				num13 = 348;

			if (type == 335)
				num13 = 2700;

			if (type == 411)
				num13 = 3545;

			if (type == 100) {
				switch (num5) {
					case 0:
						num13 = 349;
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
						num13 = 2092 + num5 - 1;
						break;
					default:
						if (num5 >= 13 && num5 <= 16) {
							num13 = 2149 + num5 - 13;
							break;
						}
						switch (num5) {
							case 17:
								num13 = 2227;
								break;
							case 18:
								num13 = 2522;
								break;
							case 19:
								num13 = 2541;
								break;
							case 20:
								num13 = 2555;
								break;
							case 21:
								num13 = 2570;
								break;
							case 22:
								num13 = 2664;
								break;
							case 23:
								num13 = 2665;
								break;
							case 24:
								num13 = 2666;
								break;
							case 25:
								num13 = 2667;
								break;
							case 26:
								num13 = 2668;
								break;
							case 27:
								num13 = 2825;
								break;
							case 28:
								num13 = 3168;
								break;
							case 29:
								num13 = 3170;
								break;
							case 30:
								num13 = 3169;
								break;
							case 31:
								num13 = 3893;
								break;
						}
						break;
				}
			}

			if (type == 173)
				num13 = 714;

			if (type == 125)
				num13 = 487;

			if (type == 287)
				num13 = 2177;

			if (type == 126)
				num13 = 488;

			if (type == 132)
				num13 = 513;

			if (type == 142)
				num13 = 581;

			if (type == 143)
				num13 = 582;

			if (type == 282)
				num13 = 250;

			if (type == 319)
				num13 = 2490;

			if (type == 172) {
				num13 = 2827 + num5;
				switch (num5) {
					case 29:
						num13 = 3147;
						break;
					case 30:
						num13 = 3149;
						break;
					case 31:
						num13 = 3148;
						break;
					case 32:
						num13 = 3896;
						break;
				}
			}

			if (TileLoader.Drop(i, j, type) && num13 != 0)
				Item.NewItem(i * 16, j * 16, 32, 32, num13);

			if (type == 138 && !gen && Main.netMode != 1)
				Projectile.NewProjectile((float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 99, 70, 10f, Main.myPlayer);

			destroyObject = false;
			for (int num14 = num2 - 1; num14 < num2 + 3; num14++) {
				for (int num15 = num6 - 1; num15 < num6 + 3; num15++) {
					TileFrame(num14, num15);
				}
			}
		}

		public static bool CheckBoulderChest(int i, int j) {
			int num = Main.tile[i, j].frameX / 18 * -1;
			if (num < -1)
				num += 2;

			num += i;
			int num2;
			for (num2 = Main.tile[i, j].frameY; num2 >= 36; num2 -= 36) {
			}

			num2 = j - num2 / 18;
			if (TileID.Sets.BasicChest[Main.tile[num, num2 - 1].type] || TileID.Sets.BasicChest[Main.tile[num + 1, num2 - 1].type] || TileID.Sets.BasicChestFake[Main.tile[num, num2 - 1].type] || TileID.Sets.BasicChestFake[Main.tile[num + 1, num2 - 1].type] || TileLoader.IsDresser(Main.tile[num, num2 - 1].type) || TileLoader.IsDresser(Main.tile[num + 1, num2 - 1].type))
				return true;

			return false;
		}

		public static void OreRunner(int i, int j, double strength, int steps, ushort type) {
			double num = strength;
			float num2 = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			while (num > 0.0 && num2 > 0f) {
				if (vector.Y < 0f && num2 > 0f && type == 59)
					num2 = 0f;

				num = strength * (double)(num2 / (float)steps);
				num2 -= 1f;
				int num3 = (int)((double)vector.X - num * 0.5);
				int num4 = (int)((double)vector.X + num * 0.5);
				int num5 = (int)((double)vector.Y - num * 0.5);
				int num6 = (int)((double)vector.Y + num * 0.5);
				if (num3 < 0)
					num3 = 0;

				if (num4 > Main.maxTilesX)
					num4 = Main.maxTilesX;

				if (num5 < 0)
					num5 = 0;

				if (num6 > Main.maxTilesY)
					num6 = Main.maxTilesY;

				for (int k = num3; k < num4; k++) {
					for (int l = num5; l < num6; l++) {
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (TileID.Sets.CanBeClearedDuringOreRunner[Main.tile[k, l].type] || Main.tileMoss[Main.tile[k, l].type])) {
							Main.tile[k, l].type = type;
							SquareTileFrame(k, l);
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, k, l, 1);
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;
			}
		}

		public static void SmashAltar(/*int i, int j*/) {
			/*
			if (Main.netMode == 1 || !Main.hardMode || noTileActions || gen)
				return;
			*/
			int num = altarCount % 3;
			int num2 = altarCount / 3 + 1;
			float num3 = Main.maxTilesX / 4200f;
			int num4 = 1 - num;
			num3 = num3 * 310f - (float)(85 * num);
			num3 *= 0.85f;
			num3 /= (float)num2;
			switch (num) {
				case 0: {
						if (oreTier1 == -1) {
							oreTier1 = 107;
							if (genRand.Next(2) == 0)
								oreTier1 = 221;
						}

						int num7 = 12;
						if (oreTier1 == 221) {
							num7 += 9;
							num3 *= 0.9f;
						}

						if (Main.netMode == 0)
							Main.NewText(Lang.misc[num7].Value, 50, byte.MaxValue, 130);
						else if (Main.netMode == 2)
							NetMessage.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num7].Key), new Color(50, 255, 130));

						num = oreTier1;
						if (Main.setting.PreSmashAltarOreGenerateOpposite)
							num = num == 107 ? 221 : 107; // For presmash, flip it.
						if (Main.setting.PreSmashAltarOreAlternates && WorldGen.genRand.Next(2) == 0)
						{
							num = num == 107 ? 221 : 107; // if both, flip again maybe
						}
						num3 *= 1.05f;
						break;
					}
				case 1: {
						if (oreTier2 == -1) {
							oreTier2 = 108;
							if (genRand.Next(2) == 0)
								oreTier2 = 222;
						}

						int num6 = 13;
						if (oreTier2 == 222) {
							num6 += 9;
							num3 *= 0.9f;
						}

						if (Main.netMode == 0)
							Main.NewText(Lang.misc[num6].Value, 50, byte.MaxValue, 130);
						else if (Main.netMode == 2)
							NetMessage.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num6].Key), new Color(50, 255, 130));

						num = oreTier2;
						break;
					}
				default: {
						if (oreTier3 == -1) {
							oreTier3 = 111;
							if (genRand.Next(2) == 0)
								oreTier3 = 223;
						}

						int num5 = 14;
						if (oreTier3 == 223) {
							num5 += 9;
							num3 *= 0.9f;
						}

						if (Main.netMode == 0)
							Main.NewText(Lang.misc[num5].Value, 50, byte.MaxValue, 130);
						else if (Main.netMode == 2)
							NetMessage.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num5].Key), new Color(50, 255, 130));

						num = oreTier3;
						break;
					}
			}
			if (!Main.setting.PreSmashAltarPreventPatches)
			{
			for (int k = 0; (float)k < num3; k++) {
				int i2 = genRand.Next(100, Main.maxTilesX - 100);
				double num8 = Main.worldSurface;
				if (num == 108 || num == 222)
					num8 = Main.rockLayer;

				if (num == 111 || num == 223)
					num8 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY) / 3.0;

				int j2 = genRand.Next((int)num8, Main.maxTilesY - 150);
				OreRunner(i2, j2, genRand.Next(5, 9 + num4), genRand.Next(5, 9 + num4), (ushort)num);
			}

			int num9 = genRand.Next(3);
			int num10 = 0;
			while (num9 != 2 && num10++ < 1000) {
				int num11 = genRand.Next(100, Main.maxTilesX - 100);
				int num12 = genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300);
				if (!Main.tile[num11, num12].active() || Main.tile[num11, num12].type != 1)
					continue;

				if (num9 == 0) {
					if (crimson)
						Main.tile[num11, num12].type = 203;
					else
						Main.tile[num11, num12].type = 25;
				}
				else {
					Main.tile[num11, num12].type = 117;
				}

				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, num11, num12, 1);

				break;
			}
			}
			if (Main.netMode != 1) {
				int num13 = Main.rand.Next(2) + 1;
				for (int l = 0; l < num13; l++) {
					// NPC.SpawnOnPlayer(Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16), 82);
				}
			}

			altarCount++;
			// AchievementsHelper.NotifyProgressionEvent(6);
		}

		public static void Check3x1(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = Main.tile[i, j].frameX / 18;
			int num2 = 0;
			while (num > 2) {
				num -= 3;
				num2++;
			}

			num = i - num;
			int num3 = num2 * 54;
			for (int k = num; k < num + 3; k++) {
				if (Main.tile[k, j] == null)
					Main.tile[k, j] = new Tile();

				if (!Main.tile[k, j].active() || Main.tile[k, j].type != type || Main.tile[k, j].frameX != (k - num) * 18 + num3 || Main.tile[k, j].frameY != 0)
					flag = true;

				if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || TileLoader.IsDresser(Main.tile[k, j - 1].type)))
					return;

				if (!SolidTileAllowBottomSlope(k, j + 1))
					flag = true;
			}

			if (!flag)
				return;

			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			if (TileLoader.Drop(i, j, type) && type == 235)
				Item.NewItem(i * 16, j * 16, 32, 32, 1263);

			for (int l = num; l < num + 3; l++) {
				if (Main.tile[l, j] == null)
					Main.tile[l, j] = new Tile();

				if (Main.tile[l, j].type == type && Main.tile[l, j].active())
					KillTile(l, j);
			}

			destroyObject = false;
			for (int m = num - 1; m < num + 4; m++) {
				TileFrame(m, j);
			}
		}

		public static void Check3x2(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			bool flag2 = false;
			int num = j;
			int num2 = 36;
			int num3 = Main.tile[i, j].frameY / num2;
			int num4 = Main.tile[i, j].frameY % num2;
			num -= num4 / 18;
			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = 0;
			while (num5 > 2) {
				num5 -= 3;
				num6++;
			}

			num5 = i - num5;
			int num7 = num6 * 54;
			if (type == 14 && num6 == 25)
				flag2 = true;

			int num8 = num + 2;
			if (flag2)
				num8--;

			for (int k = num5; k < num5 + 3; k++) {
				for (int l = num; l < num8; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num7 || Main.tile[k, l].frameY != (l - num) * 18 + num3 * 36)
						flag = true;
				}

				switch (type) {
					case 285:
					case 286:
					case 298:
					case 299:
					case 310:
					case 339:
					case 361:
					case 362:
					case 363:
					case 364:
						if (!SolidTileAllowBottomSlope(k, num8) && (!Main.tile[k, num8].nactive() || !Main.tileSolidTop[Main.tile[k, num8].type] || Main.tile[k, num8].frameY != 0) && (!Main.tile[k, num8].active() || !TileID.Sets.Platforms[Main.tile[k, num8].type]))
							flag = true;
						break;
					default:
						if (!SolidTileAllowBottomSlope(k, num8))
							flag = true;
						break;
				}
			}

			if (type == 187 && Main.tile[num5, num].frameX >= 756 && Main.tile[num5, num].frameX <= 900 && Main.tile[num5, num + 2].type != 2 && Main.tile[num5 + 1, num + 2].type != 2 && Main.tile[num5 + 2, num + 2].type != 2) {
				Main.tile[num5, num].frameX -= 378;
				Main.tile[num5 + 1, num].frameX -= 378;
				Main.tile[num5 + 2, num].frameX -= 378;
				Main.tile[num5, num + 1].frameX -= 378;
				Main.tile[num5 + 1, num + 1].frameX -= 378;
				Main.tile[num5 + 2, num + 1].frameX -= 378;
				Main.tile[num5, num].type = 186;
				Main.tile[num5 + 1, num].type = 186;
				Main.tile[num5 + 2, num].type = 186;
				Main.tile[num5, num + 1].type = 186;
				Main.tile[num5 + 1, num + 1].type = 186;
				Main.tile[num5 + 2, num + 1].type = 186;
			}

			if (!flag)
				return;

			int frameX = Main.tile[i, j].frameX;
			destroyObject = true;
			num8 = num + 3;
			if (flag2)
				num8--;

			for (int m = num5; m < num5 + 3; m++) {
				for (int n = num; n < num + 3; n++) {
					if (Main.tile[m, n] == null)
						Main.tile[m, n] = new Tile();

					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;
				
			if (type == 14) {
				int type2;
				if (num6 >= 1 && num6 <= 3) {
					type2 = 637 + num6;
				}
				else if (num6 >= 15 && num6 <= 20) {
					type2 = 1698 + num6;
				}
				else if (num6 >= 4 && num6 <= 7) {
					type2 = 823 + num6;
				}
				else {
					switch (num6) {
						case 8:
							type2 = 917;
							break;
						case 9:
							type2 = 1144;
							break;
						case 10:
							type2 = 1397;
							break;
						case 11:
							type2 = 1400;
							break;
						case 12:
							type2 = 1403;
							break;
						case 13:
							type2 = 1460;
							break;
						case 14:
							type2 = 1510;
							break;
						case 23:
							type2 = 1926;
							break;
						case 21:
							type2 = 1794;
							break;
						case 22:
							type2 = 1816;
							break;
						case 24:
							type2 = 2248;
							break;
						case 25:
							type2 = 2259;
							break;
						case 26:
							type2 = 2532;
							break;
						case 27:
							type2 = 2550;
							break;
						case 28:
							type2 = 677;
							break;
						case 29:
							type2 = 2583;
							break;
						case 30:
							type2 = 2743;
							break;
						case 31:
							type2 = 2824;
							break;
						case 32:
							type2 = 3153;
							break;
						case 33:
							type2 = 3155;
							break;
						case 34:
							type2 = 3154;
							break;
						default:
							type2 = 32;
							break;
					}
				}

				Item.NewItem(i * 16, j * 16, 32, 32, type2);
			}

			switch (type) {
				case 469: {
						int type6 = 3920;
						Item.NewItem(i * 16, j * 16, 32, 32, type6);
						break;
					}
				case 114:
					Item.NewItem(i * 16, j * 16, 32, 32, 398);
					break;
				case 26:
					if (!noTileActions && !IsGeneratingHardMode)
						SmashAltar();
					break;
				case 298:
					Item.NewItem(i * 16, j * 16, 32, 32, 2190);
					break;
				case 299:
					Item.NewItem(i * 16, j * 16, 32, 32, 2191);
					break;
				case 361:
				case 362:
				case 363:
				case 364:
					Item.NewItem(i * 16, j * 16, 32, 32, 3073 + type - 361);
					break;
				default:
					if (type >= 391 && type <= 394) {
						Item.NewItem(i * 16, j * 16, 48, 32, 3254 + type - 391);
						break;
					}
					switch (type) {
						case 285:
							Item.NewItem(i * 16, j * 16, 32, 32, 2174);
							break;
						case 286:
							Item.NewItem(i * 16, j * 16, 32, 32, 2175);
							break;
						case 310:
							Item.NewItem(i * 16, j * 16, 32, 32, 2207);
							break;
						case 339:
							Item.NewItem(i * 16, j * 16, 32, 32, 2741);
							break;
						case 217:
							Item.NewItem(i * 16, j * 16, 32, 32, 995);
							break;
						case 218:
							Item.NewItem(i * 16, j * 16, 32, 32, 996);
							break;
						case 219:
							Item.NewItem(i * 16, j * 16, 32, 32, 997);
							break;
						case 220:
							Item.NewItem(i * 16, j * 16, 32, 32, 998);
							break;
						case 377:
							Item.NewItem(i * 16, j * 16, 32, 32, 3198);
							break;
						case 228:
							Item.NewItem(i * 16, j * 16, 32, 32, 1120);
							break;
						case 405:
							Item.NewItem(i * 16, j * 16, 32, 32, 3364);
							break;
						case 215:
							switch (num6) {
								case 0:
									Item.NewItem(i * 16, j * 16, 32, 32, 966);
									break;
								case 6:
									Item.NewItem(i * 16, j * 16, 32, 32, 3723);
									break;
								case 7:
									Item.NewItem(i * 16, j * 16, 32, 32, 3724);
									break;
								default:
									Item.NewItem(i * 16, j * 16, 32, 32, 3046 + num6 - 1);
									break;
							}
							break;
						case 244:
							Item.NewItem(i * 16, j * 16, 32, 32, 1449);
							break;
						case 17:
							Item.NewItem(i * 16, j * 16, 32, 32, 33);
							break;
						case 77:
							Item.NewItem(i * 16, j * 16, 32, 32, 221);
							break;
						case 86:
							Item.NewItem(i * 16, j * 16, 32, 32, 332);
							break;
						case 237:
							Item.NewItem(i * 16, j * 16, 32, 32, 1292);
							break;
						case 87: {
								int type3;
								if (num6 >= 1 && num6 <= 3) {
									type3 = 640 + num6;
								}
								else {
									switch (num6) {
										case 4:
											type3 = 919;
											break;
										case 5:
										case 6:
										case 7:
											type3 = 2245 + num6 - 5;
											break;
										default:
											if (num6 >= 8 && num6 <= 10) {
												type3 = 2254 + num6 - 8;
												break;
											}
											if (num6 >= 11 && num6 <= 20) {
												type3 = 2376 + num6 - 11;
												break;
											}
											switch (num6) {
												case 21:
													type3 = 2531;
													break;
												case 22:
													type3 = 2548;
													break;
												case 23:
													type3 = 2565;
													break;
												case 24:
													type3 = 2580;
													break;
												case 25:
													type3 = 2671;
													break;
												case 26:
													type3 = 2821;
													break;
												case 27:
													type3 = 3141;
													break;
												case 28:
													type3 = 3143;
													break;
												case 29:
													type3 = 3142;
													break;
												case 30:
													type3 = 3915;
													break;
												case 31:
													type3 = 3916;
													break;
												default:
													type3 = 333;
													break;
											}
											break;
									}
								}

								Item.NewItem(i * 16, j * 16, 32, 32, type3);
								break;
							}
						case 88: {
								int type5;
								if (num6 >= 1 && num6 <= 3) {
									type5 = 646 + num6;
								}
								else {
									switch (num6) {
										case 4:
											type5 = 918;
											break;
										case 5:
										case 6:
										case 7:
										case 8:
										case 9:
										case 10:
										case 11:
										case 12:
										case 13:
										case 14:
										case 15:
											type5 = 2386 + num6 - 5;
											break;
										default:
											switch (num6) {
												case 16:
													type5 = 2529;
													break;
												case 17:
													type5 = 2545;
													break;
												case 18:
													type5 = 2562;
													break;
												case 19:
													type5 = 2577;
													break;
												case 20:
													type5 = 2637;
													break;
												case 21:
													type5 = 2638;
													break;
												case 22:
													type5 = 2639;
													break;
												case 23:
													type5 = 2640;
													break;
												case 24:
													type5 = 2816;
													break;
												case 25:
													type5 = 3132;
													break;
												case 26:
													type5 = 3134;
													break;
												case 27:
													type5 = 3133;
													break;
												case 28:
													type5 = 3911;
													break;
												case 29:
													type5 = 3912;
													break;
												case 30:
													type5 = 3913;
													break;
												case 31:
													type5 = 3914;
													break;
												default:
													type5 = 334;
													break;
											}
											break;
									}
								}

								Item.NewItem(i * 16, j * 16, 32, 32, type5);
								break;
							}
						case 89: {
								int type4;
								if (num6 >= 1 && num6 <= 20) {
									type4 = 2397 + num6 - 1;
								}
								else {
									switch (num6) {
										case 21:
											type4 = 2521;
											break;
										case 22:
											type4 = 2527;
											break;
										case 23:
											type4 = 2539;
											break;
										case 24:
											type4 = 858;
											break;
										case 25:
											type4 = 2582;
											break;
										case 26:
											type4 = 2634;
											break;
										case 27:
											type4 = 2635;
											break;
										case 28:
											type4 = 2636;
											break;
										case 29:
											type4 = 2823;
											break;
										case 30:
											type4 = 3150;
											break;
										case 31:
											type4 = 3152;
											break;
										case 32:
											type4 = 3151;
											break;
										case 33:
											type4 = 3918;
											break;
										case 34:
											type4 = 3919;
											break;
										default:
											type4 = 335;
											break;
									}
								}

								Item.NewItem(i * 16, j * 16, 32, 32, type4);
								break;
							}
						case 133:
							if (frameX >= 54)
								Item.NewItem(i * 16, j * 16, 32, 32, 1221);
							else
								Item.NewItem(i * 16, j * 16, 32, 32, 524);
							break;
						case 186:
							if (frameX < 864)
								break;
							if (frameX <= 954) {
								Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
								Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
								Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
								if (genRand.Next(3) != 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));

								if (genRand.Next(3) != 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));

								if (genRand.Next(3) != 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));

								if (genRand.Next(2) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));

								if (genRand.Next(2) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));

								if (genRand.Next(2) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));

								if (genRand.Next(3) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));

								if (genRand.Next(3) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));

								if (genRand.Next(3) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));

								if (genRand.Next(4) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));

								if (genRand.Next(4) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));

								if (genRand.Next(4) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));

								if (genRand.Next(5) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));

								if (genRand.Next(5) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));

								if (genRand.Next(5) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
							}
							else if (frameX <= 1062) {
								Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(10, 100));
								if (genRand.Next(2) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(20, 100));

								if (genRand.Next(3) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(30, 100));

								if (genRand.Next(4) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(40, 100));

								if (genRand.Next(5) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(50, 100));
							}
							else if (frameX <= 1170) {
								Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(1, 7));
								if (genRand.Next(2) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(2, 7));

								if (genRand.Next(3) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(3, 7));

								if (genRand.Next(4) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(4, 7));

								if (genRand.Next(5) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(5, 7));
							}
							break;
						case 187:
							if (frameX >= 918 && frameX <= 970) {
								if (Main.rand.Next(10) == 0)
									Item.NewItem(i * 16, j * 16, 32, 32, 3368);
								else
									Item.NewItem(i * 16, j * 16, 32, 32, 989);
							}
							break;
					}
					break;
			}

			skipDrop:
			destroyObject = false;
			for (int num9 = num5 - 1; num9 < num5 + 4; num9++) {
				for (int num10 = num - 1; num10 < num + 4; num10++) {
					TileFrame(num9, num10);
				}
			}
		}

		public static void Check3x4(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4;
			for (num4 = Main.tile[i, j].frameX / 18; num4 >= 3; num4 -= 3) {
				num3++;
			}

			num -= num4;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num; k < num + 3; k++) {
				for (int l = num2; l < num2 + 4; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 54 + (k - num) * 18 || Main.tile[k, l].frameY != (l - num2) * 18)
						flag = true;
				}

				if (Main.tile[k, num2 + 4] == null)
					Main.tile[k, num2 + 4] = new Tile();

				if (!SolidTileAllowBottomSlope(k, num2 + 4))
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + 3; m++) {
				for (int n = num2; n < num2 + 4; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;

			switch (type) {
				case 101: {
						int type2;
						switch (num3) {
							case 1:
								type2 = 1414;
								break;
							case 2:
								type2 = 1415;
								break;
							case 3:
								type2 = 1416;
								break;
							case 4:
								type2 = 1463;
								break;
							case 5:
								type2 = 1512;
								break;
							case 6:
								type2 = 2020;
								break;
							case 7:
								type2 = 2021;
								break;
							case 8:
								type2 = 2022;
								break;
							case 9:
								type2 = 2023;
								break;
							case 10:
								type2 = 2024;
								break;
							case 11:
								type2 = 2025;
								break;
							case 12:
								type2 = 2026;
								break;
							case 13:
								type2 = 2027;
								break;
							case 14:
								type2 = 2028;
								break;
							case 15:
								type2 = 2029;
								break;
							case 16:
								type2 = 2030;
								break;
							case 17:
								type2 = 2031;
								break;
							case 18:
							case 19:
							case 20:
							case 21:
								type2 = 2135 + num3 - 18;
								break;
							default:
								switch (num3) {
									case 22:
										type2 = 2233;
										break;
									case 23:
										type2 = 2536;
										break;
									case 24:
										type2 = 2540;
										break;
									case 25:
										type2 = 2554;
										break;
									case 26:
										type2 = 2569;
										break;
									case 27:
										type2 = 2670;
										break;
									case 28:
										type2 = 2817;
										break;
									case 29:
										type2 = 3165;
										break;
									case 30:
										type2 = 3167;
										break;
									case 31:
										type2 = 3166;
										break;
									case 32:
										type2 = 3917;
										break;
									default:
										type2 = 354;
										break;
								}
								break;
						}

						Item.NewItem(i * 16, j * 16, 32, 32, type2);
						break;
					}
				case 102:
					Item.NewItem(i * 16, j * 16, 32, 32, 355);
					break;
				case 463:
					Item.NewItem(i * 16, j * 16, 32, 32, 3813);
					break;
			}

			skipDrop:
			destroyObject = false;
			for (int num5 = num - 1; num5 < num + 4; num5++) {
				for (int num6 = num2 - 1; num6 < num2 + 4; num6++) {
					TileFrame(num5, num6);
				}
			}
		}

		public static void Check5x4(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4;
			for (num4 = Main.tile[i, j].frameX / 18; num4 >= 5; num4 -= 5) {
				num3++;
			}

			num -= num4;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num; k < num + 5; k++) {
				for (int l = num2; l < num2 + 4; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 90 + (k - num) * 18 || Main.tile[k, l].frameY != (l - num2) * 18)
						flag = true;
				}

				if (Main.tile[k, num2 + 4] == null)
					Main.tile[k, num2 + 4] = new Tile();

				if (!SolidTileAllowBottomSlope(k, num2 + 4))
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + 5; m++) {
				for (int n = num2; n < num2 + 4; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;

			if (type == 464)
				Item.NewItem(i * 16, j * 16, 32, 32, 3814);

			if (type == 466)
				Item.NewItem(i * 16, j * 16, 32, 32, 3816);

			skipDrop:
			destroyObject = false;
			for (int num5 = num - 1; num5 < num + 6; num5++) {
				for (int num6 = num2 - 1; num6 < num2 + 5; num6++) {
					TileFrame(num5, num6);
				}
			}
		}

		public static void Check6x3(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = i;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18 * -1;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num; k < num + 6; k++) {
				for (int l = num2; l < num2 + 3; l++) {
					int num3 = (k - num) * 18;
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 || Main.tile[k, l].frameY != (l - num2) * 18)
						flag = true;
				}

				if (Main.tile[k, num2 + 3] == null)
					Main.tile[k, num2 + 3] = new Tile();

				if (!SolidTileAllowBottomSlope(k, num2 + 3) && (!Main.tile[k, num2 + 3].nactive() || !Main.tileSolidTop[Main.tile[k, num2 + 3].type] || Main.tile[k, num2 + 3].frameY != 0))
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + 6; m++) {
				for (int n = num2; n < num2 + 3; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;

			if (type == 275)
				Item.NewItem(i * 16, j * 16, 32, 32, 2162);

			if (type == 413)
				Item.NewItem(i * 16, j * 16, 32, 32, 3565);

			if (type == 414)
				Item.NewItem(i * 16, j * 16, 32, 32, 3566);

			if (type == 276)
				Item.NewItem(i * 16, j * 16, 32, 32, 2163);

			if (type == 277)
				Item.NewItem(i * 16, j * 16, 32, 32, 2164);

			if (type == 278)
				Item.NewItem(i * 16, j * 16, 32, 32, 2165);

			if (type == 279)
				Item.NewItem(i * 16, j * 16, 32, 32, 2166);

			if (type == 280)
				Item.NewItem(i * 16, j * 16, 32, 32, 2167);

			if (type == 281)
				Item.NewItem(i * 16, j * 16, 32, 32, 2168);

			if (type == 296)
				Item.NewItem(i * 16, j * 16, 32, 32, 2186);

			if (type == 297)
				Item.NewItem(i * 16, j * 16, 32, 32, 2187);

			if (type == 309)
				Item.NewItem(i * 16, j * 16, 32, 32, 2206);

			if (type == 358)
				Item.NewItem(i * 16, j * 16, 32, 32, 3070);

			if (type == 359)
				Item.NewItem(i * 16, j * 16, 32, 32, 3071);

			skipDrop:
			destroyObject = false;
			for (int num4 = num - 1; num4 < num + 7; num4++) {
				for (int num5 = num2 - 1; num5 < num2 + 4; num5++) {
					TileFrame(num4, num5);
				}
			}
		}

		public static void Place6x3(int x, int y, ushort type, int direction = -1, int style = 0) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = x - 3; i < x + 3; i++) {
				for (int j = y - 2; j <= y; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
					flag = false;
			}

			if (!flag)
				return;

			int num = 0;
			for (int k = x - 3; k < x + 3; k++) {
				int num2 = 0;
				for (int l = y - 2; l <= y; l++) {
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].frameY = (short)num2;
					Main.tile[k, l].frameX = (short)num;
					Main.tile[k, l].type = type;
					num2 += 18;
				}

				num += 18;
			}
		}

		public static void Place4x2(int x, int y, ushort type, int direction = -1, int style = 0) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = x - 1; i < x + 3; i++) {
				for (int j = y - 1; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!SolidTile2(i, y + 1))
					flag = false;
			}

			short num = 0;
			if (direction == 1)
				num = 72;

			int num2 = 36 * style;
			if (flag) {
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = (short)num2;
				Main.tile[x - 1, y - 1].frameX = num;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = (short)num2;
				Main.tile[x, y - 1].frameX = (short)(18 + num);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = (short)num2;
				Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x + 2, y - 1].active(active: true);
				Main.tile[x + 2, y - 1].frameY = (short)num2;
				Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num2 + 18);
				Main.tile[x - 1, y].frameX = num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num2 + 18);
				Main.tile[x, y].frameX = (short)(18 + num);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = (short)(num2 + 18);
				Main.tile[x + 1, y].frameX = (short)(36 + num);
				Main.tile[x + 1, y].type = type;
				Main.tile[x + 2, y].active(active: true);
				Main.tile[x + 2, y].frameY = (short)(num2 + 18);
				Main.tile[x + 2, y].frameX = (short)(54 + num);
				Main.tile[x + 2, y].type = type;
			}
		}

		public static void ShootFromCannon(int x, int y, int angle, int ammo, int Damage, float KnockBack, int owner) {
			float num = 14f;
			float num2 = 0f;
			float num3 = 0f;
			int type = 162;
			if (ammo == 2)
				type = 281;

			if (ammo == 3)
				type = 178;

			if (ammo == 4) {
				type = 601;
				num = 3f;
			}

			if (ammo == 5) {
				type = 601;
				num = 3f;
			}

			int num4 = 0;
			if (ammo == 5)
				num4 = 1;

			if (angle == 0) {
				num2 = 10f;
				num3 = 0f;
			}

			if (angle == 1) {
				num2 = 7.5f;
				num3 = -2.5f;
			}

			if (angle == 2) {
				num2 = 5f;
				num3 = -5f;
			}

			if (angle == 3) {
				num2 = 2.75f;
				num3 = -6f;
			}

			if (angle == 4) {
				num2 = 0f;
				num3 = -10f;
			}

			if (angle == 5) {
				num2 = -2.75f;
				num3 = -6f;
			}

			if (angle == 6) {
				num2 = -5f;
				num3 = -5f;
			}

			if (angle == 7) {
				num2 = -7.5f;
				num3 = -2.5f;
			}

			if (angle == 8) {
				num2 = -10f;
				num3 = 0f;
			}

			Vector2 vector = new Vector2((x + 2) * 16, (y + 2) * 16);
			float num5 = num2;
			float num6 = num3;
			float num7 = (float)Math.Sqrt(num5 * num5 + num6 * num6);
			if (ammo == 4 || ammo == 5) {
				if (angle == 4)
					vector.X += 5f;

				vector.Y += 5f;
			}

			num7 = num / num7;
			num5 *= num7;
			num6 *= num7;
			if (Main.myPlayer != owner && Main.netMode == 2 && (ammo == 4 || ammo == 5)) {
				NetMessage.SendData(108, owner, -1, null, Damage, KnockBack, x, y, angle, ammo, owner);
				return;
			}

			if (Main.netMode == 2)
				owner = Main.myPlayer;

			Projectile.NewProjectile(vector.X, vector.Y, num5, num6, type, Damage, KnockBack, owner, num4);
		}

		public static void SwitchCannon(int i, int j) {
			int num;
			for (num = Main.tile[i, j].frameX / 18; num >= 4; num -= 4) {
			}

			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 >= 3; num2 -= 3) {
			}

			int num3 = 1;
			if (num < 2)
				num3 = -1;

			num = i - num;
			num2 = j - num2;
			if ((num3 == 1 && Main.tile[num, num2].frameY <= 52) || (num3 == -1 && Main.tile[num, num2].frameY >= 432))
				return;

			num3 *= -54;
			for (int k = num; k < num + 4; k++) {
				for (int l = num2; l < num2 + 3; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (Main.tile[k, l].active() && Main.tile[k, l].type == 209)
						Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num3);
				}
			}

			NetMessage.SendTileSquare(-1, num + 1, num2 + 1, 4);
		}

		public static void CheckCannon(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = Main.tile[i, j].frameX / 18;
			int num2 = 0;
			while (num >= 4) {
				num2++;
				num -= 4;
			}

			num = i - num;
			int num3 = Main.tile[i, j].frameY / 18;
			int num4 = 0;
			while (num3 >= 3) {
				num4 += 54;
				num3 -= 3;
			}

			num3 = j - num3;
			int num5 = 72 * num2;
			for (int k = num; k < num + 4; k++) {
				int num6 = num4;
				for (int l = num3; l < num3 + 3; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num5 || Main.tile[k, l].frameY != num6)
						flag = true;

					num6 += 18;
				}

				if (Main.tile[k, num3 + 3] == null)
					Main.tile[k, num3 + 3] = new Tile();

				if (!SolidTileAllowBottomSlope(k, num3 + 3) && k != num && k != num + 3)
					flag = true;

				num5 += 18;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + 4; m++) {
				for (int n = num3; n < num3 + 3; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;

			int type2 = 928;
			switch (num2) {
				case 1:
					type2 = 1337;
					break;
				case 2:
					type2 = 3369;
					break;
				case 3:
				case 4:
					type2 = 3664;
					break;
			}

			Item.NewItem(i * 16, j * 16, 32, 32, type2);
			skipDrop:
			destroyObject = false;
			for (int num7 = num; num7 < num + 4; num7++) {
				for (int num8 = num3; num8 < num3 + 3; num8++) {
					TileFrame(num7, num8);
				}
			}
		}

		public static void PlaceCannon(int x, int y, ushort type, int style = 0) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = x - 1; i < x + 3; i++) {
				for (int j = y - 2; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!SolidTile2(i, y + 1) && i != x - 1 && i != x + 2)
					flag = false;
			}

			int num = 72 * style;
			int num2 = 0;
			if (flag) {
				Main.tile[x - 1, y - 2].active(active: true);
				Main.tile[x - 1, y - 2].frameY = (short)num2;
				Main.tile[x - 1, y - 2].frameX = (short)num;
				Main.tile[x - 1, y - 2].type = type;
				Main.tile[x, y - 2].active(active: true);
				Main.tile[x, y - 2].frameY = (short)num2;
				Main.tile[x, y - 2].frameX = (short)(18 + num);
				Main.tile[x, y - 2].type = type;
				Main.tile[x + 1, y - 2].active(active: true);
				Main.tile[x + 1, y - 2].frameY = (short)num2;
				Main.tile[x + 1, y - 2].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 2].type = type;
				Main.tile[x + 2, y - 2].active(active: true);
				Main.tile[x + 2, y - 2].frameY = (short)num2;
				Main.tile[x + 2, y - 2].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 2].type = type;
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x - 1, y - 1].frameX = (short)num;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x, y - 1].frameX = (short)(18 + num);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x + 2, y - 1].active(active: true);
				Main.tile[x + 2, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num2 + 36);
				Main.tile[x - 1, y].frameX = (short)num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num2 + 36);
				Main.tile[x, y].frameX = (short)(18 + num);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = (short)(num2 + 36);
				Main.tile[x + 1, y].frameX = (short)(36 + num);
				Main.tile[x + 1, y].type = type;
				Main.tile[x + 2, y].active(active: true);
				Main.tile[x + 2, y].frameY = (short)(num2 + 36);
				Main.tile[x + 2, y].frameX = (short)(54 + num);
				Main.tile[x + 2, y].type = type;
			}
		}

		public static void SwitchMB(int i, int j) {
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameY / 18; num3 >= 2; num3 -= 2) {
			}

			int num4 = Main.tile[i, j].frameX / 18;
			if (num4 >= 2)
				num4 -= 2;

			num = i - num4;
			num2 = j - num3;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 2; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35
						|| TileLoader.IsModMusicBox(Main.tile[k, l]))) {
						if (Main.tile[k, l].frameX < 36)
							Main.tile[k, l].frameX += 36;
						else
							Main.tile[k, l].frameX -= 36;
					}
				}
			}

			if (Wiring.running) {
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 1);
			}

			NetMessage.SendTileSquare(-1, num, num2, 3);
		}

		public static void SwitchMonolith(int i, int j) {
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2) {
			}

			int num4 = Main.tile[i, j].frameY / 18;
			if (num4 >= 3)
				num4 -= 3;

			num = i - num3;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 3; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (Main.tile[k, l].active() && Main.tile[k, l].type == 410) {
						if (Main.tile[k, l].frameY < 56)
							Main.tile[k, l].frameY += 56;
						else
							Main.tile[k, l].frameY -= 56;
					}
				}
			}

			if (Wiring.running) {
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num, num2 + 2);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num + 1, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 2);
			}

			NetMessage.SendTileSquare(-1, num, num2 + 1, 3);
		}

		public static void SwitchFountain(int i, int j) {
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2) {
			}

			int num4 = Main.tile[i, j].frameY / 18;
			if (num4 >= 4)
				num4 -= 4;

			num = i - num3;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 4; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (Main.tile[k, l].active() && Main.tile[k, l].type == 207) {
						if (Main.tile[k, l].frameY < 72)
							Main.tile[k, l].frameY += 72;
						else
							Main.tile[k, l].frameY -= 72;
					}
				}
			}

			if (Wiring.running) {
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num, num2 + 2);
				Wiring.SkipWire(num, num2 + 3);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num + 1, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 2);
				Wiring.SkipWire(num + 1, num2 + 3);
			}

			NetMessage.SendTileSquare(-1, num, num2 + 1, 4);
		}

		public static void CheckMB(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4;
			for (num4 = Main.tile[i, j].frameY / 18; num4 >= 2; num4 -= 2) {
				num3++;
			}

			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = 0;
			if (num5 >= 2) {
				num5 -= 2;
				num6++;
			}

			num = i - num5;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 2; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num6 * 36 || Main.tile[k, l].frameY != (l - num2) * 18 + num3 * 36)
						flag = true;
				}

				if (!Main.tile[k, num2 + 2].nactive())
					flag = true;
				else if (!Main.tileSolid[Main.tile[k, num2 + 2].type] && !Main.tileTable[Main.tile[k, num2 + 2].type])
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + 2; m++) {
				for (int n = num2; n < num2 + 3; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			// size ???
			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;
			if (type == 35)
				Item.NewItem(i * 16, j * 16, 32, 32, 1813);
			else if (num3 == 28)
				Item.NewItem(i * 16, j * 16, 32, 32, 1963);
			else if (num3 == 29)
				Item.NewItem(i * 16, j * 16, 32, 32, 1964);
			else if (num3 == 30)
				Item.NewItem(i * 16, j * 16, 32, 32, 1965);
			else if (num3 == 31)
				Item.NewItem(i * 16, j * 16, 32, 32, 2742);
			else if (num3 == 32)
				Item.NewItem(i * 16, j * 16, 32, 32, 3044);
			else if (num3 == 33)
				Item.NewItem(i * 16, j * 16, 32, 32, 3235);
			else if (num3 == 34)
				Item.NewItem(i * 16, j * 16, 32, 32, 3236);
			else if (num3 == 35)
				Item.NewItem(i * 16, j * 16, 32, 32, 3237);
			else if (num3 == 36)
				Item.NewItem(i * 16, j * 16, 32, 32, 3370);
			else if (num3 == 37)
				Item.NewItem(i * 16, j * 16, 32, 32, 3371);
			else if (num3 == 38)
				Item.NewItem(i * 16, j * 16, 32, 32, 3796);
			else if (num3 == 39)
				Item.NewItem(i * 16, j * 16, 32, 32, 3869);
			else if (num3 >= 13)
				Item.NewItem(i * 16, j * 16, 32, 32, 1596 + num3 - 13);
			else
				Item.NewItem(i * 16, j * 16, 32, 32, 562 + num3);

			skipDrop:
			for (int num7 = num - 1; num7 < num + 3; num7++) {
				for (int num8 = num2 - 1; num8 < num2 + 3; num8++) {
					TileFrame(num7, num8);
				}
			}

			destroyObject = false;
		}

		public static void PlaceMB(int X, int y, ushort type, int style) {
			int num = X + 1;
			if (num < 5 || num > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = num - 1; i < num + 1; i++) {
				for (int j = y - 1; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!Main.tile[i, y + 1].active() || Main.tile[i, y + 1].halfBrick() || (!Main.tileSolid[Main.tile[i, y + 1].type] && !Main.tileTable[Main.tile[i, y + 1].type]))
					flag = false;
			}

			if (flag) {
				Main.tile[num - 1, y - 1].active(active: true);
				Main.tile[num - 1, y - 1].frameY = (short)(style * 36);
				Main.tile[num - 1, y - 1].frameX = 0;
				Main.tile[num - 1, y - 1].type = type;
				Main.tile[num, y - 1].active(active: true);
				Main.tile[num, y - 1].frameY = (short)(style * 36);
				Main.tile[num, y - 1].frameX = 18;
				Main.tile[num, y - 1].type = type;
				Main.tile[num - 1, y].active(active: true);
				Main.tile[num - 1, y].frameY = (short)(style * 36 + 18);
				Main.tile[num - 1, y].frameX = 0;
				Main.tile[num - 1, y].type = type;
				Main.tile[num, y].active(active: true);
				Main.tile[num, y].frameY = (short)(style * 36 + 18);
				Main.tile[num, y].frameX = 18;
				Main.tile[num, y].type = type;
			}
		}

		public static void Place2x2(int x, int y, ushort type, int style) {
			if (type == 95 || type == 126)
				y++;

			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			if (type == 172) {
				if (!CanPlaceSink(x, y, type, style))
					return;
			}
			else {
				for (int i = x - 1; i < x + 1; i++) {
					for (int j = y - 1; j < y + 1; j++) {
						Tile tileSafely = Framing.GetTileSafely(i, j);
						if (tileSafely.active() || (type == 98 && tileSafely.liquid > 0))
							return;
					}

					switch (type) {
						case 95:
						case 126: {
								Tile tileSafely = Framing.GetTileSafely(i, y - 2);
								if (!tileSafely.nactive() || !Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type])
									return;

								break;
							}
						default: {
								Tile tileSafely = Framing.GetTileSafely(i, y + 1);
								if (!tileSafely.nactive() || (!SolidTile2(tileSafely) && !Main.tileTable[tileSafely.type]))
									return;

								break;
							}
						case 132:
							break;
					}
				}
			}

			if (type == 132) {
				bool flag = true;
				if (Main.tile[x - 1, y + 1] == null)
					Main.tile[x - 1, y + 1] = new Tile();

				if (Main.tile[x, y + 1] == null)
					Main.tile[x, y + 1] = new Tile();

				if (!Main.tile[x - 1, y + 1].nactive() || (!SolidTile2(x - 1, y + 1) && !Main.tileTable[Main.tile[x - 1, y + 1].type]))
					flag = false;

				if (!Main.tile[x, y + 1].nactive() || (!SolidTile2(x, y + 1) && !Main.tileTable[Main.tile[x, y + 1].type]))
					flag = false;

				if (!flag && (Main.tile[x - 1, y - 1].wall < 1 || Main.tile[x, y - 1].wall < 1 || Main.tile[x - 1, y].wall < 1 || Main.tile[x - 1, y].wall < 1))
					return;
			}

			x--;
			y--;
			int num = (type == 172) ? 38 : 36;
			for (int k = 0; k < 2; k++) {
				for (int l = 0; l < 2; l++) {
					Tile tileSafely = Main.tile[x + k, y + l];
					tileSafely.active(active: true);
					tileSafely.frameX = (short)(k * 18);
					tileSafely.frameY = (short)(style * num + l * 18);
					tileSafely.type = type;
				}
			}
		}

		public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1) {
			//if (type >= 470)
			//	return false;

			if (!TileObject.CanPlace(x, y, type, style, direction, out TileObject objectData))
				return false;

			objectData.random = random;
			if (TileObject.Place(objectData) && !mute) {
				SquareTileFrame(x, y);
				Main.PlaySound(0, x * 16, y * 16);
			}

			return false;
		}

		public static bool ShiftTrapdoor(int x, int y, bool playerAbove, int onlyCloseOrOpen = -1) {
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type == 386 && onlyCloseOrOpen != 1) {
				Point topLeftAndStyles = GetTopLeftAndStyles(ref x, ref y, 2, 2, 18, 18);
				if (topLeftAndStyles.X == 0) {
					if (Main.netMode != 1 && Wiring.running) {
						Wiring.SkipWire(x, y);
						Wiring.SkipWire(x, y + 1);
						Wiring.SkipWire(x + 1, y);
						Wiring.SkipWire(x + 1, y + 1);
					}

					if (!Collision.EmptyTile(x, y + 1, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y + 1, ignoreTiles: true))
						return false;

					Main.PlaySound(8, x * 16 + 16, y * 16 + 16);
					for (int i = 0; i < 2; i++) {
						tileSafely = Framing.GetTileSafely(x + i, y);
						tileSafely.ClearTile();
					}

					for (int j = 0; j < 2; j++) {
						tileSafely = Framing.GetTileSafely(x + j, y + 1);
						tileSafely.type = 387;
						tileSafely.frameX = (short)(j * 18);
						tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
					}

					for (int k = -1; k < 3; k++) {
						for (int l = 0; l < 3; l++) {
							TileFrame(x + k, y + l);
						}
					}

					return true;
				}

				if (topLeftAndStyles.X == 1) {
					if (Main.netMode != 1 && Wiring.running) {
						Wiring.SkipWire(x, y - 1);
						Wiring.SkipWire(x, y);
						Wiring.SkipWire(x + 1, y - 1);
						Wiring.SkipWire(x + 1, y);
					}

					if (!Collision.EmptyTile(x, y, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y, ignoreTiles: true))
						return false;

					Main.PlaySound(8, x * 16 + 16, y * 16);
					for (int m = 0; m < 2; m++) {
						tileSafely = Framing.GetTileSafely(x + m, y + 1);
						tileSafely.ClearTile();
					}

					for (int n = 0; n < 2; n++) {
						tileSafely = Framing.GetTileSafely(x + n, y);
						tileSafely.type = 387;
						tileSafely.frameX = (short)(n * 18);
						tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
					}

					for (int num = -1; num < 3; num++) {
						for (int num2 = -1; num2 < 2; num2++) {
							TileFrame(x + num, y + num2);
						}
					}

					return true;
				}
			}

			if (tileSafely.type == 387 && onlyCloseOrOpen != 0) {
				GetTopLeftAndStyles(ref x, ref y, 2, 1, 18, 18);
				int num3 = playerAbove.ToDirectionInt();
				for (int num4 = 0; num4 < 2; num4++) {
					tileSafely = Framing.GetTileSafely(x + num4, y + num3);
					if (tileSafely.active() && !Main.tileCut[tileSafely.type])
						return false;
				}

				if (Main.netMode != 1 && Wiring.running) {
					Wiring.SkipWire(x, y);
					Wiring.SkipWire(x, y + num3);
					Wiring.SkipWire(x + 1, y);
					Wiring.SkipWire(x + 1, y + num3);
				}

				Main.PlaySound(8, x * 16 + 16, y * 16);
				for (int num5 = 0; num5 < 2; num5++) {
					tileSafely = Framing.GetTileSafely(x + num5, y + num3);
					if (tileSafely.active() && Main.tileCut[tileSafely.type])
						KillTile(x + num5, y + num3);
				}

				for (int num6 = 0; num6 < 2; num6++) {
					tileSafely = Framing.GetTileSafely(x + num6, y);
					byte color = tileSafely.color();
					for (int num7 = 0; num7 < 2; num7++) {
						tileSafely = Framing.GetTileSafely(x + num6, y + num7 - (!playerAbove).ToInt());
						tileSafely.type = 386;
						tileSafely.frameX = (short)(num6 * 18 + playerAbove.ToInt() * 36);
						tileSafely.frameY = (short)(num7 * 18);
						tileSafely.color(color);
						tileSafely.active(active: true);
					}
				}

				for (int num8 = -1; num8 < 3; num8++) {
					for (int num9 = -1; num9 < 3; num9++) {
						TileFrame(x + num8, y + num9 - (!playerAbove).ToInt() * 2);
					}
				}

				return true;
			}

			Main.PlaySound(9, x * 16, y * 16);
			return false;
		}

		public static void CheckTrapDoor(int x, int y, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = 0;
			int num2 = 0;
			Point point = default(Point);
			if (type == 387) {
				num = 2;
				num2 = 1;
				point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
				flag = (flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18) || !CheckTileAnchors(x, y, num, num2, 1, AnchorType.SolidTile));
			}

			if (type == 386) {
				num = 2;
				num2 = 2;
				point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
				flag = (flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18));
				if (point.X == 0)
					flag = (flag || !CheckTileAnchors(x, y + 1, num, 1, 1, AnchorType.SolidTile));
				else if (point.X == 1)
					flag = (flag || !CheckTileAnchors(x, y, num, 1, 1, AnchorType.SolidTile));
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int i = x; i < x + num; i++) {
				for (int j = y; j < y + num2; j++) {
					KillTile(i, j);
				}
			}

			int type2 = 3239;
			if (point.Y == 0)
				type2 = 3239;

			if (TileLoader.Drop(x, y, type))
				Item.NewItem(x * 16, y * 16, num * 16, num2 * 16, type2);

			for (int k = x - 1; k < x + num + 1; k++) {
				for (int l = y - 1; l < y + num2 + 1; l++) {
					TileFrame(k, l);
				}
			}

			destroyObject = false;
		}

		public static void CheckTallGate(int x, int y, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			Tile tileSafely = Framing.GetTileSafely(x, y);
			Point point = new Point(tileSafely.frameX / 18, 0);
			TileObjectData tileData = TileObjectData.GetTileData(type, point.X);
			point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
			int width = tileData.Width;
			int height = tileData.Height;
			int i = 0;
			for (int num = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num - tileData.CoordinateHeights[i] >= 0; i++) {
				num -= tileData.CoordinateHeights[i];
			}

			_ = tileData.CoordinateFullHeight;
			y -= i;
			int num2 = point.Y * tileData.CoordinateFullHeight;
			for (int j = 0; j < height; j++) {
				tileSafely = Framing.GetTileSafely(x, y + j);
				if (tileSafely.frameX != point.X * tileData.CoordinateFullWidth || tileSafely.frameY != num2) {
					flag = true;
					break;
				}

				num2 += tileData.CoordinateHeights[j] + tileData.CoordinatePadding;
			}

			if (!flag && CheckTileAnchors(x, y, width, height, 2, AnchorType.SolidTile))
				return;

			destroyObject = true;
			for (int k = x; k < x + width; k++) {
				for (int l = y; l < y + height; l++) {
					KillTile(k, l);
				}
			}

			int type2 = 3240;
			if (point.Y == 0)
				type2 = 3240;

			if (TileLoader.Drop(x, y, type))
				Item.NewItem(x * 16, y * 16, width * 16, height * 16, type2);

			for (int m = x - 1; m < x + width + 1; m++) {
				for (int n = y - 1; n < y + height + 1; n++) {
					TileFrame(m, n);
				}
			}

			destroyObject = false;
		}

		public static bool ShiftTallGate(int x, int y, bool closing) {
			ushort type = (ushort)(closing ? 388 : 389);
			ushort num = (ushort)(closing ? 389 : 388);
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type != num)
				return false;

			Point point = new Point(tileSafely.frameX / 18, 0);
			TileObjectData tileData = TileObjectData.GetTileData(388, point.X);
			point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
			_ = tileData.Width;
			int height = tileData.Height;
			int i = 0;
			for (int num2 = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num2 - tileData.CoordinateHeights[i] >= 0; i++) {
				num2 -= tileData.CoordinateHeights[i];
			}

			_ = tileData.CoordinateFullHeight;
			y -= i;
			if (Main.netMode != 1 && Wiring.running) {
				for (int j = 0; j < height; j++) {
					Wiring.SkipWire(x, y + j);
				}
			}

			for (int k = 0; k < height; k++) {
				if (!Collision.EmptyTile(x, y + k, ignoreTiles: true))
					return false;
			}

			Main.PlaySound(8, x * 16 + 16, y * 16 + 16);
			for (int l = 0; l < height; l++) {
				tileSafely = Framing.GetTileSafely(x, y + l);
				tileSafely.type = type;
			}

			for (int m = -1; m < 2; m++) {
				for (int n = -1; n < height + 1; n++) {
					TileFrame(x + m, y + n);
				}
			}

			return true;
		}

		public static Point GetTopLeftAndStyles(ref int x, ref int y, int w, int h, int frameXinc, int frameYinc) {
			Tile tileSafely = Framing.GetTileSafely(x, y);
			Point result = new Point(tileSafely.frameX / (w * frameXinc), tileSafely.frameY / (h * frameYinc));
			if (frameXinc != 0)
				x -= tileSafely.frameX / frameXinc % w;

			if (frameYinc != 0)
				y -= tileSafely.frameY / frameYinc % h;

			return result;
		}

		public static bool CheckTileFrames(int type, int sx, int sy, int w, int h, int styleX, int frameXinc, int styleY, int frameYinc) {
			for (int i = 0; i < w; i++) {
				for (int j = 0; j < h; j++) {
					Tile tileSafely = Framing.GetTileSafely(sx + i, sy + j);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != styleX * w * frameXinc + i * frameXinc || tileSafely.frameY != styleY * h * frameYinc + j * frameYinc)
						return false;
				}
			}

			return true;
		}

		public static bool CheckTileAnchors(int sx, int sy, int w, int h, int mode, AnchorType anchor) {
			if ((mode & 1) == 1) {
				for (int i = sy; i < sy + h; i++) {
					if (!AnchorValid(Framing.GetTileSafely(sx - 1, i), anchor))
						return false;

					if (!AnchorValid(Framing.GetTileSafely(sx + w, i), anchor))
						return false;
				}
			}

			if ((mode & 2) == 2) {
				for (int j = sx; j < sx + w; j++) {
					if (!AnchorValid(Framing.GetTileSafely(j, sy - 1), anchor))
						return false;

					if (!AnchorValid(Framing.GetTileSafely(j, sy + h), anchor))
						return false;
				}
			}

			return true;
		}

		public static bool AnchorValid(Tile tileCache, AnchorType anchor) {
			bool flag = false;
			if (tileCache.nactive()) {
				if ((anchor & AnchorType.SolidTile) == AnchorType.SolidTile && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type] && !Main.tileNoAttach[tileCache.type] && tileCache.blockType() == 0)
					flag = true;

				if ((anchor & AnchorType.SolidBottom) == AnchorType.SolidBottom && ((Main.tileSolid[tileCache.type] && (!Main.tileSolidTop[tileCache.type] || (TileID.Sets.Platforms[tileCache.type] && (tileCache.halfBrick() || tileCache.topSlope())))) || tileCache.topSlope() || tileCache.halfBrick()) && !TileID.Sets.NotReallySolid[tileCache.type] && !tileCache.bottomSlope())
					flag = true;

				if (!flag && ((anchor & AnchorType.SolidWithTop) == AnchorType.SolidWithTop || (anchor & AnchorType.Table) == AnchorType.Table)) {
					if (TileID.Sets.Platforms[tileCache.type]) {
						int num = tileCache.frameX / TileObjectData.PlatformFrameWidth();
						if ((!tileCache.halfBrick() && num >= 0 && num <= 7) || (num >= 12 && num <= 16) || (num >= 25 && num <= 26))
							flag = true;
					}
					else if (Main.tileSolid[tileCache.type] && Main.tileSolidTop[tileCache.type]) {
						flag = true;
					}
				}

				if (!flag && (anchor & AnchorType.Table) == AnchorType.Table && !TileID.Sets.Platforms[tileCache.type] && Main.tileTable[tileCache.type] && tileCache.blockType() == 0)
					flag = true;

				if (!flag && (anchor & AnchorType.SolidSide) == AnchorType.SolidSide && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type]) {
					int num2 = tileCache.blockType();
					if ((uint)(num2 - 4) <= 1u)
						flag = true;
				}
			}
			else if (!flag && (anchor & AnchorType.EmptyTile) == AnchorType.EmptyTile) {
				flag = true;
			}

			return flag;
		}

		public static bool CanPlaceSink(int x, int y, ushort type, int style) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return false;

			bool result = true;
			x--;
			y--;
			for (int i = 0; i < 2; i++) {
				Tile tileSafely;
				for (int j = 0; j < 2; j++) {
					tileSafely = Framing.GetTileSafely(x + i, y + j);
					if (tileSafely.active())
						result = false;
				}

				tileSafely = Framing.GetTileSafely(x + i, y + 2);
				if (!tileSafely.nactive() || !SolidTile(tileSafely))
					result = false;
			}

			return result;
		}

		public static void Place3x4(int x, int y, ushort type, int style) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = x - 1; i < x + 2; i++) {
				for (int j = y - 3; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!SolidTile2(i, y + 1))
					flag = false;
			}

			if (flag) {
				int num = style * 54;
				for (int k = -3; k <= 0; k++) {
					short frameY = (short)((3 + k) * 18);
					Main.tile[x - 1, y + k].active(active: true);
					Main.tile[x - 1, y + k].frameY = frameY;
					Main.tile[x - 1, y + k].frameX = (short)num;
					Main.tile[x - 1, y + k].type = type;
					Main.tile[x, y + k].active(active: true);
					Main.tile[x, y + k].frameY = frameY;
					Main.tile[x, y + k].frameX = (short)(num + 18);
					Main.tile[x, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 36);
					Main.tile[x + 1, y + k].type = type;
				}
			}
		}

		public static void Place5x4(int x, int y, ushort type, int style) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = x - 2; i < x + 3; i++) {
				for (int j = y - 3; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!SolidTile2(i, y + 1))
					flag = false;
			}

			if (flag) {
				int num = style * 54;
				for (int k = -3; k <= 0; k++) {
					short frameY = (short)((3 + k) * 18);
					Main.tile[x - 2, y + k].active(active: true);
					Main.tile[x - 2, y + k].frameY = frameY;
					Main.tile[x - 2, y + k].frameX = (short)(num - 36);
					Main.tile[x - 2, y + k].type = type;
					Main.tile[x - 1, y + k].active(active: true);
					Main.tile[x - 1, y + k].frameY = frameY;
					Main.tile[x - 1, y + k].frameX = (short)(num - 18);
					Main.tile[x - 1, y + k].type = type;
					Main.tile[x, y + k].active(active: true);
					Main.tile[x, y + k].frameY = frameY;
					Main.tile[x, y + k].frameX = (short)num;
					Main.tile[x, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 18);
					Main.tile[x + 1, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 36);
					Main.tile[x + 1, y + k].type = type;
				}
			}
		}

		public static void Place3x1(int x, int y, ushort type, int style = 0) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = x - 1; i < x + 2; i++) {
				if (Main.tile[i, y] == null)
					Main.tile[i, y] = new Tile();

				if (Main.tile[i, y].active())
					flag = false;

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!SolidTile2(i, y + 1))
					flag = false;
			}

			if (flag) {
				short num = (short)(54 * style);
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 0;
				Main.tile[x - 1, y].frameX = num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(num + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(num + 36);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Place3x2(int x, int y, ushort type, int style = 0) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			bool flag = false;
			bool flag2 = true;
			if (type == 14 && style == 25)
				flag = true;

			int num = y - 1;
			if (flag)
				num = y;

			for (int i = x - 1; i < x + 2; i++) {
				for (int j = num; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag2 = false;

					if (type == 215 && Main.tile[i, j].liquid > 0)
						flag2 = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				switch (type) {
					case 285:
					case 286:
					case 298:
					case 299:
					case 310:
					case 361:
					case 362:
					case 363:
					case 364:
						if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
							flag2 = false;
						break;
					default:
						if (!SolidTile2(i, y + 1))
							flag2 = false;
						break;
				}
			}

			if (TileLoader.IsDresser(type)) {
				if (Chest.CreateChest(x - 1, y - 1) == -1)
					flag2 = false;
				else if (Main.netMode == 1)
					NetMessage.SendData(34, -1, -1, null, 2, x, y, style);
			}

			if (flag2) {
				short num2 = (short)(54 * style);
				if (flag) {
					Main.tile[x - 1, y].active(active: true);
					Main.tile[x - 1, y].frameY = 0;
					Main.tile[x - 1, y].frameX = num2;
					Main.tile[x - 1, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].frameX = (short)(num2 + 18);
					Main.tile[x, y].type = type;
					Main.tile[x + 1, y].active(active: true);
					Main.tile[x + 1, y].frameY = 0;
					Main.tile[x + 1, y].frameX = (short)(num2 + 36);
					Main.tile[x + 1, y].type = type;
					return;
				}

				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = 0;
				Main.tile[x - 1, y - 1].frameX = num2;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = 0;
				Main.tile[x, y - 1].frameX = (short)(num2 + 18);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = 0;
				Main.tile[x + 1, y - 1].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 18;
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 18;
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 18;
				Main.tile[x + 1, y].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Place2x2Style(int x, int y, ushort type, int style = 0) {
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
				return;

			short num = 0;
			if (type == 254) {
				num = (short)(x % 12 / 2);
				num = (short)(num * 36);
			}

			bool flag = true;
			for (int i = x - 1; i < x + 1; i++) {
				for (int j = y - 1; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!SolidTile(i, y + 1))
					flag = false;

				if (type == 254 && Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 109)
					flag = false;
			}

			if (flag) {
				short num2 = (short)(36 * style);
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = num;
				Main.tile[x - 1, y - 1].frameX = num2;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = num;
				Main.tile[x, y - 1].frameX = (short)(num2 + 18);
				Main.tile[x, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num + 18);
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num + 18);
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
			}
		}

		public static bool NearFriendlyWall(int x, int y) {
			try {
				if (x < 2 || x >= Main.maxTilesX - 2 || y < 2 || y >= Main.maxTilesY - 2)
					return true;

				if (Main.tile[x, y].wall == 0 || Main.wallHouse[Main.tile[x, y].wall])
					return true;

				if (Main.tile[x - 1, y].wall == 0 || Main.wallHouse[Main.tile[x - 1, y].wall])
					return true;

				if (Main.tile[x + 1, y].wall == 0 || Main.wallHouse[Main.tile[x + 1, y].wall])
					return true;

				if (Main.tile[x, y - 1].wall == 0 || Main.wallHouse[Main.tile[x, y - 1].wall])
					return true;

				if (Main.tile[x, y + 1].wall == 0 || Main.wallHouse[Main.tile[x, y + 1].wall])
					return true;
			}
			catch {
			}

			return false;
		}

		public static void Check2x2Style(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = j;
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2) {
			}

			num -= num2;
			int num3 = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num3 > 1) {
				num3 -= 2;
				num4++;
			}

			num3 = i - num3;
			int num5 = num4 * 36;
			for (int k = num3; k < num3 + 2; k++) {
				for (int l = num; l < num + 2; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
						flag = true;
				}

				if (!SolidTileAllowBottomSlope(k, num + 2))
					flag = true;
			}

			if (!flag)
				return;

			int frameX = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int m = num3; m < num3 + 2; m++) {
				for (int n = num; n < num + 2; n++) {
					if (Main.tile[m, n] == null)
						Main.tile[m, n] = new Tile();

					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;

			switch (type) {
				case 254:
					if (frameX < 72)
						break;
					if (frameX < 108) {
						if (genRand.Next(2) == 0)
							Item.NewItem(i * 16, j * 16, 32, 32, 1725, genRand.Next(1, 3));

						break;
					}
					if (frameX < 144) {
						Item.NewItem(i * 16, j * 16, 32, 32, 1725, genRand.Next(2, 6));
						break;
					}
					Item.NewItem(i * 16, j * 16, 32, 32, 1725, genRand.Next(5, 11));
					if (Main.halloween && genRand.Next(200) == 0)
						Item.NewItem(i * 16, j * 16, 32, 32, 1799);
					break;
				case 457:
					Item.NewItem(i * 16, j * 16, 32, 32, 3749);
					break;
				case 96:
					if (num4 == 0)
						Item.NewItem(i * 16, j * 16, 32, 32, 345);
					if (num4 == 1)
						Item.NewItem(i * 16, j * 16, 32, 32, 1791);
					break;
				case 441: {
						int num7 = -1;
						switch (num4) {
							case 0:
								num7 = 3665;
								break;
							case 1:
								num7 = 3666;
								break;
							case 3:
								num7 = 3667;
								break;
							case 7:
								num7 = 3668;
								break;
							case 8:
								num7 = 3669;
								break;
							case 9:
								num7 = 3670;
								break;
							case 10:
								num7 = 3671;
								break;
							case 11:
								num7 = 3672;
								break;
							case 12:
								num7 = 3673;
								break;
							case 13:
								num7 = 3674;
								break;
							case 14:
								num7 = 3675;
								break;
							case 15:
								num7 = 3676;
								break;
							case 16:
								num7 = 3677;
								break;
							case 17:
								num7 = 3678;
								break;
							case 18:
								num7 = 3679;
								break;
							case 19:
								num7 = 3680;
								break;
							case 20:
								num7 = 3681;
								break;
							case 21:
								num7 = 3682;
								break;
							case 22:
								num7 = 3683;
								break;
							case 28:
								num7 = 3684;
								break;
							case 29:
								num7 = 3685;
								break;
							case 30:
								num7 = 3686;
								break;
							case 31:
								num7 = 3687;
								break;
							case 32:
								num7 = 3688;
								break;
							case 33:
								num7 = 3689;
								break;
							case 34:
								num7 = 3690;
								break;
							case 35:
								num7 = 3691;
								break;
							case 37:
								num7 = 3692;
								break;
							case 39:
								num7 = 3693;
								break;
							case 41:
								num7 = 3694;
								break;
							case 42:
								num7 = 3695;
								break;
							case 43:
								num7 = 3696;
								break;
							case 44:
								num7 = 3697;
								break;
							case 45:
								num7 = 3698;
								break;
							case 46:
								num7 = 3699;
								break;
							case 47:
								num7 = 3700;
								break;
							case 48:
								num7 = 3701;
								break;
							case 49:
								num7 = 3702;
								break;
							case 50:
								num7 = 3703;
								break;
							case 51:
								num7 = 3704;
								break;
						}

						if (num7 != -1)
							Item.NewItem(i * 16, j * 16, 32, 32, num7);

						break;
					}
				case 468: {
						int num6 = -1;
						switch (num4) {
							case 0:
								num6 = 3886;
								break;
							case 1:
								num6 = 3887;
								break;
						}

						if (num6 != -1)
							Item.NewItem(i * 16, j * 16, 32, 32, num6);

						break;
					}
			}

			skipDrop:
			destroyObject = false;
			for (int num8 = num3 - 1; num8 < num3 + 3; num8++) {
				for (int num9 = num - 1; num9 < num + 3; num9++) {
					TileFrame(num8, num9);
				}
			}
		}

		public static void PlacePumpkin(int x, int superY) {
			ushort type = 254;
			int num = genRand.Next(6) * 36;
			if (x < 5 || x > Main.maxTilesX - 5 || superY < 5 || superY > Main.maxTilesY - 5)
				return;

			bool flag = true;
			for (int i = x - 1; i < x + 1; i++) {
				for (int j = superY - 1; j < superY + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active() && Main.tile[i, j].type != 3 && Main.tile[i, j].type != 73 && Main.tile[i, j].type != 113 && Main.tile[i, j].type != 110 && (Main.tile[i, j].type != 185 || Main.tile[i, j].frameY != 0))
						flag = false;

					if (Main.tile[i, j].liquid > 0)
						flag = false;
				}

				if (!SolidTile(i, superY + 1) || (Main.tile[i, superY + 1].type != 2 && Main.tile[i, superY + 1].type != 109))
					flag = false;
			}

			if (flag) {
				Main.tile[x - 1, superY - 1].active(active: true);
				Main.tile[x - 1, superY - 1].frameY = (short)num;
				Main.tile[x - 1, superY - 1].frameX = 0;
				Main.tile[x - 1, superY - 1].type = type;
				Main.tile[x, superY - 1].active(active: true);
				Main.tile[x, superY - 1].frameY = (short)num;
				Main.tile[x, superY - 1].frameX = 18;
				Main.tile[x, superY - 1].type = type;
				Main.tile[x - 1, superY].active(active: true);
				Main.tile[x - 1, superY].frameY = (short)(num + 18);
				Main.tile[x - 1, superY].frameX = 0;
				Main.tile[x - 1, superY].type = type;
				Main.tile[x, superY].active(active: true);
				Main.tile[x, superY].frameY = (short)(num + 18);
				Main.tile[x, superY].frameX = 18;
				Main.tile[x, superY].type = type;
			}
		}

		public static void GrowPumpkin(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = j;
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2) {
			}

			num -= num2;
			int num3 = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num3 > 1) {
				num3 -= 2;
				num4++;
			}

			num3 = i - num3;
			int num5 = num4 * 36;
			if (num4 >= 4)
				return;

			for (int k = num3; k < num3 + 2; k++) {
				for (int l = num; l < num + 2; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
						flag = true;
				}

				if (!SolidTile(k, num + 2) || (Main.tile[k, num + 2].type != 2 && Main.tile[k, num + 2].type != 109))
					flag = true;
			}

			if (!flag) {
				for (int m = num3; m < num3 + 2; m++) {
					for (int n = num; n < num + 2; n++) {
						if (Main.tile[m, n] == null)
							Main.tile[m, n] = new Tile();

						if (Main.tile[m, n].type == type && Main.tile[m, n].active())
							Main.tile[m, n].frameX += 36;
					}
				}
			}

			if (Main.netMode == 2)
				NetMessage.SendTileSquare(-1, num3, num, 4);
		}

		public static void FixHearts() {
			for (int i = 0; i < Main.maxTilesX; i++) {
				for (int j = 0; j < Main.maxTilesY; j++) {
					Tile tile = Main.tile[i, j];
					if (tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
						FixHeart(i, j);
				}
			}
		}

		public static void DestroyHeart(int i, int j) {
			destroyObject = true;
			for (int k = i; k < i + 2; k++) {
				for (int l = j; l < j + 2; l++) {
					if (k < Main.maxTilesX && l < Main.maxTilesY) {
						Tile tile = Main.tile[k, l];
						if (tile.active() && tile.type == 12)
							KillTile(k, l);
					}
				}
			}

			destroyObject = false;
		}

		public static void FixHeart(int i, int j) {
			if (i < 40 || i >= Main.maxTilesX - 40 || j < 40 || j >= Main.maxTilesY - 40) {
				DestroyHeart(i, j);
				return;
			}

			Tile tile = Main.tile[i, j + 2];
			Tile tile2 = Main.tile[i + 1, j + 2];
			if (tile.active() && !Main.tileSolid[tile.type] && Main.tileCut[tile.type])
				KillTile(i, j + 2);

			if (tile2.active() && !Main.tileSolid[tile2.type] && Main.tileCut[tile2.type])
				KillTile(i + 1, j + 2);

			if (!tile.active()) {
				if (!tile2.active()) {
					DestroyHeart(i, j);
					return;
				}

				if (Main.tileSolid[tile2.type]) {
					tile.type = tile2.type;
					tile.active(active: true);
				}
			}

			if (!tile2.active() && Main.tileSolid[tile.type]) {
				tile2.type = tile.type;
				tile2.active(active: true);
			}

			if (!tile.nactive() || !Main.tileSolid[tile.type] || !tile2.nactive() || !Main.tileSolid[tile2.type]) {
				DestroyHeart(i, j);
				return;
			}

			if (tile.blockType() != 0) {
				tile.slope(0);
				tile.halfBrick(halfBrick: false);
			}

			if (tile2.blockType() != 0) {
				tile2.slope(0);
				tile2.halfBrick(halfBrick: false);
			}
		}

		public static void FixChands() {
			for (int i = 5; i < Main.maxTilesX - 5; i++) {
				for (int j = 5; j < Main.maxTilesY - 5; j++) {
					if (Main.tile[i, j].active()) {
						int type = Main.tile[i, j].type;
						if (Main.tile[i, j].active() && (type == 35 || type == 36 || type == 170 || type == 171 || type == 172))
							FixChand(i, j);
					}
				}
			}
		}

		public static void FixChand(int i, int j) {
			int num = 0;
			int type = Main.tile[i, j].type;
			if (Main.tile[i, j].active()) {
				if (type == 35)
					num = 1;

				if (type == 36)
					num = 2;

				if (type == 170)
					num = 3;

				if (type == 171)
					num = 4;

				if (type == 172)
					num = 5;
			}

			if (num <= 0)
				return;

			int num2 = i;
			int num3 = j;
			for (num2 = Main.tile[i, j].frameX / 18; num2 >= 3; num2 -= 3) {
			}

			if (num2 >= 3)
				num2 -= 3;

			num2 = i - num2;
			num3 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num2; k < num2 + 3; k++) {
				for (int l = num3; l < num3 + 3; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (Main.tile[k, l].active() && Main.tile[k, l].type == type) {
						Main.tile[k, l].type = 34;
						Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num * 54);
					}
				}
			}
		}

		public static void PlaceChand(int x, int y, ushort type, int style = 0) {
			bool flag = true;
			int num = 0;
			for (int i = x - 1; i < x + 2; i++) {
				for (int j = y; j < y + 3; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}
			}

			if (Main.tile[x, y - 1] == null)
				Main.tile[x, y - 1] = new Tile();

			if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
				flag = false;

			if (flag) {
				int num2 = style / 36 * 108;
				int num3 = style * 18 * 3;
				Main.tile[x - 1, y + num].active(active: true);
				Main.tile[x - 1, y + num].frameY = (short)num3;
				Main.tile[x - 1, y + num].frameX = (short)num2;
				Main.tile[x - 1, y + num].type = type;
				Main.tile[x, y + num].active(active: true);
				Main.tile[x, y + num].frameY = (short)num3;
				Main.tile[x, y + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + num].type = type;
				Main.tile[x + 1, y + num].active(active: true);
				Main.tile[x + 1, y + num].frameY = (short)num3;
				Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + num].type = type;
				Main.tile[x - 1, y + 1 + num].active(active: true);
				Main.tile[x - 1, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 1 + num].type = type;
				Main.tile[x, y + 1 + num].active(active: true);
				Main.tile[x, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 1 + num].type = type;
				Main.tile[x + 1, y + 1 + num].active(active: true);
				Main.tile[x + 1, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 1 + num].type = type;
				Main.tile[x - 1, y + 2 + num].active(active: true);
				Main.tile[x - 1, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 2 + num].type = type;
				Main.tile[x, y + 2 + num].active(active: true);
				Main.tile[x, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 2 + num].type = type;
				Main.tile[x + 1, y + 2 + num].active(active: true);
				Main.tile[x + 1, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 2 + num].type = type;
			}
		}

		public static void CheckChand(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 3;
			if (type == 454)
				num3 = 4;

			num = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num >= num3) {
				num4++;
				num -= num3;
			}

			int num5 = i - num;
			int num6 = 18 * num3 * num4;
			if (num >= num3)
				num -= num3;

			num = i - num;
			num2 = Main.tile[i, j].frameY / 18;
			int num7 = 0;
			while (num2 >= 3) {
				num7++;
				num2 -= 3;
			}

			if (num6 >= 108)
				num7 += 37 * (num6 / 108);

			int num8 = 54 * num7;
			if (num6 >= 108)
				num8 -= 54 * (num6 / 108) * 37;

			if (num2 >= 3)
				num2 -= 3;

			num2 = j - num2;
			for (int k = num; k < num + num3; k++) {
				for (int l = num2; l < num2 + 3; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num6 || Main.tile[k, l].frameY != (l - num2) * 18 + num8)
						flag = true;
				}
			}

			if (Main.tile[num + 1, num2 - 1] == null)
				Main.tile[num + 1, num2 - 1] = new Tile();

			if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
				flag = true;

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + num3; m++) {
				for (int n = num2; n < num2 + 3; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (!TileLoader.Drop(i, j, type))
				goto skipDrop;
			if (type == 454) {
				switch (Main.rand.Next(9)) {
					case 2:
					case 3:
					case 4: {
							int num13 = Main.rand.Next(10, 31);
							while (num13 > 0) {
								int num14 = Main.rand.Next(2, 11);
								if (num14 > num13)
									num14 = num13;

								num13 -= num14;
								Item.NewItem(i * 16, j * 16, 32, 32, 72, num14);
							}

							break;
						}
					case 5:
					case 6: {
							int num17 = Main.rand.Next(60, 80);
							while (num17 > 0) {
								int num18 = Main.rand.Next(3, 16);
								if (num18 > num17)
									num18 = num17;

								num17 -= num18;
								Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, num18);
							}

							Item.NewItem(i * 16, j * 16, 32, 32, 1358);
							break;
						}
					case 7: {
							int num15 = Main.rand.Next(10, 31);
							while (num15 > 0) {
								int num16 = Main.rand.Next(2, 9);
								if (num16 > num15)
									num16 = num15;

								num15 -= num16;
								Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, num16);
							}

							if (Main.rand.Next(8) == 0)
								Item.NewItem(i * 16, j * 16, 32, 32, 3532);

							if (Main.rand.Next(8) == 0)
								Item.NewItem(i * 16, j * 16, 32, 32, 3532);

							Item.NewItem(i * 16, j * 16, 32, 32, 73);
							break;
						}
					case 8: {
							int num9 = 100;
							while (num9 > 0) {
								int num10 = Main.rand.Next(3, 16);
								if (num10 > num9)
									num10 = num9;

								num9 -= num10;
								Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, num10);
							}

							int num11 = Main.rand.Next(30, 91);
							while (num11 > 0) {
								int num12 = Main.rand.Next(7, 14);
								if (num12 > num11)
									num12 = num11;

								num11 -= num12;
								Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 1349, num12);
							}

							Item.NewItem(i * 16, j * 16, 32, 32, 1358);
							Item.NewItem(i * 16, j * 16, 32, 32, 73);
							break;
						}
				}
			}

			if (type == 34) {
				int type2;
				switch (num7) {
					case 1:
						type2 = 107;
						break;
					case 2:
						type2 = 108;
						break;
					case 3:
						type2 = 710;
						break;
					case 4:
						type2 = 711;
						break;
					case 5:
						type2 = 712;
						break;
					case 6:
						type2 = 1812;
						break;
					case 7:
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
					case 14:
					case 15:
					case 16:
					case 17:
						type2 = 2055 + num7 - 7;
						break;
					default:
						if (num7 >= 18 && num7 <= 21) {
							type2 = 2141 + num7 - 18;
							break;
						}
						switch (num7) {
							case 22:
								type2 = 2224;
								break;
							case 23:
								type2 = 2525;
								break;
							case 24:
								type2 = 2543;
								break;
							case 25:
								type2 = 2558;
								break;
							case 26:
								type2 = 2573;
								break;
							case 27:
								type2 = 2652;
								break;
							case 28:
								type2 = 2653;
								break;
							case 29:
								type2 = 2654;
								break;
							case 30:
								type2 = 2655;
								break;
							case 31:
								type2 = 2656;
								break;
							case 32:
								type2 = 2657;
								break;
							case 33:
								type2 = 2813;
								break;
							case 34:
								type2 = 3177;
								break;
							case 35:
								type2 = 3179;
								break;
							case 36:
								type2 = 3178;
								break;
							case 37:
								type2 = 3894;
								break;
							default:
								type2 = 106;
								break;
						}
						break;
				}

				Item.NewItem(i * 16, j * 16, 32, 32, type2);
			}

			skipDrop:
			destroyObject = false;
			for (int num19 = num - 1; num19 < num + num3 + 1; num19++) {
				for (int num20 = num2 - 1; num20 < num2 + 4; num20++) {
					TileFrame(num19, num20);
				}
			}
		}

		public static void Check3x3(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 3) {
				num3++;
				num -= 3;
			}

			int num4 = i - num;
			int num5 = 54 * num3;
			int num6 = Main.tile[i, j].frameY / 54;
			int num7 = Main.tile[i, j].frameY % 54 / 18;
			if (num >= 3)
				num -= 3;

			num = i - num;
			num2 -= num7;
			for (int k = num; k < num + 3; k++) {
				for (int l = num2; l < num2 + 3; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18 + num6 * 54)
						flag = true;
				}
			}

			if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 406 || type == 412 || type == 452 || type == 455) {
				for (int m = num; m < num + 3; m++) {
					if (Main.tile[m, num2 + 3] == null)
						Main.tile[m, num2 + 3] = new Tile();

					if (!SolidTileAllowBottomSlope(m, num2 + 3)) {
						flag = true;
						break;
					}
				}
			}
			else {
				if (Main.tile[num + 1, num2 - 1] == null)
					Main.tile[num + 1, num2 - 1] = new Tile();

				if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int n = num; n < num + 3; n++) {
				for (int num8 = num2; num8 < num2 + 3; num8++) {
					if (Main.tile[n, num8].type == type && Main.tile[n, num8].active())
						KillTile(n, num8);
				}
			}

			if (!TileLoader.Drop(num, j, type))
				goto skipDrop;

			switch (type) {
				case 106:
					Item.NewItem(i * 16, j * 16, 32, 32, 363);
					break;
				case 243:
					Item.NewItem(i * 16, j * 16, 32, 32, 1430);
					break;
				case 212:
					Item.NewItem(i * 16, j * 16, 32, 32, 951);
					break;
				case 219:
					Item.NewItem(i * 16, j * 16, 32, 32, 997);
					break;
				case 220:
					Item.NewItem(i * 16, j * 16, 32, 32, 998);
					break;
				case 228:
					Item.NewItem(i * 16, j * 16, 32, 32, 1120);
					break;
				case 247:
					Item.NewItem(i * 16, j * 16, 32, 32, 1551);
					break;
				case 283:
					Item.NewItem(i * 16, j * 16, 32, 32, 2172);
					break;
				case 300:
				case 301:
				case 302:
				case 303:
				case 304:
				case 305:
				case 306:
					Item.NewItem(i * 16, j * 16, 32, 32, 2192 + type - 300);
					break;
				default:
					switch (type) {
						case 307:
							Item.NewItem(i * 16, j * 16, 32, 32, 2203);
							break;
						case 308:
							Item.NewItem(i * 16, j * 16, 32, 32, 2204);
							break;
						case 406:
							Item.NewItem(i * 16, j * 16, 32, 32, 3365);
							break;
						case 452:
							Item.NewItem(i * 16, j * 16, 32, 32, 3742);
							break;
						case 354:
							Item.NewItem(i * 16, j * 16, 32, 32, 2999);
							break;
						case 355:
							Item.NewItem(i * 16, j * 16, 32, 32, 3000);
							break;
						case 412:
							Item.NewItem(i * 16, j * 16, 32, 32, 3549);
							break;
						case 455:
							Item.NewItem(i * 16, j * 16, 32, 32, 3747);
							break;
						case 231: {
								int num9 = (i + 1) * 16 + 8;
								int num10 = j * 16;
								Gore.NewGore(new Vector2(num9, num10), default(Vector2), 300);
								Gore.NewGore(new Vector2(num9, num10 + 8), default(Vector2), 301);
								Gore.NewGore(new Vector2(num9, num10 + 16), default(Vector2), 302);
								float num11 = i * 16;
								float num12 = j * 16;
								float num13 = -1f;
								int plr = 0;
								for (int num14 = 0; num14 < 255; num14++) {
									if (Main.player[num14].active && !Main.player[num14].dead) {
										float num15 = Math.Abs(Main.player[num14].position.X - num11) + Math.Abs(Main.player[num14].position.Y - num12);
										if (num15 < num13 || num13 == -1f) {
											plr = num14;
											num13 = num15;
										}
									}
								}

								NPC.SpawnOnPlayer(plr, 222);
								break;
							}
					}
					break;
			}

			skipDrop:
			destroyObject = false;
			for (int num16 = num - 1; num16 < num + 4; num16++) {
				for (int num17 = num2 - 1; num17 < num2 + 4; num17++) {
					TileFrame(num16, num17);
				}
			}
		}

		public static void Place3x3(int x, int y, ushort type, int style = 0) {
			bool flag = true;
			int num = 0;
			if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355) {
				num = -2;
				for (int i = x - 1; i < x + 2; i++) {
					for (int j = y - 2; j < y + 1; j++) {
						if (Main.tile[i, j] == null)
							Main.tile[i, j] = new Tile();

						if (Main.tile[i, j].active())
							flag = false;
					}
				}

				for (int k = x - 1; k < x + 2; k++) {
					if (Main.tile[k, y + 1] == null)
						Main.tile[k, y + 1] = new Tile();

					if (!SolidTile2(k, y + 1)) {
						flag = false;
						break;
					}
				}
			}
			else {
				for (int l = x - 1; l < x + 2; l++) {
					for (int m = y; m < y + 3; m++) {
						if (Main.tile[l, m] == null)
							Main.tile[l, m] = new Tile();

						if (Main.tile[l, m].active())
							flag = false;
					}
				}

				if (Main.tile[x, y - 1] == null)
					Main.tile[x, y - 1] = new Tile();

				if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
					flag = false;
			}

			if (flag) {
				int num2 = style * 18 * 3;
				Main.tile[x - 1, y + num].active(active: true);
				Main.tile[x - 1, y + num].frameY = 0;
				Main.tile[x - 1, y + num].frameX = (short)num2;
				Main.tile[x - 1, y + num].type = type;
				Main.tile[x, y + num].active(active: true);
				Main.tile[x, y + num].frameY = 0;
				Main.tile[x, y + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + num].type = type;
				Main.tile[x + 1, y + num].active(active: true);
				Main.tile[x + 1, y + num].frameY = 0;
				Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + num].type = type;
				Main.tile[x - 1, y + 1 + num].active(active: true);
				Main.tile[x - 1, y + 1 + num].frameY = 18;
				Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 1 + num].type = type;
				Main.tile[x, y + 1 + num].active(active: true);
				Main.tile[x, y + 1 + num].frameY = 18;
				Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 1 + num].type = type;
				Main.tile[x + 1, y + 1 + num].active(active: true);
				Main.tile[x + 1, y + 1 + num].frameY = 18;
				Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 1 + num].type = type;
				Main.tile[x - 1, y + 2 + num].active(active: true);
				Main.tile[x - 1, y + 2 + num].frameY = 36;
				Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 2 + num].type = type;
				Main.tile[x, y + 2 + num].active(active: true);
				Main.tile[x, y + 2 + num].frameY = 36;
				Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 2 + num].type = type;
				Main.tile[x + 1, y + 2 + num].active(active: true);
				Main.tile[x + 1, y + 2 + num].frameY = 36;
				Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 2 + num].type = type;
			}
		}

		public static void PlaceSunflower(int x, int y, ushort type = 27) {
			if ((double)y > Main.worldSurface - 1.0)
				return;

			bool flag = true;
			for (int i = x; i < x + 2; i++) {
				for (int j = y - 3; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active() || Main.tile[i, j].wall > 0)
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || (Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 109))
					flag = false;
			}

			if (!flag)
				return;

			int num = genRand.Next(3);
			for (int k = 0; k < 2; k++) {
				for (int l = -3; l < 1; l++) {
					int num2 = k * 18 + genRand.Next(3) * 36;
					if (l <= -2)
						num2 = k * 18 + num * 36;

					int num3 = (l + 3) * 18;
					Main.tile[x + k, y + l].active(active: true);
					Main.tile[x + k, y + l].frameX = (short)num2;
					Main.tile[x + k, y + l].frameY = (short)num3;
					Main.tile[x + k, y + l].type = type;
				}
			}
		}

		public static void FixSunflowers() {
			for (int i = 5; i < Main.maxTilesX - 5; i++) {
				for (int j = 5; (double)j < Main.worldSurface; j++) {
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 27)
						FixSunflower(i, j);
				}
			}
		}

		public static void FixSunflower(int i, int j) {
			if (Main.tile[i, j].type != 27)
				return;

			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1) {
				num -= 2;
			}

			num *= -1;
			num += i;
			int num3 = genRand.Next(3) * 36;
			int num4 = 0;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 4; l++) {
					Main.tile[k, l].frameX = (short)(num4 + num3);
				}

				num4 += 18;
			}
		}

		public static void CheckSunflower(int i, int j, int type = 27) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1) {
				num -= 2;
			}

			num *= -1;
			num += i;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 4; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					int num3;
					for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2) {
					}

					if (!Main.tile[k, l].nactive() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
						flag = true;
				}

				if (Main.tile[k, num2 + 4] == null)
					Main.tile[k, num2 + 4] = new Tile();

				if (!Main.tile[k, num2 + 4].nactive() || (Main.tile[k, num2 + 4].type != 2 && Main.tile[k, num2 + 4].type != 109))
					flag = true;

				if (!SolidTile(k, num2 + 4))
					flag = true;
			}

			if (!flag)
				return;

			destroyObject = true;
			for (int m = num; m < num + 2; m++) {
				for (int n = num2; n < num2 + 4; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			if (TileLoader.Drop(i, j, type))
				Item.NewItem(i * 16, j * 16, 32, 32, 63);
			destroyObject = false;
		}

		public static void CheckDye(int x, int y) {
			switch (Main.tile[x, y].frameX / 34) {
				case 7:
					if (!SolidTile(x, y - 1))
						KillTile(x, y);
					break;
				case 6:
					if (!Main.tile[x, y + 1].nactive() || Main.tile[x, y + 1].type != 80)
						KillTile(x, y);
					break;
				default:
					if (!SolidTile(x, y + 1))
						KillTile(x, y);
					break;
			}
		}

		public static void PlaceDye(int x, int y, int style) {
			bool flag = false;
			if (style == 7) {
				if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type != 3 && Main.tile[x, y + 1].type != 51 && Main.tile[x, y + 1].type != 61 && Main.tile[x, y + 1].type != 73 && Main.tile[x, y + 1].type != 74 && Main.tile[x, y + 1].type != 184)
					return;

				if (SolidTile(x, y - 1) && !Main.tile[x, y + 1].active())
					flag = true;
			}
			else {
				if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type != 3 && Main.tile[x, y - 1].type != 51 && Main.tile[x, y - 1].type != 61 && Main.tile[x, y - 1].type != 73 && Main.tile[x, y - 1].type != 74 && Main.tile[x, y - 1].type != 184)
					return;

				if (style == 6) {
					if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == 80 && !Main.tile[x - 1, y + 1].active() && !Main.tile[x + 1, y + 1].active())
						flag = true;
				}
				else if (SolidTile(x, y + 1) && !Main.tile[x, y - 1].active()) {
					switch (style) {
						case 5:
							if (Main.tile[x, y].liquid == byte.MaxValue)
								flag = true;
							break;
						case 8:
						case 9:
						case 10:
						case 11:
							flag = true;
							break;
						default:
							if (Main.tile[x, y].liquid != 0)
								break;
							if (style == 3 || style == 4) {
								if (Main.tile[x, y].wall == 0)
									flag = true;
							}
							else {
								flag = true;
							}
							break;
					}
				}
			}

			if (flag) {
				Main.tile[x, y].type = 227;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].halfBrick(halfBrick: false);
				Main.tile[x, y].slope(0);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(34 * style);
			}
		}

		public static bool PlacePot(int x, int y, ushort type = 28, int style = 0) {
			bool flag = true;
			for (int i = x; i < x + 2; i++) {
				for (int j = y - 1; j < y + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					if (Main.tile[i, j].active())
						flag = false;
				}

				if (Main.tile[i, y + 1] == null)
					Main.tile[i, y + 1] = new Tile();

				if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || !Main.tileSolid[Main.tile[i, y + 1].type])
					flag = false;
			}

			if (flag) {
				int num = genRand.Next(3) * 36;
				for (int k = 0; k < 2; k++) {
					for (int l = -1; l < 1; l++) {
						int num2 = k * 18 + num;
						int num3 = (l + 1) * 18;
						Main.tile[x + k, y + l].active(active: true);
						Main.tile[x + k, y + l].frameX = (short)num2;
						Main.tile[x + k, y + l].frameY = (short)(num3 + style * 36);
						Main.tile[x + k, y + l].type = type;
						Main.tile[x + k, y + l].halfBrick(halfBrick: false);
					}
				}

				return true;
			}

			return false;
		}

		public static bool CheckCactus(int i, int j) {
			int num = j;
			int num2 = i;
			while (Main.tile[num2, num] != null && Main.tile[num2, num].active() && Main.tile[num2, num].type == 80) {
				num++;
				if (Main.tile[num2, num] == null)
					return false;

				if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80) {
					if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1] != null && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
						num2--;

					if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1] != null && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
						num2++;
				}
			}

			if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[num2, num].type)) {
				KillTile(i, j);
				return true;
			}

			if (i != num2) {
				if ((!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != 80) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != 80)) {
					KillTile(i, j);
					return true;
				}
			}
			else if (i == num2 && (!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[i, j + 1].type))) {
				KillTile(i, j);
				return true;
			}

			return false;
		}

		public static void PlantCactus(int i, int j) {
			GrowCactus(i, j);
			for (int k = 0; k < 150; k++) {
				int i2 = genRand.Next(i - 1, i + 2);
				int j2 = genRand.Next(j - 10, j + 2);
				GrowCactus(i2, j2);
			}
		}

		public static void CheckOrb(int i, int j, int type) {
			short frameX = Main.tile[i, j].frameX;
			bool flag = false;
			if (frameX >= 36)
				flag = true;

			if (destroyObject)
				return;

			int num = i;
			int num2 = j;
			num = ((Main.tile[i, j].frameX != 0 && Main.tile[i, j].frameX != 36) ? (i - 1) : i);
			num2 = ((Main.tile[i, j].frameY != 0) ? (j - 1) : j);
			for (int k = 0; k < 2; k++) {
				for (int l = 0; l < 2; l++) {
					Tile tile = Main.tile[num + k, num2 + l];
					if (tile != null && (!tile.nactive() || tile.type != type)) {
						destroyObject = true;
						break;
					}
				}

				if (destroyObject)
					break;

				if (type == 12) {
					Tile tile = Main.tile[num + k, num2 + 2];
					if (tile != null && (!tile.nactive() || !Main.tileSolid[tile.type] || tile.blockType() != 0)) {
						destroyObject = true;
						break;
					}
				}
			}

			if (!destroyObject)
				return;

			for (int m = num; m < num + 2; m++) {
				for (int n = num2; n < num2 + 2; n++) {
					if (Main.tile[m, n].type == type)
						KillTile(m, n);
				}
			}

			if (Main.netMode != 1 && !noTileActions && TileLoader.Drop(num, num2, type)) {
				switch (type) {
					case 12:
						Item.NewItem(num * 16, num2 * 16, 32, 32, 29);
						break;
					case 31:
						if (genRand.Next(2) == 0)
							spawnMeteor = true;
						if (flag) {
							int num3 = Main.rand.Next(5);
							if (!shadowOrbSmashed)
								num3 = 0;

							switch (num3) {
								case 0: {
										Item.NewItem(num * 16, num2 * 16, 32, 32, 800, 1, noBroadcast: false, -1);
										int stack = genRand.Next(100, 101);
										Item.NewItem(num * 16, num2 * 16, 32, 32, 97, stack);
										break;
									}
								case 1:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 1256, 1, noBroadcast: false, -1);
									break;
								case 2:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 802, 1, noBroadcast: false, -1);
									break;
								case 3:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 3062, 1, noBroadcast: false, -1);
									break;
								case 4:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 1290, 1, noBroadcast: false, -1);
									break;
							}
						}
						else {
							int num4 = Main.rand.Next(5);
							if (!shadowOrbSmashed)
								num4 = 0;

							switch (num4) {
								case 0: {
										Item.NewItem(num * 16, num2 * 16, 32, 32, 96, 1, noBroadcast: false, -1);
										int stack2 = genRand.Next(100, 101);
										Item.NewItem(num * 16, num2 * 16, 32, 32, 97, stack2);
										break;
									}
								case 1:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 64, 1, noBroadcast: false, -1);
									break;
								case 2:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 162, 1, noBroadcast: false, -1);
									break;
								case 3:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 115, 1, noBroadcast: false, -1);
									break;
								case 4:
									Item.NewItem(num * 16, num2 * 16, 32, 32, 111, 1, noBroadcast: false, -1);
									break;
							}
						}
						shadowOrbSmashed = true;
						shadowOrbCount++;
						if (shadowOrbCount >= 3) {
							shadowOrbCount = 0;
							float num5 = num * 16;
							float num6 = num2 * 16;
							float num7 = -1f;
							int plr = 0;
							for (int num8 = 0; num8 < 255; num8++) {
								float num9 = Math.Abs(Main.player[num8].position.X - num5) + Math.Abs(Main.player[num8].position.Y - num6);
								if (num9 < num7 || num7 == -1f) {
									plr = num8;
									num7 = num9;
								}
							}

							if (flag)
								NPC.SpawnOnPlayer(plr, 266);
							else
								NPC.SpawnOnPlayer(plr, 13);
						}
						else {
							LocalizedText localizedText = Lang.misc[10];
							if (shadowOrbCount == 2)
								localizedText = Lang.misc[11];

							if (Main.netMode == 0)
								Main.NewText(localizedText.ToString(), 50, byte.MaxValue, 130);
							else if (Main.netMode == 2)
								NetMessage.BroadcastChatMessage(NetworkText.FromKey(localizedText.Key), new Color(50, 255, 130));
						}
						AchievementsHelper.NotifyProgressionEvent(7);
						break;
				}
			}

			if (flag)
				Main.PlaySound(4, i * 16, j * 16);
			else
				Main.PlaySound(13, i * 16, j * 16);

			destroyObject = false;
		}

		public static void CheckPalmTree(int i, int j) {
			int num = -1;
			int num2 = -1;
			int type = Main.tile[i, j].type;
			int frameX = Main.tile[i, j].frameX;
			int frameY = Main.tile[i, j].frameY;
			if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
				num = Main.tile[i, j - 1].type;

			if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
				num2 = Main.tile[i, j + 1].type;

			if (num2 == 53)
				num2 = 53;

			if (num2 == 234)
				num2 = 53;

			if (num2 == 116)
				num2 = 53;

			if (num2 == 112)
				num2 = 53;

			if (TileLoader.CanGrowModPalmTree(num2))
				num2 = 53;

			if (num2 != 53 && num2 != type)
				KillTile(i, j);

			if ((Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 220) && num2 != 53)
				KillTile(i, j);

			if (num != type && Main.tile[i, j].frameX <= 44)
				Main.tile[i, j].frameX = (short)(genRand.Next(7, 10) * 22);
			else if (num != type && Main.tile[i, j].frameX == 66)
				Main.tile[i, j].frameX = 220;

			if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0) {
				TileFrame(i - 1, j);
				TileFrame(i + 1, j);
				TileFrame(i, j - 1);
				TileFrame(i, j + 1);
			}
		}

		public static void CheckTree(int i, int j) {
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int type = Main.tile[i, j].type;
			int frameX = Main.tile[i, j].frameX;
			int frameY = Main.tile[i, j].frameY;
			if (Main.tile[i - 1, j] != null && Main.tile[i - 1, j].active())
				num2 = Main.tile[i - 1, j].type;

			if (Main.tile[i + 1, j] != null && Main.tile[i + 1, j].active())
				num3 = Main.tile[i + 1, j].type;

			if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
				num = Main.tile[i, j - 1].type;

			if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
				num4 = Main.tile[i, j + 1].type;

			if (Main.tile[i - 1, j - 1] != null && Main.tile[i - 1, j - 1].active())
				_ = Main.tile[i - 1, j - 1].type;

			if (Main.tile[i + 1, j - 1] != null && Main.tile[i + 1, j - 1].active())
				_ = Main.tile[i + 1, j - 1].type;

			if (Main.tile[i - 1, j + 1] != null && Main.tile[i - 1, j + 1].active())
				_ = Main.tile[i - 1, j + 1].type;

			if (Main.tile[i + 1, j + 1] != null && Main.tile[i + 1, j + 1].active())
				_ = Main.tile[i + 1, j + 1].type;

			if (num4 == 23)
				num4 = 2;

			if (num4 == 60)
				num4 = 2;

			if (num4 == 70)
				num4 = 2;

			if (num4 == 109)
				num4 = 2;

			if (num4 == 147)
				num4 = 2;

			if (num4 == 199)
				num4 = 2;

			if (TileLoader.CanGrowModTree(num4))
				num4 = 2;

			if (num4 != 2 && num4 != type && ((Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 22 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 44 && Main.tile[i, j].frameY <= 130)))
				KillTile(i, j);

			if (Main.tile[i, j].frameX >= 22 && Main.tile[i, j].frameX <= 44 && Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176) {
				if (num4 != 2)
					KillTile(i, j);
				else if ((Main.tile[i, j].frameX != 22 || num2 != type) && (Main.tile[i, j].frameX != 44 || num3 != type))
					KillTile(i, j);
			}
			else if ((Main.tile[i, j].frameX == 88 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 44) || (Main.tile[i, j].frameX == 66 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 110 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 110) || (Main.tile[i, j].frameX == 132 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 176)) {
				if (num2 == type && num3 == type) {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 66;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 88;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 110;
					}
				}
				else if (num2 == type) {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 0;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 22;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 44;
					}
				}
				else if (num3 == type) {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 66;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 88;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 110;
					}
				}
				else {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
				}
			}

			if (Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176 && (Main.tile[i, j].frameX == 0 || Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 88)) {
				if (num4 != 2)
					KillTile(i, j);

				if (num2 != type && num3 != type) {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
				}
				else if (num2 != type) {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 132;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 154;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 176;
					}
				}
				else if (num3 != type) {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 132;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 154;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 176;
					}
				}
				else {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 132;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 154;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 176;
					}
				}
			}

			if ((Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 0 || Main.tile[i, j].frameY == 22 || Main.tile[i, j].frameY == 44)) || (Main.tile[i, j].frameX == 44 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242))) {
				if (num3 != type)
					KillTile(i, j);
			}
			else if ((Main.tile[i, j].frameX == 88 && (Main.tile[i, j].frameY == 66 || Main.tile[i, j].frameY == 88 || Main.tile[i, j].frameY == 110)) || (Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242))) {
				if (num2 != type)
					KillTile(i, j);
			}
			else if (num4 == -1 || num4 == 23) {
				KillTile(i, j);
			}
			else if (num != type && Main.tile[i, j].frameY < 198 && ((Main.tile[i, j].frameX != 22 && Main.tile[i, j].frameX != 44) || Main.tile[i, j].frameY < 132)) {
				if (num2 == type || num3 == type) {
					if (num4 == type) {
						if (num2 == type && num3 == type) {
							if (Main.tile[i, j].frameNumber() == 0) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 132;
							}

							if (Main.tile[i, j].frameNumber() == 1) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 154;
							}

							if (Main.tile[i, j].frameNumber() == 2) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 176;
							}
						}
						else if (num2 == type) {
							if (Main.tile[i, j].frameNumber() == 0) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 0;
							}

							if (Main.tile[i, j].frameNumber() == 1) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 22;
							}

							if (Main.tile[i, j].frameNumber() == 2) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 44;
							}
						}
						else if (num3 == type) {
							if (Main.tile[i, j].frameNumber() == 0) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 66;
							}

							if (Main.tile[i, j].frameNumber() == 1) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 88;
							}

							if (Main.tile[i, j].frameNumber() == 2) {
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 110;
							}
						}
					}
					else if (num2 == type && num3 == type) {
						if (Main.tile[i, j].frameNumber() == 0) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 132;
						}

						if (Main.tile[i, j].frameNumber() == 1) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 154;
						}

						if (Main.tile[i, j].frameNumber() == 2) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 176;
						}
					}
					else if (num2 == type) {
						if (Main.tile[i, j].frameNumber() == 0) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 0;
						}

						if (Main.tile[i, j].frameNumber() == 1) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 22;
						}

						if (Main.tile[i, j].frameNumber() == 2) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 44;
						}
					}
					else if (num3 == type) {
						if (Main.tile[i, j].frameNumber() == 0) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 66;
						}

						if (Main.tile[i, j].frameNumber() == 1) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 88;
						}

						if (Main.tile[i, j].frameNumber() == 2) {
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 110;
						}
					}
				}
				else {
					if (Main.tile[i, j].frameNumber() == 0) {
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 0;
					}

					if (Main.tile[i, j].frameNumber() == 1) {
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 22;
					}

					if (Main.tile[i, j].frameNumber() == 2) {
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 44;
					}
				}
			}

			if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0) {
				TileFrame(i - 1, j);
				TileFrame(i + 1, j);
				TileFrame(i, j - 1);
				TileFrame(i, j + 1);
			}
		}

		public static void Convert(int i, int j, int conversionType, int size = 4) {
			for (int k = i - size; k <= i + size; k++) {
				for (int l = j - size; l <= j + size; l++) {
					if (!InWorld(k, l, 1) || Math.Abs(k - i) + Math.Abs(l - j) >= 6)
						continue;

					int type = Main.tile[k, l].type;
					int wall = Main.tile[k, l].wall;
					switch (conversionType) {
						case 4:
							if (true) {//if (type <= 470 && wall <= 231) {
								if (WallID.Sets.Conversion.Grass[wall] && wall != 81) {
									Main.tile[k, l].wall = 81;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (WallID.Sets.Conversion.Stone[wall] && wall != 83) {
									Main.tile[k, l].wall = 83;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218) {
									Main.tile[k, l].wall = 218;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221) {
									Main.tile[k, l].wall = 221;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}

								if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203) {
									Main.tile[k, l].type = 203;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Grass[type] && type != 199) {
									Main.tile[k, l].type = 199;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Ice[type] && type != 200) {
									Main.tile[k, l].type = 200;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Sand[type] && type != 234) {
									Main.tile[k, l].type = 234;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.HardenedSand[type] && type != 399) {
									Main.tile[k, l].type = 399;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Sandstone[type] && type != 401) {
									Main.tile[k, l].type = 401;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Thorn[type] && type != 352) {
									Main.tile[k, l].type = 352;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}

								if (type == 59 && (Main.tile[k - 1, l].type == 199 || Main.tile[k + 1, l].type == 199 || Main.tile[k, l - 1].type == 199 || Main.tile[k, l + 1].type == 199)) {
									Main.tile[k, l].type = 0;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
							}
							continue;
						case 2:
							if (WallID.Sets.Conversion.Grass[wall] && wall != 70) {
								Main.tile[k, l].wall = 70;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.Stone[wall] && wall != 28) {
								Main.tile[k, l].wall = 28;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219) {
								Main.tile[k, l].wall = 219;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222) {
								Main.tile[k, l].wall = 222;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117) {
								Main.tile[k, l].type = 117;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Grass[type] && type != 109) {
								Main.tile[k, l].type = 109;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Ice[type] && type != 164) {
								Main.tile[k, l].type = 164;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Sand[type] && type != 116) {
								Main.tile[k, l].type = 116;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402) {
								Main.tile[k, l].type = 402;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Sandstone[type] && type != 403) {
								Main.tile[k, l].type = 403;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Thorn[type]) {
								KillTile(k, l);
								if (Main.netMode == 1)
									NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
							if (type == 59 && (Main.tile[k - 1, l].type == 109 || Main.tile[k + 1, l].type == 109 || Main.tile[k, l - 1].type == 109 || Main.tile[k, l + 1].type == 109)) {
								Main.tile[k, l].type = 0;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							continue;
						case 1:
							if (true) {//if (type <= 470 && wall <= 231) {
								if (WallID.Sets.Conversion.Grass[wall] && wall != 69) {
									Main.tile[k, l].wall = 69;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (WallID.Sets.Conversion.Stone[wall] && wall != 3) {
									Main.tile[k, l].wall = 3;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217) {
									Main.tile[k, l].wall = 217;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220) {
									Main.tile[k, l].wall = 220;
									SquareWallFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}

								if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25) {
									Main.tile[k, l].type = 25;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Grass[type] && type != 23) {
									Main.tile[k, l].type = 23;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Ice[type] && type != 163) {
									Main.tile[k, l].type = 163;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Sand[type] && type != 112) {
									Main.tile[k, l].type = 112;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.HardenedSand[type] && type != 398) {
									Main.tile[k, l].type = 398;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Sandstone[type] && type != 400) {
									Main.tile[k, l].type = 400;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
								else if (TileID.Sets.Conversion.Thorn[type] && type != 32) {
									Main.tile[k, l].type = 32;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}

								if (type == 59 && (Main.tile[k - 1, l].type == 23 || Main.tile[k + 1, l].type == 23 || Main.tile[k, l - 1].type == 23 || Main.tile[k, l + 1].type == 23)) {
									Main.tile[k, l].type = 0;
									SquareTileFrame(k, l);
									NetMessage.SendTileSquare(-1, k, l, 1);
								}
							}
							continue;
						case 3:
							if (Main.tile[k, l].wall == 64 || Main.tile[k, l].wall == 15) {
								Main.tile[k, l].wall = 80;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 3);
							}
							if (Main.tile[k, l].type == 60) {
								Main.tile[k, l].type = 70;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 3);
							}
							else if (TileID.Sets.Conversion.Thorn[type]) {
								KillTile(k, l);
								if (Main.netMode == 1)
									NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
							continue;
					}

					if (Main.tile[k, l].wall == 69 || Main.tile[k, l].wall == 70 || Main.tile[k, l].wall == 81) {
						if ((double)l < Main.worldSurface) {
							if (genRand.Next(10) == 0)
								Main.tile[k, l].wall = 65;
							else
								Main.tile[k, l].wall = 63;
						}
						else {
							Main.tile[k, l].wall = 64;
						}

						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].wall == 3 || Main.tile[k, l].wall == 28 || Main.tile[k, l].wall == 83) {
						Main.tile[k, l].wall = 1;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].wall == 80) {
						if ((double)l < Main.worldSurface + 4.0 + (double)genRand.Next(3) || (double)l > ((double)Main.maxTilesY + Main.rockLayer) / 2.0 - 3.0 + (double)genRand.Next(3)) {
							Main.tile[k, l].wall = 15;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 3);
						}
						else {
							Main.tile[k, l].wall = 64;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 3);
						}
					}
					else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216) {
						Main.tile[k, l].wall = 216;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187) {
						Main.tile[k, l].wall = 187;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}

					if (Main.tile[k, l].type == 23 || Main.tile[k, l].type == 109 || Main.tile[k, l].type == 199) {
						Main.tile[k, l].type = 2;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 117 || Main.tile[k, l].type == 25 || Main.tile[k, l].type == 203) {
						Main.tile[k, l].type = 1;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 112 || Main.tile[k, l].type == 116 || Main.tile[k, l].type == 234) {
						Main.tile[k, l].type = 53;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 398 || Main.tile[k, l].type == 402 || Main.tile[k, l].type == 399) {
						Main.tile[k, l].type = 397;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 400 || Main.tile[k, l].type == 403 || Main.tile[k, l].type == 401) {
						Main.tile[k, l].type = 396;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 164 || Main.tile[k, l].type == 163 || Main.tile[k, l].type == 200) {
						Main.tile[k, l].type = 161;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 70) {
						Main.tile[k, l].type = 60;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 32 || Main.tile[k, l].type == 352) {
						KillTile(k, l);
						if (Main.netMode == 1)
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
					}
				}
			}
		}

		public static void CactusFrame(int i, int j) {
			try {
				int num = j;
				int num2 = i;
				if (CheckCactus(i, j))
					return;

				while (Main.tile[num2, num].active() && Main.tile[num2, num].type == 80) {
					num++;
					if (Main.tile[num2, num] == null)
						return;

					if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80) {
						if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
							num2--;

						if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
							num2++;
					}
				}

				num--;
				int num3 = i - num2;
				num2 = i;
				num = j;
				if (Main.tile[i - 2, j] == null)
					return;

				int type = Main.tile[i - 2, j].type;
				if (Main.tile[i - 1, j] == null)
					return;

				int num4 = Main.tile[i - 1, j].type;
				if (Main.tile[i + 1, j] == null)
					return;

				int num5 = Main.tile[i + 1, j].type;
				int num6 = Main.tile[i, j - 1].type;
				if (num6 == 227)
					num6 = 80;

				int num7 = Main.tile[i, j + 1].type;
				int num8 = Main.tile[i - 1, j + 1].type;
				int num9 = Main.tile[i + 1, j + 1].type;
				if (!Main.tile[i - 1, j].active())
					num4 = -1;

				if (!Main.tile[i + 1, j].active())
					num5 = -1;

				if (!Main.tile[i, j - 1].active())
					num6 = -1;

				if (!Main.tile[i, j + 1].active())
					num7 = -1;

				if (!Main.tile[i - 1, j + 1].active())
					num8 = -1;

				if (!Main.tile[i + 1, j + 1].active())
					num9 = -1;

				short num10 = Main.tile[i, j].frameX;
				short num11 = Main.tile[i, j].frameY;
				switch (num3) {
					case 0:
						if (num6 != 80) {
							if (num4 == 80 && num5 == 80 && num8 != 80 && num9 != 80 && type != 80) {
								num10 = 90;
								num11 = 0;
							}
							else if (num4 == 80 && num8 != 80 && type != 80) {
								num10 = 72;
								num11 = 0;
							}
							else if (num5 == 80 && num9 != 80) {
								num10 = 18;
								num11 = 0;
							}
							else {
								num10 = 0;
								num11 = 0;
							}
						}
						else if (num4 == 80 && num5 == 80 && num8 != 80 && num9 != 80 && type != 80) {
							num10 = 90;
							num11 = 36;
						}
						else if (num4 == 80 && num8 != 80 && type != 80) {
							num10 = 72;
							num11 = 36;
						}
						else if (num5 == 80 && num9 != 80) {
							num10 = 18;
							num11 = 36;
						}
						else if (num7 >= 0 && Main.tileSolid[num7]) {
							num10 = 0;
							num11 = 36;
						}
						else {
							num10 = 0;
							num11 = 18;
						}
						break;
					case -1:
						if (num5 == 80) {
							if (num6 != 80 && num7 != 80) {
								num10 = 108;
								num11 = 36;
							}
							else if (num7 != 80) {
								num10 = 54;
								num11 = 36;
							}
							else if (num6 != 80) {
								num10 = 54;
								num11 = 0;
							}
							else {
								num10 = 54;
								num11 = 18;
							}
						}
						else if (num6 != 80) {
							num10 = 54;
							num11 = 0;
						}
						else {
							num10 = 54;
							num11 = 18;
						}
						break;
					case 1:
						if (num4 == 80) {
							if (num6 != 80 && num7 != 80) {
								num10 = 108;
								num11 = 18;
							}
							else if (num7 != 80) {
								num10 = 36;
								num11 = 36;
							}
							else if (num6 != 80) {
								num10 = 36;
								num11 = 0;
							}
							else {
								num10 = 36;
								num11 = 18;
							}
						}
						else if (num6 != 80) {
							num10 = 36;
							num11 = 0;
						}
						else {
							num10 = 36;
							num11 = 18;
						}
						break;
				}

				if (num10 != Main.tile[i, j].frameX || num11 != Main.tile[i, j].frameY) {
					Main.tile[i, j].frameX = num10;
					Main.tile[i, j].frameY = num11;
					DiamondTileFrame(i, j);
				}
			}
			catch {
				Main.tile[i, j].frameX = 0;
				Main.tile[i, j].frameY = 0;
			}
		}

		public static void GrowCactus(int i, int j) {
			int num = j;
			int num2 = i;
			if (!Main.tile[i, j].nactive() || Main.tile[i, j].halfBrick() || Main.tile[i, j].slope() != 0 || Main.tile[i, j - 1].liquid > 0 || (Main.tile[i, j].type != 53 && Main.tile[i, j].type != 80 && Main.tile[i, j].type != 234 && Main.tile[i, j].type != 112 && Main.tile[i, j].type != 116))
				return;

			if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234 || TileLoader.CanGrowModCactus(Main.tile[i, j].type)) {
				if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
					return;

				int num3 = 0;
				int num4 = 0;
				for (int k = i - 6; k <= i + 6; k++) {
					for (int l = j - 3; l <= j + 1; l++) {
						try {
							if (!Main.tile[k, l].active())
								continue;

							if (Main.tile[k, l].type == 80) {
								num3++;
								if (num3 >= 4)
									return;
							}

							if (Main.tile[k, l].type == 53 || Main.tile[k, l].type == 112 || Main.tile[k, l].type == 116 || Main.tile[k, l].type == 234 || TileLoader.CanGrowModCactus(Main.tile[k, l].type))
								num4++;
						}
						catch {
						}
					}
				}

				if (num4 > 10) {
					Main.tile[i, j - 1].active(active: true);
					Main.tile[i, j - 1].type = 80;
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, i, j - 1, 1);

					SquareTileFrame(num2, num - 1);
				}
			}
			else {
				if (Main.tile[i, j].type != 80)
					return;

				while (Main.tile[num2, num].active() && Main.tile[num2, num].type == 80) {
					num++;
					if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80) {
						if (Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
							num2--;

						if (Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
							num2++;
					}
				}

				num--;
				int num5 = num - j;
				int num6 = i - num2;
				num2 = i - num6;
				num = j;
				int num7 = 11 - num5;
				int num8 = 0;
				for (int m = num2 - 2; m <= num2 + 2; m++) {
					for (int n = num - num7; n <= num + num5; n++) {
						if (Main.tile[m, n].active() && Main.tile[m, n].type == 80)
							num8++;
					}
				}

				if (num8 >= genRand.Next(11, 13))
					return;

				num2 = i;
				num = j;
				if (num6 == 0) {
					if (num5 == 0) {
						if (!Main.tile[num2, num - 1].active()) {
							Main.tile[num2, num - 1].active(active: true);
							Main.tile[num2, num - 1].type = 80;
							SquareTileFrame(num2, num - 1);
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num2, num - 1, 1);
						}

						return;
					}

					bool flag = false;
					bool flag2 = false;
					if (Main.tile[num2, num - 1].active() && Main.tile[num2, num - 1].type == 80) {
						if (!Main.tile[num2 - 1, num].active() && !Main.tile[num2 - 2, num + 1].active() && !Main.tile[num2 - 1, num - 1].active() && !Main.tile[num2 - 1, num + 1].active() && !Main.tile[num2 - 2, num].active())
							flag = true;

						if (!Main.tile[num2 + 1, num].active() && !Main.tile[num2 + 2, num + 1].active() && !Main.tile[num2 + 1, num - 1].active() && !Main.tile[num2 + 1, num + 1].active() && !Main.tile[num2 + 2, num].active())
							flag2 = true;
					}

					int num9 = genRand.Next(3);
					if (num9 == 0 && flag) {
						Main.tile[num2 - 1, num].active(active: true);
						Main.tile[num2 - 1, num].type = 80;
						SquareTileFrame(num2 - 1, num);
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num2 - 1, num, 1);
					}
					else if (num9 == 1 && flag2) {
						Main.tile[num2 + 1, num].active(active: true);
						Main.tile[num2 + 1, num].type = 80;
						SquareTileFrame(num2 + 1, num);
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num2 + 1, num, 1);
					}
					else {
						if (num5 >= genRand.Next(2, 8))
							return;

						if (Main.tile[num2 - 1, num - 1].active()) {
							_ = Main.tile[num2 - 1, num - 1].type;
							_ = 80;
						}

						if ((!Main.tile[num2 + 1, num - 1].active() || Main.tile[num2 + 1, num - 1].type != 80) && !Main.tile[num2, num - 1].active()) {
							Main.tile[num2, num - 1].active(active: true);
							Main.tile[num2, num - 1].type = 80;
							SquareTileFrame(num2, num - 1);
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num2, num - 1, 1);
						}
					}
				}
				else if (!Main.tile[num2, num - 1].active() && !Main.tile[num2, num - 2].active() && !Main.tile[num2 + num6, num - 1].active() && Main.tile[num2 - num6, num - 1].active() && Main.tile[num2 - num6, num - 1].type == 80) {
					Main.tile[num2, num - 1].active(active: true);
					Main.tile[num2, num - 1].type = 80;
					SquareTileFrame(num2, num - 1);
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, num2, num - 1, 1);
				}
			}
		}

		public static void CheckPot(int i, int j, int type = 28) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = 0;
			int num2 = j;
			for (num += Main.tile[i, j].frameX / 18; num > 1; num -= 2) {
			}

			num *= -1;
			num += i;
			int num3 = Main.tile[i, j].frameY / 18;
			int num4 = 0;
			while (num3 > 1) {
				num3 -= 2;
				num4++;
			}

			num2 -= num3;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 2; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					int num5;
					for (num5 = Main.tile[k, l].frameX / 18; num5 > 1; num5 -= 2) {
					}

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num5 != k - num || Main.tile[k, l].frameY != (l - num2) * 18 + num4 * 36)
						flag = true;
				}

				if (Main.tile[k, num2 + 2] == null)
					Main.tile[k, num2 + 2] = new Tile();

				if (!SolidTile2(k, num2 + 2))
					flag = true;
			}

			if (!flag)
				return;

			// size ???
			if (!TileLoader.Drop(num, num2, type))
				goto skipDrop;

			destroyObject = true;
			if (num4 >= 7 && num4 <= 9)
				Main.PlaySound(6, i * 16, j * 16);
			else if (num4 >= 16 && num4 <= 24)
				Main.PlaySound(4, i * 16, j * 16);
			else
				Main.PlaySound(13, i * 16, j * 16);

			for (int m = num; m < num + 2; m++) {
				for (int n = num2; n < num2 + 2; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						KillTile(m, n);
				}
			}

			float num6 = 1f;
			switch (num4) {
				case 0:
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 51);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 52);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 53);
					break;
				case 1:
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 166);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 167);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 168);
					break;
				case 2:
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 169);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 170);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 171);
					break;
				case 3:
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 172);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 173);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 174);
					break;
				case 4:
				case 5:
				case 6:
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 197);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 198);
					num6 = 1.25f;
					break;
				default:
					if (num4 >= 7 && num4 <= 9) {
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 199);
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 200);
						num6 = 1.75f;
					}
					else if (num4 >= 10 && num4 <= 12) {
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 201);
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 202);
						num6 = 1.9f;
					}
					else if (num4 >= 13 && num4 <= 15) {
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 203);
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 204);
						num6 = 2.1f;
					}
					else if (num4 >= 16 && num4 <= 18) {
						num6 = 1.6f;
					}
					else if (num4 >= 19 && num4 <= 21) {
						num6 = 3.5f;
					}
					else if (num4 >= 22 && num4 <= 24) {
						num6 = 1.6f;
					}
					else if (num4 >= 25 && num4 <= 27) {
						num6 = 10f;
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
					}
					else if (num4 >= 28 && num4 <= 30) {
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
						if (Main.hardMode)
							num6 = 4f;
					}
					else if (num4 >= 31 && num4 <= 33) {
						int num7 = genRand.Next(2, 5);
						for (int num8 = 0; num8 < num7; num8++) {
							Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 698 + genRand.Next(6));
						}

						num6 = 2f;
					}
					break;
			}

			num6 = (num6 * 2f + 1f) / 3f;
			int maxValue = (int)(250f / ((num6 + 1f) / 2f));
			if (!gen) {
				if (Main.rand.Next(maxValue) == 0) {
					if (Main.netMode != 1)
						Projectile.NewProjectile(i * 16 + 16, j * 16 + 16, 0f, -12f, 518, 0, 0f, Main.myPlayer);
				}
				else if (genRand.Next(40) == 0 && Main.wallDungeon[Main.tile[i, j].wall] && (double)j > Main.worldSurface) {
					Item.NewItem(i * 16, j * 16, 16, 16, 327);
				}
				else if (genRand.Next(45) == 0 || (Main.rand.Next(45) == 0 && Main.expertMode)) {
					if ((double)j < Main.worldSurface) {
						int num9 = genRand.Next(10);
						if (num9 == 0)
							Item.NewItem(i * 16, j * 16, 16, 16, 292);

						if (num9 == 1)
							Item.NewItem(i * 16, j * 16, 16, 16, 298);

						if (num9 == 2)
							Item.NewItem(i * 16, j * 16, 16, 16, 299);

						if (num9 == 3)
							Item.NewItem(i * 16, j * 16, 16, 16, 290);

						if (num9 == 4)
							Item.NewItem(i * 16, j * 16, 16, 16, 2322);

						if (num9 == 5)
							Item.NewItem(i * 16, j * 16, 16, 16, 2324);

						if (num9 == 6)
							Item.NewItem(i * 16, j * 16, 16, 16, 2325);

						if (num9 >= 7)
							Item.NewItem(i * 16, j * 16, 16, 16, 2350);
					}
					else if ((double)j < Main.rockLayer) {
						int num10 = genRand.Next(11);
						if (num10 == 0)
							Item.NewItem(i * 16, j * 16, 16, 16, 289);

						if (num10 == 1)
							Item.NewItem(i * 16, j * 16, 16, 16, 298);

						if (num10 == 2)
							Item.NewItem(i * 16, j * 16, 16, 16, 299);

						if (num10 == 3)
							Item.NewItem(i * 16, j * 16, 16, 16, 290);

						if (num10 == 4)
							Item.NewItem(i * 16, j * 16, 16, 16, 303);

						if (num10 == 5)
							Item.NewItem(i * 16, j * 16, 16, 16, 291);

						if (num10 == 6)
							Item.NewItem(i * 16, j * 16, 16, 16, 304);

						if (num10 == 7)
							Item.NewItem(i * 16, j * 16, 16, 16, 2322);

						if (num10 == 8)
							Item.NewItem(i * 16, j * 16, 16, 16, 2329);

						if (num10 >= 9)
							Item.NewItem(i * 16, j * 16, 16, 16, 2350);
					}
					else if (j < Main.maxTilesY - 200) {
						int num11 = genRand.Next(15);
						if (num11 == 0)
							Item.NewItem(i * 16, j * 16, 16, 16, 296);

						if (num11 == 1)
							Item.NewItem(i * 16, j * 16, 16, 16, 295);

						if (num11 == 2)
							Item.NewItem(i * 16, j * 16, 16, 16, 299);

						if (num11 == 3)
							Item.NewItem(i * 16, j * 16, 16, 16, 302);

						if (num11 == 4)
							Item.NewItem(i * 16, j * 16, 16, 16, 303);

						if (num11 == 5)
							Item.NewItem(i * 16, j * 16, 16, 16, 305);

						if (num11 == 6)
							Item.NewItem(i * 16, j * 16, 16, 16, 301);

						if (num11 == 7)
							Item.NewItem(i * 16, j * 16, 16, 16, 302);

						if (num11 == 8)
							Item.NewItem(i * 16, j * 16, 16, 16, 297);

						if (num11 == 9)
							Item.NewItem(i * 16, j * 16, 16, 16, 304);

						if (num11 == 10)
							Item.NewItem(i * 16, j * 16, 16, 16, 2322);

						if (num11 == 11)
							Item.NewItem(i * 16, j * 16, 16, 16, 2323);

						if (num11 == 12)
							Item.NewItem(i * 16, j * 16, 16, 16, 2327);

						if (num11 == 13)
							Item.NewItem(i * 16, j * 16, 16, 16, 2329);

						if (num11 == 14)
							Item.NewItem(i * 16, j * 16, 16, 16, 2350);
					}
					else {
						int num12 = genRand.Next(14);
						if (num12 == 0)
							Item.NewItem(i * 16, j * 16, 16, 16, 296);

						if (num12 == 1)
							Item.NewItem(i * 16, j * 16, 16, 16, 295);

						if (num12 == 2)
							Item.NewItem(i * 16, j * 16, 16, 16, 293);

						if (num12 == 3)
							Item.NewItem(i * 16, j * 16, 16, 16, 288);

						if (num12 == 4)
							Item.NewItem(i * 16, j * 16, 16, 16, 294);

						if (num12 == 5)
							Item.NewItem(i * 16, j * 16, 16, 16, 297);

						if (num12 == 6)
							Item.NewItem(i * 16, j * 16, 16, 16, 304);

						if (num12 == 7)
							Item.NewItem(i * 16, j * 16, 16, 16, 305);

						if (num12 == 8)
							Item.NewItem(i * 16, j * 16, 16, 16, 301);

						if (num12 == 9)
							Item.NewItem(i * 16, j * 16, 16, 16, 302);

						if (num12 == 10)
							Item.NewItem(i * 16, j * 16, 16, 16, 288);

						if (num12 == 11)
							Item.NewItem(i * 16, j * 16, 16, 16, 300);

						if (num12 == 12)
							Item.NewItem(i * 16, j * 16, 16, 16, 2323);

						if (num12 == 13)
							Item.NewItem(i * 16, j * 16, 16, 16, 2326);
					}
				}
				else if (Main.netMode == 2 && Main.rand.Next(30) == 0) {
					Item.NewItem(i * 16, j * 16, 16, 16, 2997);
				}
				else {
					int num13 = Main.rand.Next(8);
					if (Main.expertMode)
						num13--;

					if (num13 == 0 && Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)].statLife < Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)].statLifeMax2) {
						Item.NewItem(i * 16, j * 16, 16, 16, 58);
						if (Main.rand.Next(2) == 0)
							Item.NewItem(i * 16, j * 16, 16, 16, 58);

						if (Main.expertMode) {
							if (Main.rand.Next(2) == 0)
								Item.NewItem(i * 16, j * 16, 16, 16, 58);

							if (Main.rand.Next(2) == 0)
								Item.NewItem(i * 16, j * 16, 16, 16, 58);
						}
					}
					else if (num13 == 1 && Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)].statMana < Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)].statManaMax2) {
						Item.NewItem(i * 16, j * 16, 16, 16, 184);
					}
					else if (num13 == 2) {
						int num14 = Main.rand.Next(2, 6);
						if (Main.expertMode)
							num14 += Main.rand.Next(1, 7);

						if (Main.tile[i, j].liquid > 0)
							Item.NewItem(i * 16, j * 16, 16, 16, 282, num14);
						else
							Item.NewItem(i * 16, j * 16, 16, 16, 8, num14);
					}
					else if (num13 == 3) {
						int stack = Main.rand.Next(10, 21);
						int type2 = 40;
						if ((double)j < Main.rockLayer && genRand.Next(2) == 0)
							type2 = ((!Main.hardMode) ? 42 : 168);

						if (j > Main.maxTilesY - 200)
							type2 = 265;
						else if (Main.hardMode)
							type2 = ((Main.rand.Next(2) != 0) ? 47 : 278);

						Item.NewItem(i * 16, j * 16, 16, 16, type2, stack);
					}
					else if (num13 == 4) {
						int type3 = 28;
						if (j > Main.maxTilesY - 200 || Main.hardMode)
							type3 = 188;

						int num15 = 1;
						if (Main.expertMode && Main.rand.Next(3) != 0)
							num15++;

						Item.NewItem(i * 16, j * 16, 16, 16, type3, num15);
					}
					else if (num13 == 5 && (double)j > Main.rockLayer) {
						int num16 = Main.rand.Next(4) + 1;
						if (Main.expertMode)
							num16 += Main.rand.Next(4);

						Item.NewItem(i * 16, j * 16, 16, 16, 166, num16);
					}
					else if ((num13 == 5 || num13 == 6) && j < Main.maxTilesY - 200 && !Main.hardMode) {
						int stack2 = Main.rand.Next(20, 41);
						Item.NewItem(i * 16, j * 16, 16, 16, 965, stack2);
					}
					else {
						float num17 = 200 + genRand.Next(-100, 101);
						if ((double)j < Main.worldSurface)
							num17 *= 0.5f;
						else if ((double)j < Main.rockLayer)
							num17 *= 0.75f;
						else if (j > Main.maxTilesY - 250)
							num17 *= 1.25f;

						num17 *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
						if (Main.rand.Next(4) == 0)
							num17 *= 1f + (float)Main.rand.Next(5, 11) * 0.01f;

						if (Main.rand.Next(8) == 0)
							num17 *= 1f + (float)Main.rand.Next(10, 21) * 0.01f;

						if (Main.rand.Next(12) == 0)
							num17 *= 1f + (float)Main.rand.Next(20, 41) * 0.01f;

						if (Main.rand.Next(16) == 0)
							num17 *= 1f + (float)Main.rand.Next(40, 81) * 0.01f;

						if (Main.rand.Next(20) == 0)
							num17 *= 1f + (float)Main.rand.Next(50, 101) * 0.01f;

						if (Main.expertMode)
							num17 *= 2.5f;

						if (Main.expertMode && Main.rand.Next(2) == 0)
							num17 *= 1.25f;

						if (Main.expertMode && Main.rand.Next(3) == 0)
							num17 *= 1.5f;

						if (Main.expertMode && Main.rand.Next(4) == 0)
							num17 *= 1.75f;

						num17 *= num6;
						if (NPC.downedBoss1)
							num17 *= 1.1f;

						if (NPC.downedBoss2)
							num17 *= 1.1f;

						if (NPC.downedBoss3)
							num17 *= 1.1f;

						if (NPC.downedMechBoss1)
							num17 *= 1.1f;

						if (NPC.downedMechBoss2)
							num17 *= 1.1f;

						if (NPC.downedMechBoss3)
							num17 *= 1.1f;

						if (NPC.downedPlantBoss)
							num17 *= 1.1f;

						if (NPC.downedQueenBee)
							num17 *= 1.1f;

						if (NPC.downedGolemBoss)
							num17 *= 1.1f;

						if (NPC.downedPirates)
							num17 *= 1.1f;

						if (NPC.downedGoblins)
							num17 *= 1.1f;

						if (NPC.downedFrost)
							num17 *= 1.1f;

						while ((int)num17 > 0) {
							if (num17 > 1000000f) {
								int num18 = (int)(num17 / 1000000f);
								if (num18 > 50 && Main.rand.Next(2) == 0)
									num18 /= Main.rand.Next(3) + 1;

								if (Main.rand.Next(2) == 0)
									num18 /= Main.rand.Next(3) + 1;

								num17 -= (float)(1000000 * num18);
								Item.NewItem(i * 16, j * 16, 16, 16, 74, num18);
								continue;
							}

							if (num17 > 10000f) {
								int num19 = (int)(num17 / 10000f);
								if (num19 > 50 && Main.rand.Next(2) == 0)
									num19 /= Main.rand.Next(3) + 1;

								if (Main.rand.Next(2) == 0)
									num19 /= Main.rand.Next(3) + 1;

								num17 -= (float)(10000 * num19);
								Item.NewItem(i * 16, j * 16, 16, 16, 73, num19);
								continue;
							}

							if (num17 > 100f) {
								int num20 = (int)(num17 / 100f);
								if (num20 > 50 && Main.rand.Next(2) == 0)
									num20 /= Main.rand.Next(3) + 1;

								if (Main.rand.Next(2) == 0)
									num20 /= Main.rand.Next(3) + 1;

								num17 -= (float)(100 * num20);
								Item.NewItem(i * 16, j * 16, 16, 16, 72, num20);
								continue;
							}

							int num21 = (int)num17;
							if (num21 > 50 && Main.rand.Next(2) == 0)
								num21 /= Main.rand.Next(3) + 1;

							if (Main.rand.Next(2) == 0)
								num21 /= Main.rand.Next(4) + 1;

							if (num21 < 1)
								num21 = 1;

							num17 -= (float)num21;
							Item.NewItem(i * 16, j * 16, 16, 16, 71, num21);
						}
					}
				}
			}

			skipDrop:
			destroyObject = false;
		}

		public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0) {
			int num = -1;
			if (TileObject.CanPlace(x, y, type, style, 1, out TileObject objectData)) {
				bool flag = true;
				if (notNearOtherChests && Chest.NearOtherChests(x - 1, y - 1))
					flag = false;

				if (flag) {
					TileObject.Place(objectData);
					num = Chest.CreateChest(objectData.xCoord, objectData.yCoord);
				}
			}
			else {
				num = -1;
			}

			if (num != -1 && Main.netMode == 1 && type == 21)
				NetMessage.SendData(34, -1, -1, null, 0, x, y, style);

			if (num != -1 && Main.netMode == 1 && type == 467)
				NetMessage.SendData(34, -1, -1, null, 4, x, y, style);

			if (num != 1 && Main.netMode == 1 && type >= TileID.Count && TileID.Sets.BasicChest[type])
				NetMessage.SendData(34, -1, -1, null, 100, x, y, style, 0, type, 0);

			return num;
		}

		public static void PlaceChestDirect(int x, int y, ushort type, int style, int id) {
			Chest.CreateChest(x, y - 1, id);
			for (int i = 0; i <= 1; i++) {
				for (int j = -1; j <= 0; j++) {
					if (Main.tile[x + i, y + j] == null)
						Main.tile[x + i, y + j] = new Tile();
				}
			}

			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(36 * style);
			Main.tile[x, y - 1].type = type;
			Main.tile[x, y - 1].halfBrick(halfBrick: false);
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(18 + 36 * style);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x + 1, y - 1].halfBrick(halfBrick: false);
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(36 * style);
			Main.tile[x, y].type = type;
			Main.tile[x, y].halfBrick(halfBrick: false);
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(18 + 36 * style);
			Main.tile[x + 1, y].type = type;
			Main.tile[x + 1, y].halfBrick(halfBrick: false);
		}

		public static void PlaceDresserDirect(int x, int y, ushort type, int style, int id) {
			Chest.CreateChest(x - 1, y - 1, id);
			for (int i = -1; i <= 1; i++) {
				for (int j = -1; j <= 0; j++) {
					if (Main.tile[x + i, y + j] == null)
						Main.tile[x + i, y + j] = new Tile();
				}
			}

			short num = (short)(style * 54);
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(num + 18);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(num + 36);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(num + 18);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(num + 36);
			Main.tile[x + 1, y].type = type;
		}

		public static void CheckChest(int i, int j, int type) {
			if (destroyObject)
				return;

			bool flag = false;
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1) {
				num -= 2;
			}

			num *= -1;
			num += i;
			for (int k = num; k < num + 2; k++) {
				for (int l = num2; l < num2 + 2; l++) {
					if (Main.tile[k, l] == null)
						Main.tile[k, l] = new Tile();

					int num3;
					for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2) {
					}

					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
						flag = true;
				}

				if (Main.tile[k, num2 + 2] == null)
					Main.tile[k, num2 + 2] = new Tile();

				if (!Main.tile[k, num2 + 2].active() || !Main.tileSolid[Main.tile[k, num2 + 2].type])
					flag = true;
			}

			if (!flag)
				return;

			int num4 = Main.tile[i, j].frameX / 36;
			int type2 = (type != 467) ? Chest.chestItemSpawn[num4] : Chest.chestItemSpawn2[num4];
			destroyObject = true;
			for (int m = num; m < num + 2; m++) {
				for (int n = num2; n < num2 + 3; n++) {
					if (Main.tile[m, n].type == type && Main.tile[m, n].active()) {
						Chest.DestroyChest(m, n);
						KillTile(m, n);
					}
				}
			}

			if (TileLoader.Drop(i, j, type))
				Item.NewItem(i * 16, j * 16, 32, 32, type2);

			destroyObject = false;
			if (Main.tile[num, num2 + 2].type == 138 || Main.tile[num + 1, num2 + 2].type == 138)
				SquareTileFrame(num, num2 + 2);
		}

		public static bool PlaceActuator(int i, int j) {
			if (!Main.tile[i, j].actuator()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].actuator(actuator: true);
				return true;
			}

			return false;
		}

		public static bool KillActuator(int i, int j) {
			if (Main.tile[i, j].actuator()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].actuator(actuator: false);
				if (Main.netMode != 1)
					Item.NewItem(i * 16, j * 16, 16, 16, 849);

				for (int k = 0; k < 5; k++) {
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}

				return true;
			}

			return false;
		}

		public static bool PlaceWire(int i, int j) {
			if (!Main.tile[i, j].wire()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire(wire: true);
				return true;
			}

			return false;
		}

		public static bool KillWire(int i, int j) {
			if (Main.tile[i, j].wire()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire(wire: false);
				if (Main.netMode != 1)
					Item.NewItem(i * 16, j * 16, 16, 16, 530);

				for (int k = 0; k < 5; k++) {
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}

				return true;
			}

			return false;
		}

		public static bool PlaceWire2(int i, int j) {
			if (!Main.tile[i, j].wire2()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire2(wire2: true);
				return true;
			}

			return false;
		}

		public static bool KillWire2(int i, int j) {
			if (Main.tile[i, j].wire2()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire2(wire2: false);
				if (Main.netMode != 1)
					Item.NewItem(i * 16, j * 16, 16, 16, 530);

				for (int k = 0; k < 5; k++) {
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}

				return true;
			}

			return false;
		}

		public static bool PlaceWire3(int i, int j) {
			if (!Main.tile[i, j].wire3()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire3(wire3: true);
				return true;
			}

			return false;
		}

		public static bool KillWire3(int i, int j) {
			if (Main.tile[i, j].wire3()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire3(wire3: false);
				if (Main.netMode != 1)
					Item.NewItem(i * 16, j * 16, 16, 16, 530);

				for (int k = 0; k < 5; k++) {
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}

				return true;
			}

			return false;
		}

		public static bool PlaceWire4(int i, int j) {
			if (!Main.tile[i, j].wire4()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire4(wire4: true);
				return true;
			}

			return false;
		}

		public static bool KillWire4(int i, int j) {
			if (Main.tile[i, j].wire4()) {
				Main.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire4(wire4: false);
				if (Main.netMode != 1)
					Item.NewItem(i * 16, j * 16, 16, 16, 530);

				for (int k = 0; k < 5; k++) {
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}

				return true;
			}

			return false;
		}

		public static bool PlaceTile(int i, int j, int type, bool mute = false, bool forced = false, int plr = -1, int style = 0) {
			//if (type >= 470)
			//	return false;

			bool result = false;
			if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY) {
				Tile tile = Main.tile[i, j];
				if (tile == null) {
					tile = new Tile();
					Main.tile[i, j] = tile;
				}

				if (forced || Collision.EmptyTile(i, j) || !Main.tileSolid[type] || (type == 23 && tile.type == 0 && tile.active()) || (type == 199 && tile.type == 0 && tile.active()) || (type == 2 && tile.type == 0 && tile.active()) || (type == 109 && tile.type == 0 && tile.active()) || (type == 60 && tile.type == 59 && tile.active()) || (type == 70 && tile.type == 59 && tile.active())) {
					if (type == 23 && (tile.type != 0 || !tile.active()))
						return false;

					if (type == 2 && (tile.type != 0 || !tile.active()))
						return false;

					if (type == 109 && (tile.type != 0 || !tile.active()))
						return false;

					if (type == 60 && (tile.type != 59 || !tile.active()))
						return false;

					if (type == 81) {
						if (Main.tile[i, j - 1] == null)
							Main.tile[i, j - 1] = new Tile();

						if (Main.tile[i, j + 1] == null)
							Main.tile[i, j + 1] = new Tile();

						if (Main.tile[i, j - 1].active())
							return false;

						if (!Main.tile[i, j + 1].active() || !Main.tileSolid[Main.tile[i, j + 1].type] || Main.tile[i, j + 1].halfBrick() || Main.tile[i, j + 1].slope() != 0)
							return false;
					}

					if ((type == 373 || type == 375 || type == 374 || type == 461) && (Main.tile[i, j - 1] == null || Main.tile[i, j - 1].bottomSlope()))
						return false;

					if (tile.liquid > 0) {
						switch (type) {
							case 4:
								if (style != 8 && style != 11)
									return false;
								break;
							case 3:
							case int _ when TileLoader.IsSapling(type):
							case 20:
							case 24:
							case 27:
							case 32:
							case 51:
							case 69:
							case 72:
							case 201:
							case 352:
								return false;
						}
					}

					if (type != 2 || Main.tile[i, j].type != 0) {
						tile.halfBrick(halfBrick: false);
						tile.frameY = 0;
						tile.frameX = 0;
					}

					if (type == 3 || type == 24 || type == 110 || type == 201) {
						if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && ((Main.tile[i, j + 1].type == 2 && type == 3) || (Main.tile[i, j + 1].type == 23 && type == 24) || (Main.tile[i, j + 1].type == 199 && type == 201) || ((Main.tile[i, j + 1].type == 78 || Main.tile[i, j + 1].type == 380) && type == 3) || (Main.tile[i, j + 1].type == 109 && type == 110))) {
							if (type == 24 && genRand.Next(13) == 0) {
								tile.active(active: true);
								tile.type = 32;
								SquareTileFrame(i, j);
							}
							else if (type == 201 && genRand.Next(13) == 0) {
								tile.active(active: true);
								tile.type = 352;
								SquareTileFrame(i, j);
							}
							else if (Main.tile[i, j + 1].type == 78 || Main.tile[i, j + 1].type == 380) {
								tile.active(active: true);
								tile.type = (ushort)type;
								tile.frameX = (short)(genRand.Next(2) * 18 + 108);
							}
							else if ((tile.wall == 0 || tile.wall == 106 || tile.wall == 107 || (tile.wall >= 63 && tile.wall <= 70)) && (Main.tile[i, j + 1].wall == 0 || Main.tile[i, j + 1].wall == 106 || Main.tile[i, j + 1].wall == 107 || (Main.tile[i, j + 1].wall >= 63 && Main.tile[i, j + 1].wall <= 70))) {
								if (type == 3 && genRand.Next(35) == 0) {
									tile.active(active: true);
									tile.type = (ushort)type;
									tile.frameX = (short)(genRand.Next(2) * 18 + 162);
								}
								else if (genRand.Next(50) == 0 || ((type == 24 || type == 201) && genRand.Next(40) == 0)) {
									tile.active(active: true);
									tile.type = (ushort)type;
									if (type == 201)
										tile.frameX = 270;
									else
										tile.frameX = 144;
								}
								else if (genRand.Next(35) == 0) {
									tile.active(active: true);
									tile.type = (ushort)type;
									tile.frameX = (short)(genRand.Next(2) * 18 + 108);
								}
								else {
									tile.active(active: true);
									tile.type = (ushort)type;
									tile.frameX = (short)(genRand.Next(6) * 18);
								}
							}
						}
					}
					else if (type == 61) {
						if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 60) {
							if (genRand.Next(16) == 0 && (double)j > Main.worldSurface) {
								tile.active(active: true);
								tile.type = 69;
								SquareTileFrame(i, j);
							}
							else if (genRand.Next(60) == 0 && (double)j > Main.rockLayer) {
								tile.active(active: true);
								tile.type = (ushort)type;
								tile.frameX = 144;
							}
							else if (genRand.Next(300) == 0 && (double)j > Main.rockLayer) {
								tile.active(active: true);
								tile.type = (ushort)type;
								tile.frameX = 162;
							}
							else if (genRand.Next(15) == 0) {
								tile.active(active: true);
								tile.type = (ushort)type;
								if (genRand.Next(3) != 0)
									tile.frameX = (short)(genRand.Next(2) * 18 + 108);
								else
									tile.frameX = (short)(genRand.Next(13) * 18 + 180);
							}
							else {
								tile.active(active: true);
								tile.type = (ushort)type;
								tile.frameX = (short)(genRand.Next(6) * 18);
							}
						}
					}
					else if (type == 71) {
						if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 70) {
							tile.active(active: true);
							tile.type = (ushort)type;
							tile.frameX = (short)(genRand.Next(5) * 18);
						}
					}
					else if (type == 129) {
						if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1)) {
							tile.active(active: true);
							tile.type = (ushort)type;
							tile.frameX = (short)(genRand.Next(18) * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (type == 178) {
						if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1)) {
							tile.active(active: true);
							tile.type = (ushort)type;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (type == 184) {
						if ((Main.tileMoss[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (Main.tileMoss[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (Main.tileMoss[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (Main.tileMoss[Main.tile[i, j + 1].type] && SolidTile(i, j + 1))) {
							tile.active(active: true);
							tile.type = (ushort)type;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (type == 171) {
						PlaceXmasTree(i, j, 171);
					}
					else if (type == 254) {
						Place2x2Style(i, j, (ushort)type, style);
					}
					else if (type == 335) {
						Place2x2(i, j, (ushort)type, 0);
					}
					else if (type == 319 || type == 132 || type == 138 || type == 142 || type == 143 || type == 282 || (type >= 288 && type <= 295) || (type >= 316 && type <= 318)) {
						Place2x2(i, j, (ushort)type, 0);
					}
					else if (type == 411) {
						Place2x2(i, j, (ushort)type, 0);
					}
					else if (type == 457) {
						Place2x2Horizontal(i, j, 457, style);
					}
					else if (type == 137) {
						tile.active(active: true);
						tile.type = (ushort)type;
						tile.frameY = (short)(18 * style);
					}
					else if (type == 136) {
						if (Main.tile[i - 1, j] == null)
							Main.tile[i - 1, j] = new Tile();

						if (Main.tile[i + 1, j] == null)
							Main.tile[i + 1, j] = new Tile();

						if (Main.tile[i, j + 1] == null)
							Main.tile[i, j + 1] = new Tile();

						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || Main.tile[i - 1, j].type == 124 || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || Main.tile[i + 1, j].type == 124 || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0) || tile.wall > 0) {
							tile.active(active: true);
							tile.type = (ushort)type;
							SquareTileFrame(i, j);
						}
					}
					else if (type == 442) {
						if (Main.tile[i - 1, j] == null)
							Main.tile[i - 1, j] = new Tile();

						if (Main.tile[i + 1, j] == null)
							Main.tile[i + 1, j] = new Tile();

						if (Main.tile[i, j + 1] == null)
							Main.tile[i, j + 1] = new Tile();

						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || Main.tile[i - 1, j].type == 124 || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || Main.tile[i + 1, j].type == 124 || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0)) {
							tile.active(active: true);
							tile.type = (ushort)type;
							SquareTileFrame(i, j);
						}
					}
					else if (TileLoader.IsTorch(type)) {
						if (Main.tile[i - 1, j] == null)
							Main.tile[i - 1, j] = new Tile();

						if (Main.tile[i + 1, j] == null)
							Main.tile[i + 1, j] = new Tile();

						if (Main.tile[i, j + 1] == null)
							Main.tile[i, j + 1] = new Tile();

						Tile tile2 = Main.tile[i - 1, j];
						Tile tile3 = Main.tile[i + 1, j];
						Tile tile4 = Main.tile[i, j + 1];
						if (tile.wall > 0 || (tile2.active() && (tile2.slope() == 0 || (int)tile2.slope() % 2 != 1) && ((Main.tileSolid[tile2.type] && !Main.tileSolidTop[tile2.type] && !TileID.Sets.NotReallySolid[tile2.type]) || tile2.type == 124 || (tile2.type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (tile3.active() && (tile3.slope() == 0 || (int)tile3.slope() % 2 != 0) && ((Main.tileSolid[tile3.type] && !Main.tileSolidTop[tile3.type] && !TileID.Sets.NotReallySolid[tile3.type]) || tile3.type == 124 || (tile3.type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (tile4.active() && Main.tileSolid[tile4.type] && (!Main.tileSolidTop[tile4.type] || (TileID.Sets.Platforms[tile4.type] && tile4.slope() == 0)) && !TileID.Sets.NotReallySolid[tile4.type] && !tile4.halfBrick() && tile4.slope() == 0)) {
							tile.active(active: true);
							tile.type = (ushort)type;
							tile.frameY = (short)(22 * style);
							SquareTileFrame(i, j);
						}
					}
					else if (type == 10) {
						if (Main.tile[i, j - 1] == null)
							Main.tile[i, j - 1] = new Tile();

						if (Main.tile[i, j - 2] == null)
							Main.tile[i, j - 2] = new Tile();

						if (Main.tile[i, j - 3] == null)
							Main.tile[i, j - 3] = new Tile();

						if (Main.tile[i, j + 1] == null)
							Main.tile[i, j + 1] = new Tile();

						if (Main.tile[i, j + 2] == null)
							Main.tile[i, j + 2] = new Tile();

						if (Main.tile[i, j + 3] == null)
							Main.tile[i, j + 3] = new Tile();

						if (!Main.tile[i, j - 1].active() && !Main.tile[i, j - 2].active() && Main.tile[i, j - 3].active() && Main.tileSolid[Main.tile[i, j - 3].type]) {
							PlaceDoor(i, j - 1, type, style);
							SquareTileFrame(i, j);
						}
						else {
							if (Main.tile[i, j + 1].active() || Main.tile[i, j + 2].active() || !Main.tile[i, j + 3].active() || !Main.tileSolid[Main.tile[i, j + 3].type])
								return false;

							PlaceDoor(i, j + 1, type, style);
							SquareTileFrame(i, j);
						}
					}
					else if ((type >= 275 && type <= 281) || type == 296 || type == 297 || type == 309 || type == 358 || type == 359 || type == 413 || type == 414) {
						Place6x3(i, j, (ushort)type);
					}
					else {
						switch (type) {
							case 237:
							case 244:
							case 285:
							case 286:
							case 298:
							case 299:
							case 310:
							case 339:
							case 361:
							case 362:
							case 363:
							case 364:
								Place3x2(i, j, (ushort)type);
								break;
							default:
								if (type == 128) {
									PlaceMan(i, j, style);
									SquareTileFrame(i, j);
									break;
								}
								if (type == 269) {
									PlaceWoman(i, j, style);
									SquareTileFrame(i, j);
									break;
								}
								if (type == 334) {
									int style2 = 0;
									if (style == -1)
										style2 = 1;

									Place3x3Wall(i, j, 334, style2);
									SquareTileFrame(i, j);
									break;
								}
								if (type == 149) {
									if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1)) {
										tile.frameX = (short)(18 * style);
										tile.active(active: true);
										tile.type = (ushort)type;
										SquareTileFrame(i, j);
									}

									break;
								}
								if (type == 139 || type == 35) {
									PlaceMB(i, j, (ushort)type, style);
									SquareTileFrame(i, j);
									break;
								}
								if (type == 165) {
									PlaceTight(i, j, (ushort)type);
									SquareTileFrame(i, j);
									break;
								}
								if (type == 235) {
									Place3x1(i, j, (ushort)type);
									SquareTileFrame(i, j);
									break;
								}
								if (type == 240) {
									Place3x3Wall(i, j, (ushort)type, style);
									break;
								}
								if (type == 440) {
									Place3x3Wall(i, j, (ushort)type, style);
									break;
								}
								if (type == 245) {
									Place2x3Wall(i, j, (ushort)type, style);
									break;
								}
								if (type == 246) {
									Place3x2Wall(i, j, (ushort)type, style);
									break;
								}
								if (type == 241) {
									Place4x3Wall(i, j, (ushort)type, style);
									break;
								}
								if (type == 242) {
									Place6x4Wall(i, j, (ushort)type, style);
									break;
								}
								if (type == 34) {
									PlaceChand(i, j, (ushort)type, style);
									SquareTileFrame(i, j);
									break;
								}
								if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355) {
									Place3x3(i, j, (ushort)type, style);
									SquareTileFrame(i, j);
									break;
								}
								switch (type) {
									case 13:
									case 33:
									case 49:
									case 50:
									case 78:
									case 174:
									case 372:
										PlaceOnTable1x1(i, j, type, style);
										SquareTileFrame(i, j);
										break;
									case 14:
									case 26:
									case 86:
									case 87:
									case int _ when TileLoader.IsDresser(type):
									case 88:
									case 89:
									case 114:
									case 186:
									case 187:
									case 215:
									case 217:
									case 218:
									case 377:
										Place3x2(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 236:
										PlaceJunglePlant(i, j, (ushort)type, genRand.Next(3), 0);
										SquareTileFrame(i, j);
										break;
									case 238:
										PlaceJunglePlant(i, j, (ushort)type, 0, 0);
										SquareTileFrame(i, j);
										break;
									case int _ when TileLoader.IsSapling(type): {
											if (Main.tile[i, j + 1] == null)
												Main.tile[i, j + 1] = new Tile();

											int type2 = Main.tile[i, j + 1].type;
											int dummyType = TileID.Saplings;
											int dummyStyle = 0;
											if (Main.tile[i, j + 1].active() && (type2 == 2 || type2 == 109 || type2 == 147 || type2 == 60 || type2 == 23 || type2 == 199 || type2 == 53 || type2 == 234 || type2 == 116 || type2 == 112 || TileLoader.SaplingGrowthType(type2, ref dummyType, ref dummyStyle))) {
												Place1x2(i, j, (ushort)type, style);
												SquareTileFrame(i, j);
											}

											break;
										}
									case 15:
									case 216:
									case 338:
									case 390:
										if (Main.tile[i, j - 1] == null)
											Main.tile[i, j - 1] = new Tile();
										if (Main.tile[i, j] == null)
											Main.tile[i, j] = new Tile();
										Place1x2(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 227:
										PlaceDye(i, j, style);
										SquareTileFrame(i, j);
										break;
									case 16:
									case 18:
									case 29:
									case 103:
									case 134:
									case 462:
										Place2x1(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 92:
									case 93:
									case 453:
										Place1xX(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 104:
									case 105:
									case 320:
									case 337:
									case 349:
									case 356:
									case 378:
									case 456:
										Place2xX(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 17:
									case 77:
									case 133:
										Place3x2(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 207:
										Place2xX(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 410:
										Place2xX(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									case 465:
										Place2xX(i, j, (ushort)type, style);
										SquareTileFrame(i, j);
										break;
									default:
										if (TileID.Sets.BasicChest[type]) {
											PlaceChest(i, j, (ushort)type, notNearOtherChests: false, style);
											SquareTileFrame(i, j);
											break;
										}
										switch (type) {
											case 91:
												PlaceBanner(i, j, (ushort)type, style);
												SquareTileFrame(i, j);
												break;
											case 419:
											case 420:
											case 423:
											case 424:
											case 429:
											case 445:
												PlaceLogicTiles(i, j, type, style);
												SquareTileFrame(i, j);
												break;
											case 36:
											case 135:
											case 141:
											case 144:
											case 210:
											case 239:
											case 324:
												Place1x1(i, j, type, style);
												SquareTileFrame(i, j);
												break;
											case 101:
											case 102:
											case 463:
												Place3x4(i, j, (ushort)type, style);
												SquareTileFrame(i, j);
												break;
											case 464:
											case 466:
												Place5x4(i, j, (ushort)type, style);
												SquareTileFrame(i, j);
												break;
											case 27:
												PlaceSunflower(i, j, 27);
												SquareTileFrame(i, j);
												break;
											case 28:
												PlacePot(i, j, 28, genRand.Next(4));
												SquareTileFrame(i, j);
												break;
											case 42:
											case 270:
											case 271:
												Place1x2Top(i, j, (ushort)type, style);
												SquareTileFrame(i, j);
												break;
											case 55:
											case 425:
												PlaceSign(i, j, (ushort)type, style);
												break;
											case 85:
											case 376:
												Place2x2Horizontal(i, j, (ushort)type, style);
												break;
											default:
												if (Main.tileAlch[type]) {
													PlaceAlch(i, j, style);
													break;
												}
												switch (type) {
													case 94:
													case 95:
													case 97:
													case 98:
													case 99:
													case 100:
													case 125:
													case 126:
													case 172:
													case 173:
													case 287:
														Place2x2(i, j, (ushort)type, style);
														break;
													case 96:
														Place2x2Style(i, j, (ushort)type, style);
														break;
													case 79:
													case 90: {
															int direction = 1;
															if (plr > -1)
																direction = Main.player[plr].direction;

															Place4x2(i, j, (ushort)type, direction, style);
															break;
														}
													case 209:
														PlaceCannon(i, j, (ushort)type, style);
														break;
													case 81:
														tile.frameX = (short)(26 * genRand.Next(6));
														tile.active(active: true);
														tile.type = (ushort)type;
														break;
													case 19:
														tile.frameY = (short)(18 * style);
														tile.active(active: true);
														tile.type = (ushort)type;
														break;
													case 380:
														tile.frameY = (short)(18 * style);
														tile.active(active: true);
														tile.type = (ushort)type;
														break;
													case 314:
														Minecart.PlaceTrack(tile, style);
														break;
													case int _ when type >= TileID.Count && TileObjectData.GetTileData(type, style) != null:
														PlaceObject(i, j, type, mute, style);
														break;
													default:
														tile.active(active: true);
														tile.type = (ushort)type;
														break;
												}
												break;
										}
										break;
								}
								break;
						}
					}

					if (tile.active()) {
						if (tile.type == 54)
							SquareWallFrame(i, j);

						SquareTileFrame(i, j);
						result = true;
						if (!mute) {
							switch (type) {
								case 127:
									Main.PlaySound(SoundID.Item30, i * 16, j * 16);
									break;
								case 314:
									Main.PlaySound(SoundID.Item52, i * 16, j * 16);
									break;
								case 330:
								case 331:
								case 332:
								case 333:
									Main.PlaySound(18, i * 16, j * 16);
									break;
								default:
									Main.PlaySound(0, i * 16, j * 16);
									break;
							}

							if (type == 22 || type == 140) {
								for (int k = 0; k < 3; k++) {
									Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 14);
								}
							}
						}
					}
				}
			}

			return result;
		}

		public static void KillWall(int i, int j, bool fail = false) {
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
				return;

			Tile tile = Main.tile[i, j];
			if (tile == null) {
				tile = new Tile();
				Main.tile[i, j] = tile;
			}

			if (tile.wall <= 0)
				return;

			if (Main.wallDungeon[tile.wall] && !NPC.downedBoss3)
				fail = true;

			if (tile.wall == 87 && !NPC.downedGolemBoss)
				fail = true;

			WallLoader.KillWall(i, j, tile.wall, ref fail);
			if (!WallLoader.KillSound(i, j, tile.wall)) {}
			else if (tile.wall == 21 || tile.wall == 186 || tile.wall == 136 || tile.wall == 137 || tile.wall == 168 || tile.wall == 169 || tile.wall == 172 || tile.wall == 226 || tile.wall == 227)
				Main.PlaySound(13, i * 16, j * 16);
			else if (tile.wall >= 63 && tile.wall <= 70)
				Main.PlaySound(6, i * 16, j * 16);
			else
				Main.PlaySound(0, i * 16, j * 16);

			int num = 10;
			if (fail)
				num = 3;

			WallLoader.NumDust(i, j, tile.wall, fail, ref num);
			for (int k = 0; k < num; k++) {
				int num2 = 0;
				if (tile.wall == 148)
					num2 = -1;

				if (tile.wall == 1 || tile.wall == 5 || tile.wall == 6 || tile.wall == 7 || tile.wall == 107 || tile.wall == 8 || tile.wall == 9 || (tile.wall >= 48 && tile.wall <= 53) || (tile.wall >= 54 && tile.wall <= 58) || tile.wall == 185)
					num2 = 1;

				if (tile.wall >= 94 && tile.wall <= 105)
					num2 = 1;

				if (tile.wall == 3)
					num2 = ((genRand.Next(2) != 0) ? 1 : 14);

				if (tile.wall == 35)
					num2 = 37;

				if (tile.wall == 4 || tile.wall == 106)
					num2 = 7;

				if (tile.wall == 12)
					num2 = 9;

				if (tile.wall == 10)
					num2 = 10;

				if (tile.wall == 11)
					num2 = 11;

				if (tile.wall == 21)
					num2 = 13;

				if (tile.wall == 34)
					num2 = 32;

				if (tile.wall == 225)
					num2 = 1;

				if (tile.wall == 145)
					num2 = 8;

				if (tile.wall == 22 || tile.wall == 28)
					num2 = 51;

				if (tile.wall == 23)
					num2 = 38;

				if (tile.wall == 24)
					num2 = 36;

				if (tile.wall == 25)
					num2 = 48;

				if (tile.wall == 179 || tile.wall == 178 || tile.wall == 183)
					num2 = 236;

				if (tile.wall == 181 || tile.wall == 180 || tile.wall == 184)
					num2 = 240;

				if (tile.wall == 113)
					num2 = 189;

				if (tile.wall == 114)
					num2 = 190;

				if (tile.wall == 115)
					num2 = 191;

				if (tile.wall == 177 || tile.wall == 13)
					num2 = 25;

				if (tile.wall == 186)
					num2 = genRand.Next(68, 71);

				if (tile.wall == 142)
					num2 = 210;

				if (tile.wall == 143)
					num2 = 210;

				if (tile.wall == 224)
					num2 = 265;

				if (tile.wall == 173)
					num2 = 128;

				if (tile.wall == 174)
					num2 = 117;

				if (tile.wall == 175)
					num2 = 42;

				if (tile.wall == 176)
					num2 = 226;

				if (tile.wall == 182)
					num2 = ((genRand.Next(2) != 0) ? 23 : 6);

				if (tile.wall >= 153 && tile.wall <= 166) {
					switch (tile.wall) {
						case 154:
						case 158:
							num2 = 86;
							break;
						case 163:
						case 166:
							num2 = 87;
							break;
						case 162:
						case 165:
							num2 = 88;
							break;
						case 156:
						case 160:
							num2 = 89;
							break;
						case 161:
						case 164:
							num2 = 90;
							break;
						case 155:
						case 159:
							num2 = 91;
							break;
						case 153:
						case 157:
							num2 = 138;
							break;
					}
				}

				if (tile.wall == 26 || tile.wall == 30)
					num2 = 49;

				if (tile.wall == 29 || tile.wall == 32)
					num2 = 50;

				if (tile.wall == 31)
					num2 = 51;

				if (tile.wall == 14 || tile.wall == 20)
					num2 = 109;

				if (tile.wall >= 88 && tile.wall <= 93) {
					num2 = 86 + tile.wall - 88;
					if (tile.wall == 93)
						num2 = genRand.Next(88, 94);
				}

				if (tile.wall == 33)
					num2 = 14;

				if (tile.wall == 41)
					num2 = 77;

				if (tile.wall == 42)
					num2 = 78;

				if (tile.wall == 43)
					num2 = 78;

				if (tile.wall == 43)
					num2 = 78;

				if (tile.wall == 36)
					num2 = 26;

				if (tile.wall == 37)
					num2 = 32;

				if (tile.wall == 38)
					num2 = 2;

				if (tile.wall == 39)
					num2 = 1;

				if (tile.wall == 40)
					num2 = 51;

				if (tile.wall == 45)
					num2 = 81;

				if (tile.wall == 46)
					num2 = 83;

				if (tile.wall == 47)
					num2 = 84;

				if (tile.wall == 85)
					num2 = 126;

				if (tile.wall == 59)
					num2 = 0;

				if (tile.wall == 61)
					num2 = 0;

				if (tile.wall == 62)
					num2 = 0;

				if (tile.wall == 63)
					num2 = 3;

				if (tile.wall == 65)
					num2 = 3;

				if (tile.wall == 66)
					num2 = 3;

				if (tile.wall == 68)
					num2 = 3;

				if (tile.wall == 64)
					num2 = 40;

				if (tile.wall == 67)
					num2 = 40;

				if (tile.wall == 84)
					num2 = 80;

				if (tile.wall == 71)
					num2 = 80;

				if (tile.wall == 60)
					num2 = 3;

				if (tile.wall == 71)
					num2 = 80;

				if (tile.wall == 167)
					num2 = 81;

				if (tile.wall == 147)
					num2 = 51;

				if (tile.wall == 146)
					num2 = 9;

				if (tile.wall == 109)
					num2 = 144;

				if (tile.wall == 110)
					num2 = 145;

				if (tile.wall == 111)
					num2 = 146;

				if (tile.wall == 86 || tile.wall == 108)
					num2 = 147;

				if (tile.wall == 87)
					num2 = 148;

				if (tile.wall == 83) {
					num2 = 117;
					if (genRand.Next(2) == 0)
						num2 = 1;
				}

				if (tile.wall == 81)
					num2 = 123;

				if (tile.wall == 136)
					num2 = 13;

				if (tile.wall == 137)
					num2 = 13;

				if (tile.wall == 168)
					num2 = 13;

				if (tile.wall == 169)
					num2 = 13;

				if (tile.wall == 172)
					num2 = 13;

				if (tile.wall == 226)
					num2 = 13;

				if (tile.wall == 227)
					num2 = 13;

				if (tile.wall == 72)
					num2 = 40;

				if (tile.wall == 73)
					num2 = 16;

				if (tile.wall == 74 || tile.wall == 80)
					num2 = 26;

				if (tile.wall == 144)
					num2 = ((genRand.Next(2) != 0) ? 118 : 10);

				if (tile.wall == 75)
					num2 = 26;

				if (tile.wall == 76)
					num2 = 4;

				if (tile.wall == 77 || tile.wall == 81)
					num2 = 5;

				if (tile.wall == 78)
					num2 = 7;

				if (tile.wall == 79)
					num2 = 37;

				if (tile.wall == 82)
					num2 = 36;

				if (tile.wall == 69)
					num2 = ((genRand.Next(2) != 0) ? 17 : 14);

				if (tile.wall == 70)
					num2 = 47;

				if (tile.wall == 27)
					num2 = ((genRand.Next(2) != 0) ? 1 : 7);

				if (tile.wall == 138)
					num2 = 77;

				if (tile.wall == 139)
					num2 = 78;

				if (tile.wall == 140)
					num2 = 79;

				if (tile.wall == 141)
					num2 = 126;

				if (tile.wall == 149 || tile.wall == 150)
					num2 = 214;

				if (tile.wall == 151 || tile.wall == 152)
					num2 = 215;
				else if (tile.wall == 17 || tile.wall == 18 || tile.wall == 19)
					num2 = 1;

				if (!WallLoader.CreateDust(i, j, tile.wall, ref num2))
					continue;

				if (tile.wall == 44) {
					int num3 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
					Main.dust[num3].noGravity = true;
				}
				else if ((tile.wall < 133 || tile.wall > 135) && (tile.wall < 116 || tile.wall > 125) && (tile.wall < 126 || tile.wall > 132)) {
					if (tile.wall == 76)
						Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num2, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
					else if (num2 >= 0)
						Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num2);
				}
			}

			if (fail) {
				SquareWallFrame(i, j);
				return;
			}

			int num4 = 0;
			if (tile.wall == 168)
				num4 = 2696;

			if (tile.wall == 169)
				num4 = 2698;

			if (tile.wall == 226)
				num4 = 3752;

			if (tile.wall == 227)
				num4 = 3753;

			if (tile.wall == 228)
				num4 = 3760;

			if (tile.wall == 229)
				num4 = 3761;

			if (tile.wall == 230)
				num4 = 3762;

			if (tile.wall == 142)
				num4 = 2263;

			if (tile.wall == 143)
				num4 = 2264;

			if (tile.wall == 144)
				num4 = 2271;

			if (tile.wall == 149)
				num4 = 2505;

			if (tile.wall == 150)
				num4 = 2507;

			if (tile.wall == 151)
				num4 = 2506;

			if (tile.wall == 152)
				num4 = 2508;

			if (tile.wall == 1)
				num4 = 26;

			if (tile.wall == 4)
				num4 = 93;

			if (tile.wall == 5)
				num4 = 130;

			if (tile.wall == 6)
				num4 = 132;

			if (tile.wall == 7)
				num4 = 135;

			if (tile.wall == 8)
				num4 = 138;

			if (tile.wall == 9)
				num4 = 140;

			if (tile.wall == 10)
				num4 = 142;

			if (tile.wall == 11)
				num4 = 144;

			if (tile.wall == 12)
				num4 = 146;

			if (tile.wall == 14)
				num4 = 330;

			if (tile.wall == 224)
				num4 = 3472;

			if (tile.wall == 177)
				num4 = 3067;

			if (tile.wall == 167)
				num4 = 2691;

			if (tile.wall == 60)
				num4 = 3584;

			if (tile.wall == 225)
				num4 = 3751;

			if (tile.wall == 179)
				num4 = 3083;

			if (tile.wall == 183)
				num4 = 3082;

			if (tile.wall == 181)
				num4 = 3089;

			if (tile.wall == 184)
				num4 = 3088;

			if (tile.wall == 186)
				num4 = 3238;

			if (tile.wall >= 153 && tile.wall <= 166) {
				switch (tile.wall) {
					case 154:
						num4 = 2679;
						break;
					case 158:
						num4 = 2680;
						break;
					case 166:
						num4 = 2689;
						break;
					case 163:
						num4 = 2690;
						break;
					case 165:
						num4 = 2687;
						break;
					case 162:
						num4 = 2688;
						break;
					case 156:
						num4 = 2683;
						break;
					case 160:
						num4 = 2684;
						break;
					case 164:
						num4 = 2685;
						break;
					case 161:
						num4 = 2686;
						break;
					case 155:
						num4 = 2681;
						break;
					case 159:
						num4 = 2682;
						break;
					case 153:
						num4 = 2677;
						break;
					case 157:
						num4 = 2678;
						break;
				}
			}

			if (tile.wall == 136)
				num4 = 2169;

			if (tile.wall == 137)
				num4 = 2170;

			if (tile.wall == 172)
				num4 = 2788;

			if (tile.wall == 145)
				num4 = 2333;

			if (tile.wall == 16)
				num4 = 30;

			if (tile.wall == 17)
				num4 = 135;

			if (tile.wall == 18)
				num4 = 138;

			if (tile.wall == 19)
				num4 = 140;

			if (tile.wall == 20)
				num4 = 330;

			if (tile.wall == 21)
				num4 = 392;

			if (tile.wall == 86 || tile.wall == 108)
				num4 = 1126;

			if (tile.wall == 173)
				num4 = 2789;

			if (tile.wall == 174)
				num4 = 2790;

			if (tile.wall == 175)
				num4 = 2791;

			if (tile.wall == 176)
				num4 = 2861;

			if (tile.wall == 182)
				num4 = 3101;

			if (tile.wall == 133)
				num4 = 2158;

			if (tile.wall == 134)
				num4 = 2159;

			if (tile.wall == 135)
				num4 = 2160;
			else if (tile.wall == 113)
				num4 = 1726;
			else if (tile.wall == 114)
				num4 = 1728;
			else if (tile.wall == 115)
				num4 = 1730;
			else if (tile.wall == 146)
				num4 = 2432;
			else if (tile.wall == 147)
				num4 = 2433;
			else if (tile.wall == 148)
				num4 = 2434;

			if (tile.wall >= 116 && tile.wall <= 125)
				num4 = 1948 + tile.wall - 116;

			if (tile.wall >= 126 && tile.wall <= 132)
				num4 = 2008 + tile.wall - 126;

			if (tile.wall == 22)
				num4 = 417;

			if (tile.wall == 23)
				num4 = 418;

			if (tile.wall == 24)
				num4 = 419;

			if (tile.wall == 25)
				num4 = 420;

			if (tile.wall == 26)
				num4 = 421;

			if (tile.wall == 29)
				num4 = 587;

			if (tile.wall == 30)
				num4 = 592;

			if (tile.wall == 31)
				num4 = 595;

			if (tile.wall == 32)
				num4 = 605;

			if (tile.wall == 33)
				num4 = 606;

			if (tile.wall == 34)
				num4 = 608;

			if (tile.wall == 35)
				num4 = 610;

			if (tile.wall == 36)
				num4 = 615;

			if (tile.wall == 37)
				num4 = 616;

			if (tile.wall == 38)
				num4 = 617;

			if (tile.wall == 39)
				num4 = 618;

			if (tile.wall == 41)
				num4 = 622;

			if (tile.wall == 42)
				num4 = 623;

			if (tile.wall == 43)
				num4 = 624;

			if (tile.wall == 44)
				num4 = 663;

			if (tile.wall == 45)
				num4 = 720;

			if (tile.wall == 46)
				num4 = 721;

			if (tile.wall == 47)
				num4 = 722;

			if (tile.wall == 66)
				num4 = 745;

			if (tile.wall == 67)
				num4 = 746;

			if (tile.wall == 68)
				num4 = 747;

			if (tile.wall == 84)
				num4 = 884;

			if (tile.wall == 72)
				num4 = 750;

			if (tile.wall == 73)
				num4 = 752;

			if (tile.wall == 74)
				num4 = 764;

			if (tile.wall == 85)
				num4 = 927;

			if (tile.wall == 75)
				num4 = 768;

			if (tile.wall == 76)
				num4 = 769;

			if (tile.wall == 77)
				num4 = 770;

			if (tile.wall == 82)
				num4 = 825;

			if (tile.wall == 27)
				num4 = 479;

			if (tile.wall == 106)
				num4 = 1447;

			if (tile.wall == 107)
				num4 = 1448;

			if (tile.wall == 109)
				num4 = 1590;

			if (tile.wall == 110)
				num4 = 1592;

			if (tile.wall == 111)
				num4 = 1594;

			if (tile.wall == 78)
				num4 = 1723;

			if (tile.wall == 87 || tile.wall == 112)
				num4 = 1102;

			if (tile.wall == 94 || tile.wall == 100)
				num4 = 1378;

			if (tile.wall == 95 || tile.wall == 101)
				num4 = 1379;

			if (tile.wall == 96 || tile.wall == 102)
				num4 = 1380;

			if (tile.wall == 97 || tile.wall == 103)
				num4 = 1381;

			if (tile.wall == 98 || tile.wall == 104)
				num4 = 1382;

			if (tile.wall == 99 || tile.wall == 105)
				num4 = 1383;

			if (tile.wall >= 88 && tile.wall <= 93)
				num4 = 1267 + tile.wall - 88;

			if (tile.wall >= 138 && tile.wall <= 141)
				num4 = 2210 + tile.wall - 138;

			if (WallLoader.Drop(i, j, tile.wall, ref num4) && num4 > 0)
				Item.NewItem(i * 16, j * 16, 16, 16, num4);

			tile.wall = 0;
			tile.wallColor(0);
			SquareWallFrame(i, j);
			if (tile.type >= 0 && TileID.Sets.FramesOnKillWall[tile.type])
				TileFrame(i, j);
		}

		public static void LaunchRocket(int x, int y) {
			int num = Main.tile[x, y].frameY;
			int num2 = 0;
			while (num >= 40) {
				num -= 40;
				num2++;
			}

			if (num == 18)
				y--;

			Vector2 vector = new Vector2(x * 16 + 8, y * 16 + 4);
			int type = 167 + num2;
			int damage = 150;
			int num3 = 7;
			Projectile.NewProjectile(vector.X, vector.Y + 2f, 0f, -8f, type, damage, num3, Main.myPlayer);
			Main.tile[x, y].active(active: false);
			Main.tile[x, y + 1].active(active: false);
			NetMessage.SendTileSquare(-1, x - 1, y, 3);
		}

		public static void LaunchRocketSmall(int x, int y) {
			if (Main.tile[x, y].frameX == 18)
				x--;

			if (Main.tile[x, y].frameY == 18)
				y--;

			Vector2 vector = new Vector2(x * 16 + 16, y * 16);
			int type = 415 + Main.rand.Next(4);
			int damage = 0;
			int num = 0;
			Projectile.NewProjectile(vector.X, vector.Y + 2f, 0f, -8f, type, damage, num, Main.myPlayer);
		}

		public static bool CanKillTile(int i, int j) {
			bool blockDamaged;
			return CanKillTile(i, j, out blockDamaged);
		}

		public static bool CanKillTile(int i, int j, out bool blockDamaged) {
			blockDamaged = false;
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
				return false;

			Tile tile = Main.tile[i, j];
			Tile tile2 = null;
			if (tile == null)
				return false;

			if (!tile.active())
				return false;

			if (!TileLoader.CanKillTile(i, j, tile.type, ref blockDamaged))
				return false;

			if (j >= 1)
				tile2 = Main.tile[i, j - 1];

			if (tile2 != null && tile2.active()) {
				int type = tile2.type;
				switch (type) {
					case 5:
						if (tile.type != type && (tile2.frameX != 66 || tile2.frameY < 0 || tile2.frameY > 44) && (tile2.frameX != 88 || tile2.frameY < 66 || tile2.frameY > 110) && tile2.frameY < 198)
							return false;
						break;
					case 323:
						if (tile.type != type && (tile2.frameX == 66 || tile2.frameX == 220))
							return false;
						break;
					case 21:
					case int _ when TileID.Sets.BasicChest[type]:
					case 26:
					case 72:
					case 88:
					case int t when TileLoader.IsDresser(t):
						if (tile.type != type)
							return false;
						break;
				}
			}

			switch (tile.type) {
				case 10:
					if (tile.type == 10 && tile.frameY >= 594 && tile.frameY <= 646) {
						blockDamaged = true;
						return false;
					}
					break;
				case 138:
					if (CheckBoulderChest(i, j)) {
						blockDamaged = true;
						return false;
					}
					break;
				case 235: {
						int num = i - tile.frameX % 54 / 18;
						for (int k = 0; k < 3; k++) {
							if (Main.tile[num + k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[num + k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[num + k, j - 1].type])) {
								blockDamaged = true;
								return false;
							}
						}

						break;
					}
				case 21:
				case ushort _ when TileID.Sets.BasicChest[tile.type]:
					if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
						return false;
					break;
				case ushort t when TileLoader.IsDresser(t):
				case 88:
					if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
						return false;
					break;
			}

			return true;
		}

		public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false) {
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
				return;

			Tile tile = Main.tile[i, j];
			if (tile == null) {
				tile = new Tile();
				Main.tile[i, j] = tile;
			}

			if (!tile.active())
				return;

			if (j >= 1 && Main.tile[i, j - 1] == null)
				Main.tile[i, j - 1] = new Tile();

			if (j >= 1 && Main.tile[i, j - 1].active() && ((Main.tile[i, j - 1].type == 5 && tile.type != 5) || (Main.tile[i, j - 1].type == 323 && tile.type != 323) || (TileID.Sets.BasicChest[Main.tile[i, j - 1].type] && !TileID.Sets.BasicChest[tile.type]) || (Main.tile[i, j - 1].type == 323 && tile.type != 323) || (TileLoader.IsDresser(Main.tile[i, j - 1].type) && !TileLoader.IsDresser(tile.type)) || (Main.tile[i, j - 1].type == 26 && tile.type != 26) || (Main.tile[i, j - 1].type == 72 && tile.type != 72))) {
				if (Main.tile[i, j - 1].type == 5) {
					if ((Main.tile[i, j - 1].frameX != 66 || Main.tile[i, j - 1].frameY < 0 || Main.tile[i, j - 1].frameY > 44) && (Main.tile[i, j - 1].frameX != 88 || Main.tile[i, j - 1].frameY < 66 || Main.tile[i, j - 1].frameY > 110) && Main.tile[i, j - 1].frameY < 198)
						return;
				}
				else if (Main.tile[i, j - 1].type != 323 || Main.tile[i, j - 1].frameX == 66 || Main.tile[i, j - 1].frameX == 220) {
					return;
				}
			}

			if (tile.type == 10 && tile.frameY >= 594 && tile.frameY <= 646)
				fail = true;

			if (tile.type == 138)
				fail = CheckBoulderChest(i, j);

			if (tile.type == 235) {
				int frameX = tile.frameX;
				int num = i - frameX % 54 / 18;
				for (int k = 0; k < 3; k++) {
					if (Main.tile[num + k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[num + k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[num + k, j - 1].type] || TileLoader.IsDresser(Main.tile[num + k, j - 1].type))) {
						fail = true;
						break;
					}
				}
			}

			TileLoader.KillTile(i, j, tile.type, ref fail, ref effectOnly, ref noItem);
			if (!effectOnly && !stopDrops) {
				if (!noItem && FixExploitManEaters.SpotProtected(i, j))
					return;

				if (!TileLoader.KillSound(i, j, tile.type)) { }
				else if (tile.type == 127) {
					Main.PlaySound(SoundID.Item27, i * 16, j * 16);
				}
				else if (tile.type == 147 || tile.type == 224) {
					if (genRand.Next(2) == 0)
						Main.PlaySound(SoundID.Item48, i * 16, j * 16);
					else
						Main.PlaySound(SoundID.Item49, i * 16, j * 16);
				}
				else if (tile.type == 161 || tile.type == 163 || tile.type == 164 || tile.type == 200) {
					Main.PlaySound(SoundID.Item50, i * 16, j * 16);
				}
				else if (tile.type == 3 || tile.type == 110) {
					Main.PlaySound(6, i * 16, j * 16);
					if (tile.frameX == 144)
						Item.NewItem(i * 16, j * 16, 16, 16, 5);
				}
				else if (tile.type == 254) {
					Main.PlaySound(6, i * 16, j * 16);
				}
				else if (tile.type == 24) {
					Main.PlaySound(6, i * 16, j * 16);
					if (tile.frameX == 144)
						Item.NewItem(i * 16, j * 16, 16, 16, 60);
				}
				else if (Main.tileAlch[tile.type] || tile.type == 384 || tile.type == 227 || tile.type == 32 || tile.type == 51 || tile.type == 52 || tile.type == 61 || tile.type == 62 || tile.type == 69 || tile.type == 71 || tile.type == 73 || tile.type == 74 || tile.type == 113 || tile.type == 115 || tile.type == 184 || tile.type == 192 || tile.type == 205 || tile.type == 233 || tile.type == 352 || tile.type == 382) {
					Main.PlaySound(6, i * 16, j * 16);
				}
				else if (tile.type == 201) {
					Main.PlaySound(6, i * 16, j * 16);
					if (tile.frameX == 270)
						Item.NewItem(i * 16, j * 16, 16, 16, 2887);
				}
				else if (tile.type == 1 || tile.type == 6 || tile.type == 7 || tile.type == 8 || tile.type == 9 || tile.type == 22 || tile.type == 140 || tile.type == 25 || tile.type == 37 || tile.type == 38 || tile.type == 39 || tile.type == 41 || tile.type == 43 || tile.type == 44 || tile.type == 45 || tile.type == 46 || tile.type == 47 || tile.type == 48 || tile.type == 56 || tile.type == 58 || tile.type == 63 || tile.type == 64 || tile.type == 65 || tile.type == 66 || tile.type == 67 || tile.type == 68 || tile.type == 75 || tile.type == 76 || tile.type == 107 || tile.type == 108 || tile.type == 111 || tile.type == 117 || tile.type == 118 || tile.type == 119 || tile.type == 120 || tile.type == 121 || tile.type == 122 || tile.type == 150 || tile.type == 151 || tile.type == 152 || tile.type == 153 || tile.type == 154 || tile.type == 155 || tile.type == 156 || tile.type == 160 || tile.type == 161 || tile.type == 166 || tile.type == 167 || tile.type == 168 || tile.type == 169 || tile.type == 175 || tile.type == 176 || tile.type == 177 || tile.type == 203 || tile.type == 202 || tile.type == 204 || tile.type == 206 || tile.type == 211 || tile.type == 221 || tile.type == 222 || tile.type == 223 || tile.type == 226 || tile.type == 248 || tile.type == 249 || tile.type == 250 || tile.type == 272 || tile.type == 273 || tile.type == 274 || tile.type == 284 || tile.type == 325 || tile.type == 346 || tile.type == 347 || tile.type == 348 || tile.type == 350 || tile.type == 367 || tile.type == 357 || tile.type == 368 || tile.type == 369 || tile.type == 370 || tile.type == 407) {
					Main.PlaySound(21, i * 16, j * 16);
				}
				else if (tile.type == 231 || tile.type == 195) {
					Main.PlaySound(4, i * 16, j * 16);
				}
				else if (tile.type == 26 && tile.frameX >= 54) {
					Main.PlaySound(4, i * 16, j * 16);
				}
				else if (tile.type == 314) {
					Main.PlaySound(SoundID.Item52, i * 16, j * 16);
				}
				else if (tile.type >= 330 && tile.type <= 333) {
					Main.PlaySound(18, i * 16, j * 16);
				}
				else if (tile.type != 138) {
					Main.PlaySound(0, i * 16, j * 16);
				}

				if ((tile.type == 162 || tile.type == 385 || tile.type == 129 || (tile.type == 165 && tile.frameX < 54)) && !fail)
					Main.PlaySound(SoundID.Item27, i * 16, j * 16);
			}

			if (tile.type == 128 || tile.type == 269) {
				int num2 = i;
				int num3 = tile.frameX;
				int num4;
				for (num4 = tile.frameX; num4 >= 100; num4 -= 100) {
				}

				while (num4 >= 36) {
					num4 -= 36;
				}

				if (num4 == 18) {
					num3 = Main.tile[i - 1, j].frameX;
					num2--;
				}

				if (num3 >= 100) {
					int num5 = 0;
					while (num3 >= 100) {
						num3 -= 100;
						num5++;
					}

					int num6 = Main.tile[num2, j].frameY / 18;
					if (num6 == 0)
						Item.NewItem(i * 16, j * 16, 16, 16, Item.headType[num5]);

					if (num6 == 1)
						Item.NewItem(i * 16, j * 16, 16, 16, Item.bodyType[num5]);

					if (num6 == 2)
						Item.NewItem(i * 16, j * 16, 16, 16, Item.legType[num5]);

					for (num3 = Main.tile[num2, j].frameX; num3 >= 100; num3 -= 100) {
					}

					Main.tile[num2, j].frameX = (short)num3;
				}
			}

			if (tile.type == 334) {
				int num7 = i;
				int frameX2 = tile.frameX;
				int num8 = tile.frameX;
				int num9 = 0;
				while (num8 >= 5000) {
					num8 -= 5000;
					num9++;
				}

				if (num9 != 0)
					num8 = (num9 - 1) * 18;

				num8 %= 54;
				if (num8 == 18) {
					frameX2 = Main.tile[i - 1, j].frameX;
					num7--;
				}

				if (num8 == 36) {
					frameX2 = Main.tile[i - 2, j].frameX;
					num7 -= 2;
				}

				if (frameX2 >= 5000) {
					int num10 = frameX2 % 5000;
					num10 -= 100;
					int frameX3 = Main.tile[num7 + 1, j].frameX;
					frameX3 = ((frameX3 < 25000) ? (frameX3 - 10000) : (frameX3 - 25000));
					if (Main.netMode != 1) {
						Item item = new Item();
						item.netDefaults(num10);
						item.Prefix(frameX3);
						int num11 = Item.NewItem(i * 16, j * 16, 16, 16, num10, 1, noBroadcast: true);
						item.position = Main.item[num11].position;
						Main.item[num11] = item;
						NetMessage.SendData(21, -1, -1, null, num11);
					}

					frameX2 = Main.tile[num7, j].frameX;
					int num12 = 0;
					while (frameX2 >= 5000) {
						frameX2 -= 5000;
						num12++;
					}

					if (num12 != 0)
						frameX2 = (num12 - 1) * 18;

					Main.tile[num7, j].frameX = (short)frameX2;
					Main.tile[num7 + 1, j].frameX = (short)(frameX2 + 18);
				}
			}

			if (tile.type == 395) {
				int num13 = TEItemFrame.Find(i - tile.frameX % 36 / 18, j - tile.frameY % 36 / 18);
				if (num13 != -1 && ((TEItemFrame)TileEntity.ByID[num13]).item.stack > 0) {
					((TEItemFrame)TileEntity.ByID[num13]).DropItem();
					if (Main.netMode != 2)
						Main.blockMouse = true;

					return;
				}
			}

			int num14 = KillTile_GetTileDustAmount(fail, tile, i, j);
			for (int l = 0; l < num14; l++) {
				KillTile_MakeTileDust(i, j, tile);
			}

			if (effectOnly)
				return;

			if (fail) {
				if (tile.type == 2 || tile.type == 23 || tile.type == 109 || tile.type == 199)
					tile.type = 0;

				if (tile.type == 60 || tile.type == 70)
					tile.type = 59;

				if (Main.tileMoss[tile.type])
					tile.type = 1;

				SquareTileFrame(i, j);
				return;
			}

			if (TileID.Sets.BasicChest[tile.type] && Main.netMode != 1) {
				int num15 = tile.frameX / 18;
				int y = j - tile.frameY / 18;
				while (num15 > 1) {
					num15 -= 2;
				}

				num15 = i - num15;
				if (!Chest.DestroyChest(num15, y))
					return;
			}

			if (TileLoader.IsDresser(tile.type) && Main.netMode != 1) {
				int num16 = tile.frameX / 18;
				int y2 = j - tile.frameY / 18;
				num16 %= 3;
				num16 = i - num16;
				if (!Chest.DestroyChest(num16, y2))
					return;
			}

			if (tile.type == 51 && tile.wall == 62 && genRand.Next(4) != 0)
				noItem = true;

			if (!noItem && !stopDrops && Main.netMode != 1) {
				bool flag = false;
				int num17 = -1;
				int num18 = -1;
				int num19 = -1;
				if (tile.type == 3) {
					num17 = 400;
					num18 = 100;
					if (tile.frameX >= 108) {
						num17 *= 3;
						num18 *= 3;
					}
				}

				if (tile.type == 73) {
					//patch file: num17, num18
					num17 = 200;
					num18 = 50;
					if (tile.frameX >= 108) {
						num17 *= 3;
						num18 *= 3;
					}
				}

				if (tile.type == 61) {
					num19 = 80;
					if (tile.frameX >= 108)
						num19 *= 3;
				}

				if (tile.type == 74) {
					num19 = 40;
					if (tile.frameX >= 108)
						num19 *= 3;
				}

				if (tile.type == 62)
					num19 = 250;

				if (tile.type == 185) {
					if (tile.frameY == 0 && tile.frameX < 214)
						num17 = 6;

					if (tile.frameY == 18 && (tile.frameX < 214 || tile.frameX >= 1368))
						num17 = 6;
				}
				else if (tile.type == 186) {
					if (tile.frameX >= 378 && tile.frameX <= 700)
						num17 = 6;
				}
				else if (tile.type == 187) {
					if (tile.frameX >= 756 && tile.frameX <= 916)
						num17 = 6;

					if (tile.frameX <= 322)
						num17 = 6;
				}
				else if (tile.type == 233) {
					num19 = 10;
				}

				TileLoader.DropCritterChance(i, j, tile.type, ref num17, ref num18, ref num19);
				if (num17 > 0 && NPC.CountNPCS(357) < 5 && genRand.Next(num17) == 0) {
					int type = 357;
					if (genRand.Next(NPC.goldCritterChance) == 0)
						type = 448;

					int num20 = NPC.NewNPC(i * 16 + 10, j * 16, type);
					Main.npc[num20].TargetClosest();
					Main.npc[num20].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
					Main.npc[num20].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num20].direction);
					Main.npc[num20].direction *= -1;
					Main.npc[num20].netUpdate = true;
				}

				if (num18 > 0 && NPC.CountNPCS(377) < 5 && genRand.Next(num18) == 0) {
					int type2 = 377;
					if (genRand.Next(NPC.goldCritterChance) == 0)
						type2 = 446;

					int num21 = NPC.NewNPC(i * 16 + 10, j * 16, type2);
					Main.npc[num21].TargetClosest();
					Main.npc[num21].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
					Main.npc[num21].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num21].direction);
					Main.npc[num21].direction *= -1;
					Main.npc[num21].netUpdate = true;
				}

				if (num19 > 0 && NPC.CountNPCS(485) + NPC.CountNPCS(486) + NPC.CountNPCS(487) < 8 && genRand.Next(num19) == 0) {
					int type3 = 485;
					if (genRand.Next(4) == 0)
						type3 = 486;

					if (genRand.Next(12) == 0)
						type3 = 487;

					int num22 = NPC.NewNPC(i * 16 + 10, j * 16, type3);
					Main.npc[num22].TargetClosest();
					Main.npc[num22].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
					Main.npc[num22].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num22].direction);
					Main.npc[num22].direction *= -1;
					Main.npc[num22].netUpdate = true;
				}

				int num23 = 0;
				int num24 = 0;
				if (tile.type == 0 || tile.type == 2 || tile.type == 109) {
					num23 = 2;
				}
				else if (tile.type == 426) {
					num23 = 3621;
				}
				else if (tile.type == 430) {
					num23 = 3633;
				}
				else if (tile.type == 431) {
					num23 = 3634;
				}
				else if (tile.type == 432) {
					num23 = 3635;
				}
				else if (tile.type == 433) {
					num23 = 3636;
				}
				else if (tile.type == 434) {
					num23 = 3637;
				}
				else if (tile.type == 427) {
					num23 = 3622;
				}
				else if (tile.type == 435) {
					num23 = 3638;
				}
				else if (tile.type == 436) {
					num23 = 3639;
				}
				else if (tile.type == 437) {
					num23 = 3640;
				}
				else if (tile.type == 438) {
					num23 = 3641;
				}
				else if (tile.type == 439) {
					num23 = 3642;
				}
				else if (tile.type == 446) {
					num23 = 3736;
				}
				else if (tile.type == 447) {
					num23 = 3737;
				}
				else if (tile.type == 448) {
					num23 = 3738;
				}
				else if (tile.type == 449) {
					num23 = 3739;
				}
				else if (tile.type == 450) {
					num23 = 3740;
				}
				else if (tile.type == 451) {
					num23 = 3741;
				}
				else if (tile.type == 368) {
					num23 = 3086;
				}
				else if (tile.type == 369) {
					num23 = 3087;
				}
				else if (tile.type == 367) {
					num23 = 3081;
				}
				else if (tile.type == 379) {
					num23 = 3214;
				}
				else if (tile.type == 353) {
					num23 = 2996;
				}
				else if (tile.type == 365) {
					num23 = 3077;
				}
				else if (tile.type == 366) {
					num23 = 3078;
				}
				else if ((tile.type == 52 || tile.type == 62) && genRand.Next(2) == 0 && Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)].cordage) {
					num23 = 2996;
				}
				else if (tile.type == 357) {
					num23 = 3066;
				}
				else if (tile.type == 1) {
					num23 = 3;
				}
				else if (tile.type == 3 || tile.type == 73) {
					if (genRand.Next(2) == 0 && (Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)].HasItem(281) || Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)].HasItem(986)))
						num23 = 283;
				}
				else if (tile.type == 227) {
					int num25 = tile.frameX / 34;
					num23 = 1107 + num25;
					if (num25 >= 8 && num25 <= 11)
						num23 = 3385 + num25 - 8;
				}
				else if (tile.type == 4) {
					int num26 = tile.frameY / 22;
					switch (num26) {
						case 0:
							num23 = 8;
							break;
						case 8:
							num23 = 523;
							break;
						case 9:
							num23 = 974;
							break;
						case 10:
							num23 = 1245;
							break;
						case 11:
							num23 = 1333;
							break;
						case 12:
							num23 = 2274;
							break;
						case 13:
							num23 = 3004;
							break;
						case 14:
							num23 = 3045;
							break;
						case 15:
							num23 = 3114;
							break;
						default:
							num23 = 426 + num26;
							break;
					}
				}
				else if (tile.type == 239) {
					int num27 = tile.frameX / 18;
					if (num27 == 0)
						num23 = 20;

					if (num27 == 1)
						num23 = 703;

					if (num27 == 2)
						num23 = 22;

					if (num27 == 3)
						num23 = 704;

					if (num27 == 4)
						num23 = 21;

					if (num27 == 5)
						num23 = 705;

					if (num27 == 6)
						num23 = 19;

					if (num27 == 7)
						num23 = 706;

					if (num27 == 8)
						num23 = 57;

					if (num27 == 9)
						num23 = 117;

					if (num27 == 10)
						num23 = 175;

					if (num27 == 11)
						num23 = 381;

					if (num27 == 12)
						num23 = 1184;

					if (num27 == 13)
						num23 = 382;

					if (num27 == 14)
						num23 = 1191;

					if (num27 == 15)
						num23 = 391;

					if (num27 == 16)
						num23 = 1198;

					if (num27 == 17)
						num23 = 1006;

					if (num27 == 18)
						num23 = 1225;

					if (num27 == 19)
						num23 = 1257;

					if (num27 == 20)
						num23 = 1552;

					if (num27 == 21)
						num23 = 3261;

					if (num27 == 22)
						num23 = 3467;
				}
				else if (tile.type == 380) {
					int num28 = tile.frameY / 18;
					num23 = 3215 + num28;
				}
				else if (tile.type == 442) {
					num23 = 3707;
				}
				else if (tile.type == 383) {
					num23 = 620;
				}
				else if (tile.type == 315) {
					num23 = 2435;
				}
				else if (tile.type == 330) {
					num23 = 71;
				}
				else if (tile.type == 331) {
					num23 = 72;
				}
				else if (tile.type == 332) {
					num23 = 73;
				}
				else if (tile.type == 333) {
					num23 = 74;
				}
				else if (tile.type == 5) {
					if (tile.frameX >= 22 && tile.frameY >= 198) {
						if (Main.netMode != 1) {
							if (genRand.Next(2) == 0) {
								int m;
								for (m = j; Main.tile[i, m] != null && (!Main.tile[i, m].active() || !Main.tileSolid[Main.tile[i, m].type] || Main.tileSolidTop[Main.tile[i, m].type]); m++) {
								}

								if (Main.tile[i, m] != null) {
									if (Main.tile[i, m].type == 2 || Main.tile[i, m].type == 109 || Main.tile[i, m].type == 147 || Main.tile[i, m].type == 199 || Main.tile[i, m].type == 23 || TileLoader.CanDropAcorn(Main.tile[i, m].type)) {
										num23 = 9;
										num24 = 27;
									}
									else {
										num23 = 9;
									}
								}
							}
							else {
								num23 = 9;
							}
						}
					}
					else {
						num23 = 9;
					}

					if (num23 == 9) {
						int num29 = i;
						int n = j;
						if (tile.frameX == 66 && tile.frameY <= 45)
							num29++;

						if (tile.frameX == 88 && tile.frameY >= 66 && tile.frameY <= 110)
							num29--;

						if (tile.frameX == 22 && tile.frameY >= 132 && tile.frameY <= 176)
							num29--;

						if (tile.frameX == 44 && tile.frameY >= 132 && tile.frameY <= 176)
							num29++;

						if (tile.frameX == 44 && tile.frameY >= 198)
							num29++;

						if (tile.frameX == 66 && tile.frameY >= 198)
							num29--;

						for (; !Main.tile[num29, n].active() || !Main.tileSolid[Main.tile[num29, n].type]; n++) {
						}

						if (Main.tile[num29, n].active()) {
							switch (Main.tile[num29, n].type) {
								case 23:
									num23 = 619;
									break;
								case 60:
									num23 = 620;
									break;
								case 109:
									num23 = 621;
									break;
								case 199:
									num23 = 911;
									break;
								case 70:
									num23 = 183;
									break;
								case 147:
									num23 = 2503;
									break;
							}
							TileLoader.DropTreeWood(Main.tile[num29, n].type, ref num23);
						}

						int num30 = Player.FindClosest(new Vector2(num29 * 16, n * 16), 16, 16);
						int axe = Main.player[num30].inventory[Main.player[num30].selectedItem].axe;
						if (genRand.Next(100) < axe || Main.rand.Next(3) == 0)
							flag = true;
					}
				}
				else if (tile.type == 323) {
					num23 = 2504;
					if (tile.frameX <= 132 && tile.frameX >= 88)
						num24 = 27;

					int num31;
					for (num31 = j; !Main.tile[i, num31].active() || !Main.tileSolid[Main.tile[i, num31].type]; num31++) {
					}

					if (Main.tile[i, num31].active()) {
						switch (Main.tile[i, num31].type) {
							case 234:
								num23 = 911;
								break;
							case 116:
								num23 = 621;
								break;
							case 112:
								num23 = 619;
								break;
						}
						TileLoader.DropPalmTreeWood(Main.tile[i, num31].type, ref num23);
					}
				}
				else if (tile.type == 408) {
					num23 = 3460;
				}
				else if (tile.type == 409) {
					num23 = 3461;
				}
				else if (tile.type == 415) {
					num23 = 3573;
				}
				else if (tile.type == 416) {
					num23 = 3574;
				}
				else if (tile.type == 417) {
					num23 = 3575;
				}
				else if (tile.type == 418) {
					num23 = 3576;
				}
				else if (tile.type >= 255 && tile.type <= 261) {
					num23 = 1970 + tile.type - 255;
				}
				else if (tile.type >= 262 && tile.type <= 268) {
					num23 = 1970 + tile.type - 262;
				}
				else if (tile.type == 171) {
					if (tile.frameX >= 10) {
						dropXmasTree(i, j, 0);
						dropXmasTree(i, j, 1);
						dropXmasTree(i, j, 2);
						dropXmasTree(i, j, 3);
					}
				}
				else if (tile.type == 324) {
					switch (tile.frameY / 22) {
						case 0:
							num23 = 2625;
							break;
						case 1:
							num23 = 2626;
							break;
					}
				}
				else if (tile.type == 421) {
					num23 = 3609;
				}
				else if (tile.type == 422) {
					num23 = 3610;
				}
				else if (tile.type == 419) {
					switch (tile.frameX / 18) {
						case 0:
							num23 = 3602;
							break;
						case 1:
							num23 = 3618;
							break;
						case 2:
							num23 = 3663;
							break;
					}
				}
				else if (tile.type == 428) {
					switch (tile.frameY / 18) {
						case 0:
							num23 = 3630;
							break;
						case 1:
							num23 = 3632;
							break;
						case 2:
							num23 = 3631;
							break;
						case 3:
							num23 = 3626;
							break;
					}

					PressurePlateHelper.DestroyPlate(new Point(i, j));
				}
				else if (tile.type == 420) {
					switch (tile.frameY / 18) {
						case 0:
							num23 = 3603;
							break;
						case 1:
							num23 = 3604;
							break;
						case 2:
							num23 = 3605;
							break;
						case 3:
							num23 = 3606;
							break;
						case 4:
							num23 = 3607;
							break;
						case 5:
							num23 = 3608;
							break;
					}
				}
				else if (tile.type == 423) {
					TELogicSensor.Kill(i, j);
					switch (tile.frameY / 18) {
						case 0:
							num23 = 3613;
							break;
						case 1:
							num23 = 3614;
							break;
						case 2:
							num23 = 3615;
							break;
						case 3:
							num23 = 3726;
							break;
						case 4:
							num23 = 3727;
							break;
						case 5:
							num23 = 3728;
							break;
						case 6:
							num23 = 3729;
							break;
					}
				}
				else if (tile.type == 424) {
					num23 = 3616;
				}
				else if (tile.type == 445) {
					num23 = 3725;
				}
				else if (tile.type == 429) {
					num23 = 3629;
				}
				else if (tile.type == 272) {
					num23 = 1344;
				}
				else if (tile.type == 273) {
					num23 = 2119;
				}
				else if (tile.type == 274) {
					num23 = 2120;
				}
				else if (tile.type == 460) {
					num23 = 3756;
				}
				else if (tile.type == 326) {
					num23 = 2693;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 327) {
					num23 = 2694;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 458) {
					num23 = 3754;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 459) {
					num23 = 3755;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 345) {
					num23 = 2787;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 328) {
					num23 = 2695;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 329) {
					num23 = 2697;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 346) {
					num23 = 2792;
				}
				else if (tile.type == 347) {
					num23 = 2793;
				}
				else if (tile.type == 348) {
					num23 = 2794;
				}
				else if (tile.type == 350) {
					num23 = 2860;
				}
				else if (tile.type == 336) {
					num23 = 2701;
				}
				else if (tile.type == 340) {
					num23 = 2751;
				}
				else if (tile.type == 341) {
					num23 = 2752;
				}
				else if (tile.type == 342) {
					num23 = 2753;
				}
				else if (tile.type == 343) {
					num23 = 2754;
				}
				else if (tile.type == 344) {
					num23 = 2755;
				}
				else if (tile.type == 351) {
					num23 = 2868;
				}
				else if (tile.type == 251) {
					num23 = 1725;
				}
				else if (tile.type == 252) {
					num23 = 1727;
				}
				else if (tile.type == 253) {
					num23 = 1729;
				}
				else if (tile.type == 325) {
					num23 = 2692;
				}
				else if (tile.type == 370) {
					num23 = 3100;
				}
				else if (tile.type == 396) {
					num23 = 3271;
				}
				else if (tile.type == 400) {
					num23 = 3276;
				}
				else if (tile.type == 401) {
					num23 = 3277;
				}
				else if (tile.type == 403) {
					num23 = 3339;
				}
				else if (tile.type == 397) {
					num23 = 3272;
				}
				else if (tile.type == 398) {
					num23 = 3274;
				}
				else if (tile.type == 399) {
					num23 = 3275;
				}
				else if (tile.type == 402) {
					num23 = 3338;
				}
				else if (tile.type == 404) {
					num23 = 3347;
				}
				else if (tile.type == 407) {
					num23 = 3380;
				}
				else if (tile.type == 170) {
					num23 = 1872;
				}
				else if (tile.type == 284) {
					num23 = 2173;
				}
				else if (tile.type == 214) {
					num23 = 85;
				}
				else if (tile.type == 213) {
					num23 = 965;
				}
				else if (tile.type == 211) {
					num23 = 947;
				}
				else if (tile.type == 6) {
					num23 = 11;
				}
				else if (tile.type == 7) {
					num23 = 12;
				}
				else if (tile.type == 8) {
					num23 = 13;
				}
				else if (tile.type == 9) {
					num23 = 14;
				}
				else if (tile.type == 202) {
					num23 = 824;
				}
				else if (tile.type == 234) {
					num23 = 1246;
				}
				else if (tile.type == 226) {
					num23 = 1101;
				}
				else if (tile.type == 224) {
					num23 = 1103;
				}
				else if (tile.type == 36) {
					num23 = 1869;
				}
				else if (tile.type == 311) {
					num23 = 2260;
				}
				else if (tile.type == 312) {
					num23 = 2261;
				}
				else if (tile.type == 313) {
					num23 = 2262;
				}
				else if (tile.type == 229) {
					num23 = 1125;
				}
				else if (tile.type == 230) {
					num23 = 1127;
				}
				else if (tile.type == 225) {
					if (genRand.Next(3) == 0) {
						tile.honey(honey: true);
						tile.liquid = byte.MaxValue;
					}
					else {
						num23 = 1124;
						if (Main.netMode != 1 && genRand.Next(2) == 0) {
							int num32 = 1;
							if (genRand.Next(3) == 0)
								num32 = 2;

							for (int num33 = 0; num33 < num32; num33++) {
								int type4 = genRand.Next(210, 212);
								int num34 = NPC.NewNPC(i * 16 + 8, j * 16 + 15, type4, 1);
								Main.npc[num34].velocity.X = (float)genRand.Next(-200, 201) * 0.002f;
								Main.npc[num34].velocity.Y = (float)genRand.Next(-200, 201) * 0.002f;
								Main.npc[num34].netUpdate = true;
							}
						}
					}
				}
				else if (tile.type == 221) {
					num23 = 1104;
				}
				else if (tile.type == 222) {
					num23 = 1105;
				}
				else if (tile.type == 223) {
					num23 = 1106;
				}
				else if (tile.type == 248) {
					num23 = 1589;
				}
				else if (tile.type == 249) {
					num23 = 1591;
				}
				else if (tile.type == 250) {
					num23 = 1593;
				}
				else if (tile.type == 191) {
					num23 = 9;
				}
				else if (tile.type == 203) {
					num23 = 836;
				}
				else if (tile.type == 204) {
					num23 = 880;
				}
				else if (tile.type == 166) {
					num23 = 699;
				}
				else if (tile.type == 167) {
					num23 = 700;
				}
				else if (tile.type == 168) {
					num23 = 701;
				}
				else if (tile.type == 169) {
					num23 = 702;
				}
				else if (tile.type == 123) {
					num23 = 424;
				}
				else if (tile.type == 124) {
					num23 = 480;
				}
				else if (tile.type == 157) {
					num23 = 619;
				}
				else if (tile.type == 158) {
					num23 = 620;
				}
				else if (tile.type == 159) {
					num23 = 621;
				}
				else if (tile.type == 161) {
					num23 = 664;
				}
				else if (tile.type == 206) {
					num23 = 883;
				}
				else if (tile.type == 232) {
					num23 = 1150;
				}
				else if (tile.type == 198) {
					num23 = 775;
				}
				else if (tile.type == 314) {
					num23 = Minecart.GetTrackItem(tile);
				}
				else if (tile.type == 189) {
					num23 = 751;
				}
				else if (tile.type == 195) {
					num23 = 763;
				}
				else if (tile.type == 194) {
					num23 = 766;
				}
				else if (tile.type == 193) {
					num23 = 762;
				}
				else if (tile.type == 196) {
					num23 = 765;
				}
				else if (tile.type == 197) {
					num23 = 767;
				}
				else if (tile.type == 178) {
					switch (tile.frameX / 18) {
						case 0:
							num23 = 181;
							break;
						case 1:
							num23 = 180;
							break;
						case 2:
							num23 = 177;
							break;
						case 3:
							num23 = 179;
							break;
						case 4:
							num23 = 178;
							break;
						case 5:
							num23 = 182;
							break;
						case 6:
							num23 = 999;
							break;
					}
				}
				else if (tile.type == 149) {
					if (tile.frameX == 0 || tile.frameX == 54)
						num23 = 596;
					else if (tile.frameX == 18 || tile.frameX == 72)
						num23 = 597;
					else if (tile.frameX == 36 || tile.frameX == 90)
						num23 = 598;
				}
				else if (tile.type == 13) {
					Main.PlaySound(13, i * 16, j * 16);
					switch (tile.frameX / 18) {
						case 1:
							num23 = 28;
							break;
						case 2:
							num23 = 110;
							break;
						case 3:
							num23 = 350;
							break;
						case 4:
							num23 = 351;
							break;
						case 5:
							num23 = 2234;
							break;
						case 6:
							num23 = 2244;
							break;
						case 7:
							num23 = 2257;
							break;
						case 8:
							num23 = 2258;
							break;
						default:
							num23 = 31;
							break;
					}
				}
				else if (tile.type == 19) {
					int num35 = tile.frameY / 18;
					switch (num35) {
						case 0:
							num23 = 94;
							break;
						case 1:
							num23 = 631;
							break;
						case 2:
							num23 = 632;
							break;
						case 3:
							num23 = 633;
							break;
						case 4:
							num23 = 634;
							break;
						case 5:
							num23 = 913;
							break;
						case 6:
							num23 = 1384;
							break;
						case 7:
							num23 = 1385;
							break;
						case 8:
							num23 = 1386;
							break;
						case 9:
							num23 = 1387;
							break;
						case 10:
							num23 = 1388;
							break;
						case 11:
							num23 = 1389;
							break;
						case 12:
							num23 = 1418;
							break;
						case 13:
							num23 = 1457;
							break;
						case 14:
							num23 = 1702;
							break;
						case 15:
							num23 = 1796;
							break;
						case 16:
							num23 = 1818;
							break;
						case 17:
							num23 = 2518;
							break;
						case 18:
							num23 = 2549;
							break;
						case 19:
							num23 = 2566;
							break;
						case 20:
							num23 = 2581;
							break;
						case 21:
							num23 = 2627;
							break;
						case 22:
							num23 = 2628;
							break;
						case 23:
							num23 = 2629;
							break;
						case 24:
							num23 = 2630;
							break;
						case 25:
							num23 = 2744;
							break;
						case 26:
							num23 = 2822;
							break;
						case 27:
							num23 = 3144;
							break;
						case 28:
							num23 = 3146;
							break;
						case 29:
							num23 = 3145;
							break;
						case 30:
						case 31:
						case 32:
						case 33:
						case 34:
						case 35:
							num23 = 3903 + num35 - 30;
							break;
					}
				}
				else if (tile.type == 22) {
					num23 = 56;
				}
				else if (tile.type == 140) {
					num23 = 577;
				}
				else if (tile.type == 23) {
					num23 = 2;
				}
				else if (tile.type == 25) {
					num23 = 61;
				}
				else if (tile.type == 30) {
					num23 = 9;
				}
				else if (tile.type == 191) {
					num23 = 9;
				}
				else if (tile.type == 208) {
					num23 = 911;
				}
				else if (tile.type == 33) {
					int num36 = tile.frameY / 22;
					num23 = 105;
					switch (num36) {
						case 1:
							num23 = 1405;
							break;
						case 2:
							num23 = 1406;
							break;
						case 3:
							num23 = 1407;
							break;
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						case 9:
						case 10:
						case 11:
						case 12:
						case 13:
							num23 = 2045 + num36 - 4;
							break;
						default:
							if (num36 >= 14 && num36 <= 16) {
								num23 = 2153 + num36 - 14;
								break;
							}
							switch (num36) {
								case 17:
									num23 = 2236;
									break;
								case 18:
									num23 = 2523;
									break;
								case 19:
									num23 = 2542;
									break;
								case 20:
									num23 = 2556;
									break;
								case 21:
									num23 = 2571;
									break;
								case 22:
									num23 = 2648;
									break;
								case 23:
									num23 = 2649;
									break;
								case 24:
									num23 = 2650;
									break;
								case 25:
									num23 = 2651;
									break;
								case 26:
									num23 = 2818;
									break;
								case 27:
									num23 = 3171;
									break;
								case 28:
									num23 = 3173;
									break;
								case 29:
									num23 = 3172;
									break;
								case 30:
									num23 = 3890;
									break;
							}
							break;
					}
				}
				else if (tile.type == 372) {
					num23 = 3117;
				}
				else if (tile.type == 371) {
					num23 = 3113;
				}
				else if (tile.type == 174) {
					num23 = 713;
				}
				else if (tile.type == 37) {
					num23 = 116;
				}
				else if (tile.type == 38) {
					num23 = 129;
				}
				else if (tile.type == 39) {
					num23 = 131;
				}
				else if (tile.type == 40) {
					num23 = 133;
				}
				else if (tile.type == 41) {
					num23 = 134;
				}
				else if (tile.type == 43) {
					num23 = 137;
				}
				else if (tile.type == 44) {
					num23 = 139;
				}
				else if (tile.type == 45) {
					num23 = 141;
				}
				else if (tile.type == 46) {
					num23 = 143;
				}
				else if (tile.type == 47) {
					num23 = 145;
				}
				else if (tile.type == 48) {
					num23 = 147;
				}
				else if (tile.type == 49) {
					num23 = 148;
				}
				else if (tile.type == 51) {
					num23 = 150;
				}
				else if (tile.type == 53) {
					num23 = 169;
				}
				else if (tile.type == 151) {
					num23 = 607;
				}
				else if (tile.type == 152) {
					num23 = 609;
				}
				else if (tile.type == 54) {
					num23 = 170;
					Main.PlaySound(13, i * 16, j * 16);
				}
				else if (tile.type == 56) {
					num23 = 173;
				}
				else if (tile.type == 57) {
					num23 = 172;
				}
				else if (tile.type == 58) {
					num23 = 174;
				}
				else if (tile.type == 60) {
					num23 = 176;
				}
				else if (tile.type == 70) {
					num23 = 176;
				}
				else if (tile.type == 75) {
					num23 = 192;
				}
				else if (tile.type == 76) {
					num23 = 214;
				}
				else if (tile.type == 78) {
					num23 = 222;
				}
				else if (tile.type == 81) {
					num23 = 275;
				}
				else if (tile.type == 80) {
					num23 = 276;
				}
				else if (tile.type == 188) {
					num23 = 276;
				}
				else if (tile.type == 107) {
					num23 = 364;
				}
				else if (tile.type == 108) {
					num23 = 365;
				}
				else if (tile.type == 111) {
					num23 = 366;
				}
				else if (tile.type == 150) {
					num23 = 604;
				}
				else if (tile.type == 112) {
					num23 = 370;
				}
				else if (tile.type == 116) {
					num23 = 408;
				}
				else if (tile.type == 117) {
					num23 = 409;
				}
				else if (tile.type == 129) {
					num23 = 502;
				}
				else if (tile.type == 118) {
					num23 = 412;
				}
				else if (tile.type == 119) {
					num23 = 413;
				}
				else if (tile.type == 120) {
					num23 = 414;
				}
				else if (tile.type == 121) {
					num23 = 415;
				}
				else if (tile.type == 122) {
					num23 = 416;
				}
				else if (tile.type == 136) {
					num23 = 538;
				}
				else if (tile.type == 385) {
					num23 = 3234;
				}
				else if (tile.type == 137) {
					int num37 = tile.frameY / 18;
					if (num37 == 0)
						num23 = 539;

					if (num37 == 1)
						num23 = 1146;

					if (num37 == 2)
						num23 = 1147;

					if (num37 == 3)
						num23 = 1148;

					if (num37 == 4)
						num23 = 1149;
				}
				else if (tile.type == 141) {
					num23 = 580;
				}
				else if (tile.type == 145) {
					num23 = 586;
				}
				else if (tile.type == 146) {
					num23 = 591;
				}
				else if (tile.type == 147) {
					num23 = 593;
				}
				else if (tile.type == 148) {
					num23 = 594;
				}
				else if (tile.type == 153) {
					num23 = 611;
				}
				else if (tile.type == 154) {
					num23 = 612;
				}
				else if (tile.type == 155) {
					num23 = 613;
				}
				else if (tile.type == 156) {
					num23 = 614;
				}
				else if (tile.type == 160) {
					num23 = 662;
				}
				else if (tile.type == 175) {
					num23 = 717;
				}
				else if (tile.type == 176) {
					num23 = 718;
				}
				else if (tile.type == 177) {
					num23 = 719;
				}
				else if (tile.type == 163) {
					num23 = 833;
				}
				else if (tile.type == 164) {
					num23 = 834;
				}
				else if (tile.type == 200) {
					num23 = 835;
				}
				else if (tile.type == 210) {
					num23 = 937;
				}
				else if (tile.type == 135) {
					int num38 = tile.frameY / 18;
					if (num38 == 0)
						num23 = 529;

					if (num38 == 1)
						num23 = 541;

					if (num38 == 2)
						num23 = 542;

					if (num38 == 3)
						num23 = 543;

					if (num38 == 4)
						num23 = 852;

					if (num38 == 5)
						num23 = 853;

					if (num38 == 6)
						num23 = 1151;
				}
				else if (tile.type == 144) {
					if (tile.frameX == 0)
						num23 = 583;

					if (tile.frameX == 18)
						num23 = 584;

					if (tile.frameX == 36)
						num23 = 585;
				}
				else if (tile.type == 130) {
					num23 = 511;
				}
				else if (tile.type == 131) {
					num23 = 512;
				}
				else if (tile.type == 61 || tile.type == 74) {
					if (tile.frameX == 144 && tile.type == 61)
						Item.NewItem(i * 16, j * 16, 16, 16, 331, genRand.Next(2, 4));
					else if (tile.frameX == 162 && tile.type == 61)
						num23 = 223;
					else if (tile.frameX >= 108 && tile.frameX <= 126 && tile.type == 61 && genRand.Next(20) == 0)
						num23 = 208;
					else if (genRand.Next(100) == 0)
						num23 = 195;
				}
				else if (tile.type == 59 || tile.type == 60) {
					num23 = 176;
				}
				else if (tile.type == 190) {
					num23 = 183;
				}
				else if (tile.type == 71 || tile.type == 72) {
					if (genRand.Next(50) == 0)
						num23 = 194;
					else if (genRand.Next(2) == 0)
						num23 = 183;
				}
				else if (tile.type >= 63 && tile.type <= 68) {
					num23 = tile.type - 63 + 177;
				}
				else if (tile.type == 50) {
					num23 = ((tile.frameX != 90) ? 149 : 165);
				}
				else if (Main.tileAlch[tile.type]) {
					if (tile.type > 82) {
						int num39 = tile.frameX / 18;
						bool flag2 = false;
						num23 = 313 + num39;
						int type5 = 307 + num39;
						if (tile.type == 84)
							flag2 = true;

						if (num39 == 0 && Main.dayTime)
							flag2 = true;

						if (num39 == 1 && !Main.dayTime)
							flag2 = true;

						if (num39 == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
							flag2 = true;

						if (num39 == 4 && (Main.raining || Main.cloudAlpha > 0f))
							flag2 = true;

						if (num39 == 5 && !Main.raining && Main.dayTime && Main.time > 40500.0)
							flag2 = true;

						if (num39 == 6) {
							num23 = 2358;
							type5 = 2357;
						}

						int num40 = Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16);
						if (Main.player[num40].inventory[Main.player[num40].selectedItem].type == 213) {
							Item.NewItem(i * 16, j * 16, 16, 16, type5, genRand.Next(1, 6));
							Item.NewItem(i * 16, j * 16, 16, 16, num23, genRand.Next(1, 3));
							num23 = -1;
						}
						else if (flag2) {
							int stack = genRand.Next(1, 4);
							Item.NewItem(i * 16, j * 16, 16, 16, type5, stack);
						}
					}
				}
				else if (tile.type == 321) {
					num23 = 2503;
				}
				else if (tile.type == 322) {
					num23 = 2504;
				}

				bool vanillaDrop = TileLoader.Drop(i, j, tile.type);
				if (vanillaDrop && num23 > 0) {
					int num41 = 1;
					if (flag)
						num41++;

					Item.NewItem(i * 16, j * 16, 16, 16, num23, num41, noBroadcast: false, -1);
				}

				if (vanillaDrop && num24 > 0)
					Item.NewItem(i * 16, j * 16, 16, 16, num24, 1, noBroadcast: false, -1);
			}

			if (Main.netMode != 2)
				AchievementsHelper.NotifyTileDestroyed(Main.player[Main.myPlayer], tile.type);

			tile.active(active: false);
			tile.halfBrick(halfBrick: false);
			tile.frameX = -1;
			tile.frameY = -1;
			tile.color(0);
			tile.frameNumber(0);
			if (tile.type == 58 && j > Main.maxTilesY - 200) {
				tile.lava(lava: true);
				tile.liquid = 128;
			}
			else if (tile.type == 419) {
				Wiring.PokeLogicGate(i, j + 1);
			}
			else if (tile.type == 54) {
				SquareWallFrame(i, j);
			}

			tile.type = 0;
			tile.inActive(inActive: false);
			SquareTileFrame(i, j);
		}

		public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache, int i, int j) {
			int result = 10;
			if (tileCache.type == 231)
				result = 6;

			if (fail)
				result = 3;

			if (tileCache.type == 138)
				result = 0;

			if (tileCache.type == 373)
				result = 0;

			if (tileCache.type == 374)
				result = 0;

			if (tileCache.type == 375)
				result = 0;

			if (tileCache.type == 461)
				result = 0;

			if (tileCache.type >= 300 && tileCache.type <= 308)
				result = 0;

			if (tileCache.type == 125)
				result = 0;

			if (tileCache.type == 287)
				result = 0;

			if (tileCache.type == 354)
				result = 0;

			if (tileCache.type == 355)
				result = 0;

			if (tileCache.type == 376)
				result = 0;

			TileLoader.NumDust(i, j, tileCache.type, fail, ref result);
			return result;
		}

		public static int KillTile_MakeTileDust(int i, int j, Tile tileCache) {
			int num = 0;
			if (tileCache.type == 216)
				num = -1;

			if (tileCache.type == 335)
				num = -1;

			if (tileCache.type == 338)
				num = -1;

			if (tileCache.type == 0)
				num = 0;

			if (tileCache.type == 192)
				num = 3;

			if (tileCache.type == 208)
				num = 126;
			else if (tileCache.type == 408 || tileCache.type == 409)
				num = 265;

			if (tileCache.type == 16) {
				num = 1;
				if (tileCache.frameX >= 36)
					num = 82;
			}
			else if (tileCache.type == 415) {
				num = 6;
			}
			else if (tileCache.type == 416) {
				num = 61;
			}
			else if (tileCache.type == 417) {
				num = 242;
			}
			else if (tileCache.type == 418) {
				num = 135;
			}

			if (tileCache.type == 1 || tileCache.type == 17 || tileCache.type == 38 || tileCache.type == 39 || tileCache.type == 41 || tileCache.type == 43 || tileCache.type == 44 || tileCache.type == 48 || Main.tileStone[tileCache.type] || tileCache.type == 85 || tileCache.type == 90 || tileCache.type == 92 || tileCache.type == 96 || tileCache.type == 97 || tileCache.type == 99 || tileCache.type == 117 || tileCache.type == 130 || tileCache.type == 131 || tileCache.type == 132 || tileCache.type == 135 || tileCache.type == 135 || tileCache.type == 142 || tileCache.type == 143 || tileCache.type == 144 || tileCache.type == 210 || tileCache.type == 207 || tileCache.type == 235 || tileCache.type == 247 || tileCache.type == 272 || tileCache.type == 273 || tileCache.type == 283 || tileCache.type == 410)
				num = 1;

			if (tileCache.type == 379)
				num = 257;

			if (tileCache.type == 311)
				num = 207;

			if (tileCache.type == 312)
				num = 208;

			if (tileCache.type == 313)
				num = 209;

			if (tileCache.type == 104)
				num = -1;

			if (tileCache.type == 95 || tileCache.type == 98 || tileCache.type == 100 || tileCache.type == 174 || tileCache.type == 173)
				num = 6;

			if (tileCache.type == 30 || tileCache.type == 86 || tileCache.type == 94 || tileCache.type == 106 || tileCache.type == 114 || tileCache.type == 124 || tileCache.type == 128 || tileCache.type == 269)
				num = 7;

			if (tileCache.type == 372)
				num = 242;

			if (tileCache.type == 371)
				num = 243;

			if (tileCache.type == 334)
				num = 7;

			switch (tileCache.type) {
				case 10:
				case 11:
				case 87:
				case 89:
				case 93:
				case 139:
				case 209:
				case 319:
				case 320:
				case 386:
				case 387:
				case 390:
				case 405:
				case 406:
				case 411:
				case 412:
				case 419:
				case 420:
				case 421:
				case 422:
				case 423:
				case 424:
				case 425:
				case 428:
				case 429:
				case 441:
				case 442:
				case 445:
				case 446:
				case 447:
				case 448:
				case 449:
				case 450:
				case 451:
				case 452:
				case 453:
				case 455:
				case 456:
				case 457:
				case 462:
				case 463:
				case 464:
				case 465:
				case 466:
				case 468:
					num = -1;
					break;
				case 407:
					num = 10;
					break;
				case 454:
					num = 139;
					break;
			}

			if (tileCache.type == 240) {
				int num2 = tileCache.frameX / 54;
				if (tileCache.frameY >= 54)
					num2 += 36;

				num = 7;
				if (num2 == 16 || num2 == 17)
					num = 26;

				if (num2 >= 46 && num2 <= 49)
					num = -1;
			}

			if (tileCache.type == 241)
				num = 1;

			if (tileCache.type == 242)
				num = -1;

			if (tileCache.type == 356)
				num = -1;

			if (tileCache.type == 351)
				num = -1;

			if (tileCache.type == 246)
				num = -1;

			if (tileCache.type == 36)
				num = -1;

			if (tileCache.type == 365)
				num = 239;

			if (tileCache.type == 366)
				num = 30;

			if (tileCache.type == 357 || tileCache.type == 367)
				num = 236;

			if (tileCache.type == 368 || tileCache.type == 369)
				num = 240;

			if (tileCache.type == 170)
				num = 196;

			if (tileCache.type == 315)
				num = 225;

			if (tileCache.type == 346)
				num = 128;

			if (tileCache.type == 347)
				num = 117;

			if (tileCache.type == 348)
				num = 42;

			if (tileCache.type == 350)
				num = 226;

			if (tileCache.type == 370)
				num = ((genRand.Next(2) != 0) ? 23 : 6);

			if (tileCache.type == 171)
				num = ((genRand.Next(2) != 0) ? (-1) : 196);

			if (tileCache.type == 326)
				num = 13;

			if (tileCache.type == 327)
				num = 13;

			if (tileCache.type == 345)
				num = 13;

			if (tileCache.type == 458)
				num = 13;

			if (tileCache.type == 459)
				num = 13;

			if (tileCache.type == 336)
				num = 6;

			if (tileCache.type == 340)
				num = 75;

			if (tileCache.type == 341)
				num = 65;

			if (tileCache.type == 342)
				num = 135;

			if (tileCache.type == 343)
				num = 169;

			if (tileCache.type == 344)
				num = 156;

			if (tileCache.type == 328)
				num = 13;

			if (tileCache.type == 329)
				num = 13;

			if (tileCache.type == 330)
				num = 9;

			if (tileCache.type == 331)
				num = 11;

			if (tileCache.type == 332)
				num = 19;

			if (tileCache.type == 333)
				num = 11;

			if (tileCache.type == 101)
				num = -1;

			if (tileCache.type == 19) {
				int num3 = tileCache.frameY / 18;
				switch (num3) {
					case 0:
					case 9:
					case 10:
					case 11:
					case 12:
						num = 7;
						break;
					case 1:
						num = 77;
						break;
					case 2:
						num = 78;
						break;
					case 3:
						num = 79;
						break;
					case 4:
						num = 26;
						break;
					case 5:
						num = 126;
						break;
					case 13:
						num = 109;
						break;
					case 14:
						num = 13;
						break;
					case 15:
					case 16:
						num = -1;
						break;
					default:
						switch (num3) {
							case 17:
								num = 215;
								break;
							case 18:
								num = 214;
								break;
							case 19:
								num = 214;
								break;
							case 20:
								num = 4;
								break;
							case 21:
								num = 1;
								break;
							case 22:
								num = 8;
								break;
							case 23:
								num = 78;
								break;
							case 24:
								num = 147;
								break;
							case 25:
								num = 40;
								break;
							case 26:
								num = 226;
								break;
							case 27:
								num = 23;
								break;
							case 28:
								num = 240;
								break;
							case 29:
								num = 236;
								break;
							case 30:
								num = 68 + Main.rand.Next(3);
								break;
							case 31:
								num = 10;
								break;
							case 32:
								num = 78;
								break;
							case 33:
								num = 148;
								break;
							case 34:
								num = 5;
								break;
							case 35:
								num = 80;
								break;
							default:
								num = 1;
								break;
						}
						break;
				}
			}

			if (tileCache.type == 79) {
				int num4 = tileCache.frameY / 36;
				num = ((num4 == 0) ? 7 : ((num4 == 1) ? 77 : ((num4 == 2) ? 78 : ((num4 == 3) ? 79 : ((num4 == 4) ? 126 : ((num4 == 8) ? 109 : ((num4 < 9) ? 1 : (-1))))))));
			}

			if (tileCache.type == 18) {
				switch (tileCache.frameX / 36) {
					case 0:
						num = 7;
						break;
					case 1:
						num = 77;
						break;
					case 2:
						num = 78;
						break;
					case 3:
						num = 79;
						break;
					case 4:
						num = 26;
						break;
					case 5:
						num = 40;
						break;
					case 6:
						num = 5;
						break;
					case 7:
						num = 26;
						break;
					case 8:
						num = 4;
						break;
					case 9:
						num = 126;
						break;
					case 10:
						num = 148;
						break;
					case 11:
					case 12:
					case 13:
						num = 1;
						break;
					case 14:
						num = 109;
						break;
					case 15:
						num = 126;
						break;
					default:
						num = -1;
						break;
				}
			}

			if (tileCache.type == 14 || tileCache.type == 87 || tileCache.type == 88)
				num = -1;

			if (tileCache.type >= 255 && tileCache.type <= 261) {
				int num5 = tileCache.type - 255;
				num = 86 + num5;
				if (num5 == 6)
					num = 138;
			}

			if (tileCache.type >= 262 && tileCache.type <= 268) {
				int num6 = tileCache.type - 262;
				num = 86 + num6;
				if (num6 == 6)
					num = 138;
			}

			if (tileCache.type == 178) {
				int num7 = tileCache.frameX / 18;
				num = 86 + num7;
				if (num7 == 6)
					num = 138;
			}

			if (tileCache.type == 440) {
				switch (tileCache.frameX / 54) {
					case 0:
						num = 90;
						break;
					case 1:
						num = 88;
						break;
					case 2:
						num = 89;
						break;
					case 3:
						num = 87;
						break;
					case 4:
						num = 86;
						break;
					case 5:
						num = 91;
						break;
					case 6:
						num = 138;
						break;
					default:
						num = -1;
						break;
				}

				if (tileCache.frameY < 54)
					num = -1;
			}

			switch (tileCache.type) {
				case 426:
				case 427:
					num = 90;
					break;
				case 430:
				case 435:
					num = 89;
					break;
				case 431:
				case 436:
					num = 88;
					break;
				case 432:
				case 437:
					num = 87;
					break;
				case 433:
				case 438:
					num = 86;
					break;
				case 434:
				case 439:
					num = 91;
					break;
			}

			if (tileCache.type == 186)
				num = ((tileCache.frameX <= 360) ? 26 : ((tileCache.frameX <= 846) ? 1 : ((tileCache.frameX <= 954) ? 9 : ((tileCache.frameX <= 1062) ? 11 : ((tileCache.frameX <= 1170) ? 10 : ((tileCache.frameX > 1332) ? ((tileCache.frameX > 1386) ? 80 : 10) : 0))))));

			if (tileCache.type == 187) {
				if (tileCache.frameX <= 144)
					num = 1;
				else if (tileCache.frameX <= 306)
					num = 38;
				else if (tileCache.frameX <= 468)
					num = 36;
				else if (tileCache.frameX <= 738)
					num = 30;
				else if (tileCache.frameX <= 970)
					num = 1;
				else if (tileCache.frameX <= 1132)
					num = 148;
				else if (tileCache.frameX <= 1132)
					num = 155;
				else if (tileCache.frameX <= 1348)
					num = 1;
				else if (tileCache.frameX <= 1564)
					num = 0;
			}

			if (tileCache.type == 105) {
				num = 1;
				if (tileCache.frameX >= 1548 && tileCache.frameX <= 1654 && tileCache.frameY < 54)
					num = 148;
			}

			if (tileCache.type == 349)
				num = 1;

			if (tileCache.type == 337)
				num = 1;

			if (tileCache.type == 239) {
				int num8 = tileCache.frameX / 18;
				if (num8 == 0)
					num = 9;

				if (num8 == 1)
					num = 81;

				if (num8 == 2)
					num = 8;

				if (num8 == 3)
					num = 82;

				if (num8 == 4)
					num = 11;

				if (num8 == 5)
					num = 83;

				if (num8 == 6)
					num = 10;

				if (num8 == 7)
					num = 84;

				if (num8 == 8)
					num = 14;

				if (num8 == 9)
					num = 23;

				if (num8 == 10)
					num = 25;

				if (num8 == 11)
					num = 48;

				if (num8 == 12)
					num = 144;

				if (num8 == 13)
					num = 49;

				if (num8 == 14)
					num = 145;

				if (num8 == 15)
					num = 50;

				if (num8 == 16)
					num = 146;

				if (num8 == 17)
					num = 128;

				if (num8 == 18)
					num = 84;

				if (num8 == 19)
					num = 117;

				if (num8 == 20)
					num = 42;

				if (num8 == 21)
					num = -1;

				if (num8 == 22)
					num = 265;
			}

			if (tileCache.type == 185) {
				if (tileCache.frameY == 18) {
					int num9 = tileCache.frameX / 36;
					if (num9 < 6)
						num = 1;
					else if (num9 < 16)
						num = 26;
					else if (num9 == 16)
						num = 9;
					else if (num9 == 17)
						num = 11;
					else if (num9 == 18)
						num = 10;
					else if (num9 == 19)
						num = 86;
					else if (num9 == 20)
						num = 87;
					else if (num9 == 21)
						num = 88;
					else if (num9 == 22)
						num = 89;
					else if (num9 == 23)
						num = 90;
					else if (num9 == 24)
						num = 91;
					else if (num9 < 31)
						num = 80;
					else if (num9 < 33)
						num = 7;
					else if (num9 < 34)
						num = 8;
					else if (num9 < 39)
						num = 30;
					else if (num9 < 42)
						num = 1;
				}
				else {
					int num10 = tileCache.frameX / 18;
					if (num10 < 6)
						num = 1;
					else if (num10 < 12)
						num = 0;
					else if (num10 < 27)
						num = 26;
					else if (num10 < 32)
						num = 1;
					else if (num10 < 35)
						num = 0;
					else if (num10 < 46)
						num = 80;
					else if (num10 < 52)
						num = 30;
				}
			}

			if (tileCache.type == 184) {
				int num11 = tileCache.frameX / 22;
				num = ((num11 != 5) ? (93 + num11) : 258);
			}

			if (tileCache.type == 237)
				num = 148;

			if (tileCache.type == 157)
				num = 77;

			if (tileCache.type == 158 || tileCache.type == 232 || tileCache.type == 383)
				num = 78;

			if (tileCache.type == 159)
				num = 78;

			if (tileCache.type == 15)
				num = -1;

			if (tileCache.type == 191)
				num = 7;

			if (tileCache.type == 5) {
				num = 7;
				if (i > 5 && i < Main.maxTilesX - 5) {
					int num12 = i;
					int k = j;
					if (tileCache.frameX == 66 && tileCache.frameY <= 45)
						num12++;

					if (tileCache.frameX == 88 && tileCache.frameY >= 66 && tileCache.frameY <= 110)
						num12--;

					if (tileCache.frameX == 22 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
						num12--;

					if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
						num12++;

					if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
						num12++;

					if (tileCache.frameX == 44 && tileCache.frameY >= 198)
						num12++;

					if (tileCache.frameX == 66 && tileCache.frameY >= 198)
						num12--;

					for (; Main.tile[num12, k] != null && (!Main.tile[num12, k].active() || !Main.tileSolid[Main.tile[num12, k].type]); k++) {
					}

					if (Main.tile[num12, k] != null) {
						if (Main.tile[num12, k].active() && Main.tile[num12, k].type == 23)
							num = 77;

						if (Main.tile[num12, k].active() && Main.tile[num12, k].type == 60)
							num = 78;

						if (Main.tile[num12, k].active() && Main.tile[num12, k].type == 70)
							num = 26;

						if (Main.tile[num12, k].active() && Main.tile[num12, k].type == 109)
							num = 79;

						if (Main.tile[num12, k].active() && Main.tile[num12, k].type == 199)
							num = 121;

						//patch file: num12, k
						if (Main.tile[num12, k].active() && Main.tile[num12, k].type == 147)
							num = 122;

						TileLoader.TreeDust(Main.tile[num12, k], ref num);
					}
				}
			}

			if (tileCache.type == 323) {
				num = 215;
				if (i > 5 && i < Main.maxTilesX - 5) {
					int l;
					for (l = j; Main.tile[i, l] != null && (!Main.tile[i, l].active() || !Main.tileSolid[Main.tile[i, l].type]); l++) {
					}

					if (Main.tile[i, l] != null) {
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 234)
							num = 121;

						if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
							num = 79;

						//patch file: l
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
							num = 77;

						TileLoader.PalmTreeDust(Main.tile[i, l], ref num);
					}
				}
			}

			if (tileCache.type == 137) {
				num = 1;
				if (tileCache.frameY / 18 > 0)
					num = 148;
			}

			if (tileCache.type == 443)
				num = 1;

			if (tileCache.type == 444)
				num = -1;

			if (tileCache.type == 212)
				num = -1;

			if (tileCache.type == 213)
				num = 129;

			if (tileCache.type == 214)
				num = 1;

			if (tileCache.type == 215)
				num = -6;

			if (tileCache.type == 325)
				num = 81;

			if (tileCache.type == 251)
				num = 189;

			if (tileCache.type == 252)
				num = 190;

			if (tileCache.type == 253)
				num = 191;

			if (tileCache.type == 254) {
				if (tileCache.frameX < 72) {
					num = 3;
				}
				else if (tileCache.frameX < 108) {
					num = 3;
					if (genRand.Next(3) == 0)
						num = 189;
				}
				else if (tileCache.frameX < 144) {
					num = 3;
					if (genRand.Next(2) == 0)
						num = 189;
				}
				else {
					num = 3;
					if (genRand.Next(4) != 0)
						num = 189;
				}
			}

			if (tileCache.type == 467)
				num = -1;

			if (tileCache.type == 21)
				num = ((tileCache.frameX >= 1008) ? (-1) : ((tileCache.frameX >= 612) ? 11 : ((tileCache.frameX >= 576) ? 148 : ((tileCache.frameX >= 540) ? 26 : ((tileCache.frameX >= 504) ? 126 : ((tileCache.frameX >= 468) ? 116 : ((tileCache.frameX >= 432) ? 7 : ((tileCache.frameX >= 396) ? 11 : ((tileCache.frameX >= 360) ? 10 : ((tileCache.frameX >= 324) ? 79 : ((tileCache.frameX >= 288) ? 78 : ((tileCache.frameX >= 252) ? 77 : ((tileCache.frameX >= 216) ? 1 : ((tileCache.frameX >= 180) ? 7 : ((tileCache.frameX >= 108) ? 37 : ((tileCache.frameX < 36) ? 7 : 10))))))))))))))));

			if (tileCache.type == 2)
				num = ((genRand.Next(2) != 0) ? 2 : 0);

			if (Main.tileMoss[tileCache.type])
				num = ((tileCache.type != 381) ? (tileCache.type - 179 + 93) : 258);

			if (tileCache.type == 127)
				num = 67;

			if (tileCache.type == 91)
				num = -1;

			if (tileCache.type == 198)
				num = 109;

			if (tileCache.type == 26)
				num = ((tileCache.frameX < 54) ? 8 : 5);

			if (tileCache.type == 34)
				num = -1;

			if (tileCache.type == 6)
				num = 8;

			if (tileCache.type == 7 || tileCache.type == 47 || tileCache.type == 284)
				num = 9;

			if (tileCache.type == 8 || tileCache.type == 45 || tileCache.type == 102)
				num = 10;

			if (tileCache.type == 9 || tileCache.type == 42 || tileCache.type == 46 || tileCache.type == 126 || tileCache.type == 136)
				num = 11;

			if (tileCache.type == 166 || tileCache.type == 175)
				num = 81;

			if (tileCache.type == 167)
				num = 82;

			if (tileCache.type == 168 || tileCache.type == 176)
				num = 83;

			if (tileCache.type == 169 || tileCache.type == 177)
				num = 84;

			if (tileCache.type == 199)
				num = 117;

			if (tileCache.type == 205)
				num = 125;

			if (tileCache.type == 201)
				num = 125;

			if (tileCache.type == 211)
				num = 128;

			if (tileCache.type == 227) {
				switch (tileCache.frameX / 34) {
					case 0:
					case 1:
						num = 26;
						break;
					case 3:
						num = 3;
						break;
					case 2:
					case 4:
					case 5:
					case 6:
						num = 40;
						break;
					case 7:
						num = 117;
						break;
					case 8:
						num = 17;
						break;
					case 9:
						num = 6;
						break;
					case 10:
						num = 3;
						break;
					case 11:
						num = 26;
						break;
				}
			}

			if (tileCache.type == 204) {
				num = 117;
				if (genRand.Next(2) == 0)
					num = 1;
			}

			if (tileCache.type == 203)
				num = 117;

			if (tileCache.type == 243)
				num = ((genRand.Next(2) != 0) ? 13 : 7);

			if (tileCache.type == 244) {
				num = ((genRand.Next(2) == 0) ? 1 : 13);
			}
			else if ((tileCache.type >= 358 && tileCache.type <= 364) || (tileCache.type >= 275 && tileCache.type <= 282) || tileCache.type == 285 || tileCache.type == 286 || (tileCache.type >= 288 && tileCache.type <= 297) || (tileCache.type >= 316 && tileCache.type <= 318) || tileCache.type == 298 || tileCache.type == 299 || tileCache.type == 309 || tileCache.type == 310 || tileCache.type == 339 || tileCache.type == 413 || tileCache.type == 414) {
				num = 13;
				if (genRand.Next(3) != 0)
					num = -1;
			}

			if (tileCache.type == 13)
				num = ((tileCache.frameX < 90) ? 13 : (-1));

			if (tileCache.type == 189)
				num = 16;

			if (tileCache.type == 460)
				num = 16;

			if (tileCache.type == 12)
				num = 12;

			if (tileCache.type == 3 || tileCache.type == 73)
				num = 3;

			if (tileCache.type == 54)
				num = 13;

			if (tileCache.type == 22 || tileCache.type == 140)
				num = 14;

			if (tileCache.type == 78)
				num = 22;

			if (tileCache.type == 28) {
				num = 22;
				if (tileCache.frameY >= 72 && tileCache.frameY <= 90)
					num = 1;

				if (tileCache.frameY >= 144 && tileCache.frameY <= 234)
					num = 48;

				if (tileCache.frameY >= 252 && tileCache.frameY <= 358)
					num = 85;

				if (tileCache.frameY >= 360 && tileCache.frameY <= 466)
					num = 26;

				if (tileCache.frameY >= 468 && tileCache.frameY <= 574)
					num = 36;

				if (tileCache.frameY >= 576 && tileCache.frameY <= 790)
					num = 18;

				if (tileCache.frameY >= 792 && tileCache.frameY <= 898)
					num = 5;

				if (tileCache.frameY >= 900 && tileCache.frameY <= 1006)
					num = 0;

				if (tileCache.frameY >= 1008 && tileCache.frameY <= 1114)
					num = 148;

				if (tileCache.frameY >= 1116 && tileCache.frameY <= 1222)
					num = 241;
			}

			if (tileCache.type == 163)
				num = 118;

			if (tileCache.type == 164)
				num = 119;

			if (tileCache.type == 200)
				num = 120;

			if (tileCache.type == 221 || tileCache.type == 248)
				num = 144;

			if (tileCache.type == 222 || tileCache.type == 249)
				num = 145;

			if (tileCache.type == 223 || tileCache.type == 250)
				num = 146;

			if (tileCache.type == 224)
				num = 149;

			if (tileCache.type == 225)
				num = 147;

			if (tileCache.type == 229)
				num = 153;

			if (tileCache.type == 231) {
				num = 153;
				if (genRand.Next(3) == 0)
					num = 26;
			}

			if (tileCache.type == 226)
				num = 148;

			if (tileCache.type == 103)
				num = -1;

			if (tileCache.type == 29)
				num = 23;

			if (tileCache.type == 40)
				num = 28;

			if (tileCache.type == 49)
				num = 29;

			if (tileCache.type == 50)
				num = 22;

			if (tileCache.type == 51)
				num = 30;

			if (tileCache.type == 52 || tileCache.type == 353)
				num = 3;

			if (tileCache.type == 53 || tileCache.type == 81 || tileCache.type == 151 || tileCache.type == 202 || tileCache.type == 274)
				num = 32;

			if (tileCache.type == 56 || tileCache.type == 152)
				num = 37;

			if (tileCache.type == 75)
				num = 109;

			if (tileCache.type == 57 || tileCache.type == 119 || tileCache.type == 141 || tileCache.type == 234)
				num = 36;

			if (tileCache.type == 59 || tileCache.type == 120)
				num = 38;

			if (tileCache.type == 61 || tileCache.type == 62 || tileCache.type == 74 || tileCache.type == 80 || tileCache.type == 188 || tileCache.type == 233 || tileCache.type == 236 || tileCache.type == 384)
				num = 40;

			if (tileCache.type == 238)
				num = ((genRand.Next(3) != 0) ? 166 : 167);

			if (tileCache.type == 69)
				num = 7;

			if (tileCache.type == 71 || tileCache.type == 72 || tileCache.type == 190)
				num = 26;

			if (tileCache.type == 70)
				num = 17;

			if (tileCache.type == 112)
				num = 14;

			if (tileCache.type == 123)
				num = 53;

			if (tileCache.type == 161)
				num = 80;

			if (tileCache.type == 206)
				num = 80;

			if (tileCache.type == 162)
				num = 80;

			if (tileCache.type == 165) {
				switch (tileCache.frameX / 54) {
					case 0:
						num = 80;
						break;
					case 1:
						num = 1;
						break;
					case 2:
						num = 30;
						break;
					case 3:
						num = 147;
						break;
					case 4:
						num = 1;
						break;
					case 5:
						num = 14;
						break;
					case 6:
						num = 117;
						break;
					case 7:
						num = 250;
						break;
					case 8:
						num = 240;
						break;
					case 9:
						num = 236;
						break;
					default:
						num = 1;
						break;
				}
			}

			if (tileCache.type == 193)
				num = 4;

			if (tileCache.type == 194)
				num = 26;

			if (tileCache.type == 195)
				num = 5;

			if (tileCache.type == 196)
				num = 108;

			if (tileCache.type == 197)
				num = 4;

			if (tileCache.type == 153)
				num = 26;

			if (tileCache.type == 154)
				num = 32;

			if (tileCache.type == 155)
				num = 2;

			if (tileCache.type == 156)
				num = 1;

			if (tileCache.type == 116 || tileCache.type == 118 || tileCache.type == 147 || tileCache.type == 148)
				num = 51;

			if (tileCache.type == 109)
				num = ((genRand.Next(2) != 0) ? 47 : 0);

			if (tileCache.type == 110 || tileCache.type == 113 || tileCache.type == 115)
				num = 47;

			if (tileCache.type == 107 || tileCache.type == 121)
				num = 48;

			if (tileCache.type == 108 || tileCache.type == 122 || tileCache.type == 146)
				num = 49;

			if (tileCache.type == 111 || tileCache.type == 145 || tileCache.type == 150)
				num = 50;

			if (tileCache.type == 133) {
				num = 50;
				if (tileCache.frameX >= 54)
					num = 146;
			}

			if (tileCache.type == 134) {
				num = 49;
				if (tileCache.frameX >= 36)
					num = 145;
			}

			if (tileCache.type == 149)
				num = 49;

			if (Main.tileAlch[tileCache.type]) {
				int num13 = tileCache.frameX / 18;
				if (num13 == 0)
					num = 3;

				if (num13 == 1)
					num = 3;

				if (num13 == 2)
					num = 7;

				if (num13 == 3)
					num = 17;

				if (num13 == 4)
					num = 3;

				if (num13 == 5)
					num = 6;

				if (num13 == 6)
					num = 224;
			}

			if (tileCache.type == 58 || tileCache.type == 76 || tileCache.type == 77)
				num = ((genRand.Next(2) != 0) ? 25 : 6);

			if (tileCache.type == 37)
				num = ((genRand.Next(2) != 0) ? 23 : 6);

			if (tileCache.type == 32)
				num = ((genRand.Next(2) != 0) ? 24 : 14);

			if (tileCache.type == 352)
				num = ((genRand.Next(3) != 0) ? 125 : 5);

			if (tileCache.type == 23 || tileCache.type == 24)
				num = ((genRand.Next(2) != 0) ? 17 : 14);

			if (tileCache.type == 25 || tileCache.type == 31)
				num = ((tileCache.type == 31 && tileCache.frameX >= 36) ? 5 : ((genRand.Next(2) != 0) ? 1 : 14));

			if (tileCache.type == 20) {
				switch (tileCache.frameX / 54) {
					case 1:
						num = 122;
						break;
					case 2:
						num = 78;
						break;
					case 3:
						num = 77;
						break;
					case 4:
						num = 121;
						break;
					case 5:
						num = 79;
						break;
					default:
						num = 7;
						break;
				}
			}

			if (tileCache.type == 27)
				num = ((genRand.Next(2) != 0) ? 19 : 3);

			if (tileCache.type == 129)
				num = ((tileCache.frameX != 0 && tileCache.frameX != 54 && tileCache.frameX != 108) ? ((tileCache.frameX != 18 && tileCache.frameX != 72 && tileCache.frameX != 126) ? 70 : 69) : 68);

			if (tileCache.type == 385)
				num = genRand.Next(68, 71);

			if (tileCache.type == 4) {
				int num14 = tileCache.frameY / 22;
				switch (num14) {
					case 0:
						num = 6;
						break;
					case 8:
						num = 75;
						break;
					case 9:
						num = 135;
						break;
					case 10:
						num = 158;
						break;
					case 11:
						num = 169;
						break;
					case 12:
						num = 156;
						break;
					case 13:
						num = 234;
						break;
					case 14:
						num = 66;
						break;
					case 15:
						num = 242;
						break;
					default:
						num = 58 + num14;
						break;
				}
			}

			if (tileCache.type == 35) {
				num = 189;
				if (tileCache.frameX < 36 && genRand.Next(2) == 0)
					num = 6;
			}

			if ((tileCache.type == 34 || tileCache.type == 42) && genRand.Next(2) == 0)
				num = 6;

			if (tileCache.type == 270)
				num = -1;

			if (tileCache.type == 271)
				num = -1;

			if (tileCache.type == 79 || tileCache.type == 90 || tileCache.type == 101)
				num = -1;

			if (tileCache.type == 33 || tileCache.type == 34 || tileCache.type == 42 || tileCache.type == 93 || tileCache.type == 100)
				num = -1;

			if (tileCache.type == 321)
				num = 214;

			if (tileCache.type == 322)
				num = 215;

			bool flag = tileCache.type == 178 || tileCache.type == 440;
			ushort type = tileCache.type;
			if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
				flag = true;

			if (TileLoader.CreateDust(i, j, tileCache.type, ref num) && num >= 0) { // TODO, fix
				if (tileCache.type == 352 && num == 5) {
					int num15 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 5, 0f, 0f, 100);
					Main.dust[num15].scale = 1.5f;
					Main.dust[num15].noGravity = true;
					Main.dust[num15].velocity *= 1.65f;
					Main.dust[num15].fadeIn = 1.6f;
					return num15;
				}

				if (tileCache.type == 160) {
					int num16 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
					Main.dust[num16].noGravity = true;
					return num16;
				}

				if (tileCache.type == 323) {
					int frameY = tileCache.frameY;
					return Dust.NewDust(new Vector2(i * 16 + frameY, j * 16), 16, 16, num);
				}

				if (tileCache.type == 314) {
					int num17 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 213, genRand.Next(-2, 3), genRand.Next(-2, 3));
					Main.dust[num17].noGravity = true;
					Main.dust[num17].fadeIn = Main.dust[num17].scale + 1f + 0.01f * (float)genRand.Next(0, 51);
					Main.dust[num17].noGravity = true;
					return num17;
				}

				if (flag) {
					int num18 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
					Main.dust[num18].noLight = true;
					return num18;
				}

				if (tileCache.type == 193 || (tileCache.type == 18 && num == 4))
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);

				if (tileCache.type == 197)
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(97, 200, 255, 100), 0.75f);

				if (tileCache.type == 185 && num >= 86 && num <= 91) {
					int num19 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
					Main.dust[num19].noLight = true;
					return num19;
				}

				if (tileCache.type == 4 && num == 66) {
					int num20 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 0, new Color((float)Main.DiscoR / 255f, (float)Main.DiscoG / 255f, (float)Main.DiscoB / 255f));
					Main.dust[num20].noGravity = true;
					return num20;
				}

				if (num == 139) {
					int type2 = num + Main.rand.Next(4);
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, type2);
				}

				return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
			}

			return 6000;
		}

		public static bool IsOpenDoorAnchorFrame(int x, int y) {
			Tile tile = Main.tile[x, y];
			if (!tile.active() || tile.type != 11)
				return false;

			int num = tile.frameX % 72;
			if (num >= 18)
				return num < 54;

			return false;
		}

		public static bool IsLockedDoor(int x, int y) {
			Tile tile = Main.tile[x, y];
			if (tile.type == 10 && tile.frameY >= 594 && tile.frameY <= 646)
				return tile.frameX < 54;

			return false;
		}

		public static void DropDoorItem(int x, int y, int doorStyle) {
			int num = 0;
			switch (doorStyle) {
				case 0:
					num = 25;
					break;
				case 9:
					num = 837;
					break;
				case 10:
					num = 912;
					break;
				case 12:
					num = 1137;
					break;
				case 13:
					num = 1138;
					break;
				case 14:
					num = 1139;
					break;
				case 15:
					num = 1140;
					break;
				case 16:
					num = 1411;
					break;
				case 17:
					num = 1412;
					break;
				case 18:
					num = 1413;
					break;
				case 19:
					num = 1458;
					break;
				case 20:
				case 21:
				case 22:
				case 23:
					num = 1709 + doorStyle - 20;
					break;
				default:
					switch (doorStyle) {
						case 24:
							num = 1793;
							break;
						case 25:
							num = 1815;
							break;
						case 26:
							num = 1924;
							break;
						case 27:
							num = 2044;
							break;
						case 28:
							num = 2265;
							break;
						case 29:
							num = 2528;
							break;
						case 30:
							num = 2561;
							break;
						case 31:
							num = 2576;
							break;
						case 32:
							num = 2815;
							break;
						case 33:
							num = 3129;
							break;
						case 34:
							num = 3131;
							break;
						case 35:
							num = 3130;
							break;
						case 36:
							num = 3888;
							break;
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
							num = 812 + doorStyle;
							break;
						default:
							if (doorStyle != 11)
								num = 649 + doorStyle;
							break;
					}
					break;
			}

			if (num != 0)
				Item.NewItem(x * 16, y * 16, 16, 16, num);
		}

		public static bool PlayerLOS(int x, int y) {
			Rectangle rectangle = new Rectangle(x * 16, y * 16, 16, 16);
			for (int i = 0; i < 255; i++) {
				if (Main.player[i].active) {
					Rectangle value = new Rectangle((int)((double)Main.player[i].position.X + (double)Main.player[i].width * 0.5 - (double)NPC.sWidth * 0.6), (int)((double)Main.player[i].position.Y + (double)Main.player[i].height * 0.5 - (double)NPC.sHeight * 0.6), (int)((double)NPC.sWidth * 1.2), (int)((double)NPC.sHeight * 1.2));
					if (rectangle.Intersects(value))
						return true;
				}
			}

			return false;
		}

		public static bool Chlorophyte(int i, int j) {
			int num = 40;
			int num2 = 130;
			int num3 = 35;
			int num4 = 85;
			if ((double)j < Main.rockLayer) {
				num /= 2;
				num2 /= 2;
				num3 = (int)((double)num3 * 1.5);
				num4 = (int)((double)num4 * 1.5);
			}

			int num5 = 0;
			for (int k = i - num3; k < i + num3; k++) {
				for (int l = j - num3; l < j + num3; l++) {
					if (k < Main.maxTilesX - 10 && k > 10 && Main.tile[k, l].active() && Main.tile[k, l].type == 211)
						num5++;
				}
			}

			if (num5 > num)
				return false;

			num5 = 0;
			for (int m = i - num4; m < i + num4; m++) {
				for (int n = j - num4; n < j + num4; n++) {
					if (m < Main.maxTilesX - 10 && m > 10 && Main.tile[m, n].active() && Main.tile[m, n].type == 211)
						num5++;
				}
			}

			if (num5 > num2)
				return false;

			return true;
		}

		private static bool nearbyChlorophyte(int i, int j) {
			float num = 0f;
			int num2 = 10;
			if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5)
				return false;

			if (j <= num2 + 5 || j >= Main.maxTilesY - num2 - 5)
				return false;

			for (int k = i - num2; k < i + num2; k++) {
				for (int l = j - num2; l < j + num2; l++) {
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 211 || Main.tile[k, l].type == 346)) {
						num += 1f;
						if (num == 5f)
							return true;
					}
				}
			}

			if (num > 0f && (float)genRand.Next(5) < num)
				return true;

			return false;
		}

		private static int CountNearBlocksTypes(int i, int j, int radius, int cap = 0, params int[] tiletypes) {
			if (tiletypes.Length == 0)
				return 0;

			int value = i - radius;
			int value2 = i + radius;
			int value3 = j - radius;
			int value4 = j + radius;
			int num = Utils.Clamp(value, 0, Main.maxTilesX - 1);
			value2 = Utils.Clamp(value2, 0, Main.maxTilesX - 1);
			value3 = Utils.Clamp(value3, 0, Main.maxTilesY - 1);
			value4 = Utils.Clamp(value4, 0, Main.maxTilesY - 1);
			int num2 = 0;
			for (int k = num; k < value2; k++) {
				for (int l = value3; l < value4; l++) {
					if (!Main.tile[k, l].active())
						continue;

					for (int m = 0; m < tiletypes.Length; m++) {
						if (tiletypes[m] == Main.tile[k, l].type) {
							num2++;
							if (cap <= 0 || num2 < cap)
								break;

							return num2;
						}
					}
				}
			}

			return num2;
		}

		public static void hardUpdateWorld(int i, int j) {
			if (!Main.hardMode || Main.tile[i, j].inActive())
				return;

			int type = Main.tile[i, j].type;
			if ((type == 117 || type == 164) && (double)j > Main.rockLayer && genRand.Next(110) == 0) {
				int num = genRand.Next(4);
				int num2 = 0;
				int num3 = 0;
				switch (num) {
					case 0:
						num2 = -1;
						break;
					case 1:
						num2 = 1;
						break;
					default:
						num3 = ((num != 0) ? 1 : (-1));
						break;
				}

				if (!Main.tile[i + num2, j + num3].active()) {
					int num4 = 0;
					int num5 = 6;
					for (int k = i - num5; k <= i + num5; k++) {
						for (int l = j - num5; l <= j + num5; l++) {
							if (Main.tile[k, l].active() && Main.tile[k, l].type == 129)
								num4++;
						}
					}

					if (num4 < 2) {
						PlaceTile(i + num2, j + num3, 129, mute: true);
						NetMessage.SendTileSquare(-1, i + num2, j + num3, 1);
					}
				}
			}

			if ((double)j > (Main.worldSurface + Main.rockLayer) / 2.0) {
				if (type == 60 && genRand.Next(300) == 0) {
					int num6 = i + genRand.Next(-10, 11);
					int num7 = j + genRand.Next(-10, 11);
					if (InWorld(num6, num7, 2) && Main.tile[num6, num7].active() && Main.tile[num6, num7].type == 59 && (!Main.tile[num6, num7 - 1].active() || (Main.tile[num6, num7 - 1].type != 5 && Main.tile[num6, num7 - 1].type != 236 && Main.tile[num6, num7 - 1].type != 238)) && Chlorophyte(num6, num7)) {
						Main.tile[num6, num7].type = 211;
						SquareTileFrame(num6, num7);
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num6, num7, 1);
					}
				}

				if (type == 211 && genRand.Next(3) != 0) {
					int num8 = i;
					int num9 = j;
					int num10 = genRand.Next(4);
					if (num10 == 0)
						num8++;

					if (num10 == 1)
						num8--;

					if (num10 == 2)
						num9++;

					if (num10 == 3)
						num9--;

					if (InWorld(num8, num9, 2) && Main.tile[num8, num9].active() && (Main.tile[num8, num9].type == 59 || Main.tile[num8, num9].type == 60) && Chlorophyte(num8, num9)) {
						Main.tile[num8, num9].type = 211;
						SquareTileFrame(num8, num9);
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num8, num9, 1);
					}

					bool flag = true;
					while (flag) {
						flag = false;
						num8 = i + Main.rand.Next(-5, 6);
						num9 = j + Main.rand.Next(-5, 6);
						if (!InWorld(num8, num9, 2) || !Main.tile[num8, num9].active())
							continue;

						if (Main.tile[num8, num9].type == 23 || Main.tile[num8, num9].type == 199 || Main.tile[num8, num9].type == 2 || Main.tile[num8, num9].type == 109) {
							Main.tile[num8, num9].type = 60;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num8, num9, 1);

							flag = true;
						}
						else if (Main.tile[num8, num9].type == 0) {
							Main.tile[num8, num9].type = 59;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num8, num9, 1);

							flag = true;
						}
					}
				}
			}

			if (NPC.downedPlantBoss && genRand.Next(2) != 0)
				return;

			if (type == 23 || type == 25 || type == 32 || type == 112 || type == 163 || type == 400 || type == 398) {
				bool flag2 = true;
				while (flag2) {
					flag2 = false;
					int num11 = i + genRand.Next(-3, 4);
					int num12 = j + genRand.Next(-3, 4);
					bool flag3 = false;
					ushort type2 = Main.tile[num11, num12].type;
					if ((uint)(type2 - 59) <= 1u) {
						flag3 = nearbyChlorophyte(num11, num12);
					}
					else {
						bool flag4 = false;
						int num13 = num11;
						int num14 = num12;
						for (int m = 0; m < 4; m++) {
							switch (m) {
								case 0:
									num13 = num11 - 1;
									num14 = num12;
									break;
								case 1:
									num13 = num11 + 1;
									num14 = num12;
									break;
								case 2:
									num13 = num11;
									num14 = num12 - 1;
									break;
								case 3:
									num13 = num11;
									num14 = num12 + 1;
									break;
							}

							if (Main.tile[num13, num14].active() && (Main.tile[num13, num14].type == 59 || Main.tile[num13, num14].type == 60)) {
								flag4 = true;
								break;
							}
						}

						if (flag4)
							flag3 = nearbyChlorophyte(num11, num12);
					}

					if (Main.tile[num11, num12 - 1].type == 27 || flag3)
						continue;

					if (Main.tile[num11, num12].type == 2) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 23;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 1 || Main.tileMoss[Main.tile[num11, num12].type]) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 25;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 53) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 112;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 396) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 400;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 397) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 398;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 59) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 0;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 60) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 23;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 69) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 32;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 161) {
						if (genRand.Next(2) == 0)
							flag2 = true;

						Main.tile[num11, num12].type = 163;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
				}
			}

			if (type == 199 || type == 200 || type == 201 || type == 203 || type == 205 || type == 234 || type == 352 || type == 401 || type == 399) {
				bool flag5 = true;
				while (flag5) {
					flag5 = false;
					int num15 = i + genRand.Next(-3, 4);
					int num16 = j + genRand.Next(-3, 4);
					bool flag6 = nearbyChlorophyte(num15, num16);
					if (Main.tile[num15, num16 - 1].type == 27 || flag6)
						continue;

					if (Main.tile[num15, num16].type == 2) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 199;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 1 || Main.tileMoss[Main.tile[num15, num16].type]) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 203;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 53) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 234;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 396) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 401;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 397) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 399;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 59) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 0;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 60) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 199;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 69) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 352;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
					else if (Main.tile[num15, num16].type == 161) {
						if (genRand.Next(2) == 0)
							flag5 = true;

						Main.tile[num15, num16].type = 200;
						SquareTileFrame(num15, num16);
						NetMessage.SendTileSquare(-1, num15, num16, 1);
					}
				}
			}

			if (type != 109 && type != 110 && type != 113 && type != 115 && type != 116 && type != 117 && type != 164 && type != 402 && type != 403)
				return;

			bool flag7 = true;
			while (flag7) {
				flag7 = false;
				int num17 = i + genRand.Next(-3, 4);
				int num18 = j + genRand.Next(-3, 4);
				if (Main.tile[num17, num18].type == 2) {
					if (genRand.Next(2) == 0)
						flag7 = true;

					Main.tile[num17, num18].type = 109;
					SquareTileFrame(num17, num18);
					NetMessage.SendTileSquare(-1, num17, num18, 1);
				}
				else if (Main.tile[num17, num18].type == 1 || Main.tileMoss[Main.tile[num17, num18].type]) {
					if (genRand.Next(2) == 0)
						flag7 = true;

					Main.tile[num17, num18].type = 117;
					SquareTileFrame(num17, num18);
					NetMessage.SendTileSquare(-1, num17, num18, 1);
				}
				else if (Main.tile[num17, num18].type == 53) {
					if (genRand.Next(2) == 0)
						flag7 = true;

					Main.tile[num17, num18].type = 116;
					SquareTileFrame(num17, num18);
					NetMessage.SendTileSquare(-1, num17, num18, 1);
				}
				else if (Main.tile[num17, num18].type == 396) {
					if (genRand.Next(2) == 0)
						flag7 = true;

					Main.tile[num17, num18].type = 403;
					SquareTileFrame(num17, num18);
					NetMessage.SendTileSquare(-1, num17, num18, 1);
				}
				else if (Main.tile[num17, num18].type == 397) {
					if (genRand.Next(2) == 0)
						flag7 = true;

					Main.tile[num17, num18].type = 402;
					SquareTileFrame(num17, num18);
					NetMessage.SendTileSquare(-1, num17, num18, 1);
				}
				else if (Main.tile[num17, num18].type == 161) {
					if (genRand.Next(2) == 0)
						flag7 = true;

					Main.tile[num17, num18].type = 164;
					SquareTileFrame(num17, num18);
					NetMessage.SendTileSquare(-1, num17, num18, 1);
				}
			}
		}

		public static bool SolidTile(Tile testTile) {
			try {
				if (testTile == null)
					return true;

				if (testTile.active() && Main.tileSolid[testTile.type] && !Main.tileSolidTop[testTile.type] && !testTile.halfBrick() && testTile.slope() == 0 && !testTile.inActive())
					return true;
			}
			catch {
			}

			return false;
		}

		public static bool TileEmpty(int i, int j) {
			if (Main.tile[i, j] != null && Main.tile[i, j].active())
				return Main.tile[i, j].inActive();

			return true;
		}

		public static bool SolidOrSlopedTile(Tile tile) {
			if (tile != null && tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
				return !tile.inActive();

			return false;
		}

		public static bool SolidOrSlopedTile(int x, int y) => SolidOrSlopedTile(Main.tile[x, y]);

		public static bool SolidTile(int i, int j) {
			try {
				if (Main.tile[i, j] == null)
					return true;

				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type] && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].inActive())
					return true;
			}
			catch {
			}

			return false;
		}

		public static bool SolidTile2(Tile testTile) {
			try {
				if (testTile == null)
					return true;

				if (testTile.active() && Main.tileSolid[testTile.type] && testTile.slope() == 0 && !testTile.halfBrick() && !testTile.inActive())
					return true;
			}
			catch {
			}

			return false;
		}

		public static bool PlatformProperTopFrame(short frameX) {
			int num = frameX / TileObjectData.PlatformFrameWidth();
			if ((num < 0 || num > 7) && (num < 12 || num > 16)) {
				if (num >= 25)
					return num <= 26;

				return false;
			}

			return true;
		}

		public static bool SolidTileAllowBottomSlope(int i, int j) {
			try {
				Tile tile = Main.tile[i, j];
				if (tile == null)
					return true;

				if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
					return true;
			}
			catch {
			}

			return false;
		}

		public static bool SolidTile3(int i, int j) {
			if (!InWorld(i, j, 1))
				return false;

			return SolidTile3(Main.tile[i, j]);
		}

		public static bool SolidTile3(Tile t) {
			if (t == null)
				return false;

			if (t.active() && !t.inActive() && Main.tileSolid[t.type])
				return !Main.tileSolidTop[t.type];

			return false;
		}

		public static bool SolidTile2(int i, int j) {
			try {
				if (Main.tile[i, j] == null)
					return true;

				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
					return true;
			}
			catch {
			}

			return false;
		}

		public static bool SolidTileNoAttach(int i, int j) {
			try {
				if (Main.tile[i, j] == null)
					return true;

				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileNoAttach[Main.tile[i, j].type] && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
					return true;
			}
			catch {
			}

			return false;
		}

		public static Vector2 Hive(int i, int j) {
			double num = genRand.Next(12, 21);
			double num2 = num;
			float num3 = genRand.Next(10, 21);
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.2f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.2f;
			while (num > 0.0 && num3 > 0f) {
				num = num2 * (double)(1f + (float)genRand.Next(-20, 20) * 0.01f);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num);
				int num5 = (int)((double)vector.X + num);
				int num6 = (int)((double)vector.Y - num);
				int num7 = (int)((double)vector.Y + num);
				if (num4 < 1)
					num4 = 1;

				if (num5 > Main.maxTilesX - 1)
					num5 = Main.maxTilesX - 1;

				if (num6 < 1)
					num6 = 1;

				if (num7 > Main.maxTilesY - 1)
					num7 = Main.maxTilesY - 1;

				for (int k = num4; k < num5; k++) {
					for (int l = num6; l < num7; l++) {
						float num8 = Math.Abs((float)k - vector.X);
						float num9 = Math.Abs((float)l - vector.Y);
						double num10 = Math.Sqrt(num8 * num8 + num9 * num9);
						if (num10 < num2 * 0.4 * (1.0 + (double)genRand.Next(-10, 11) * 0.005)) {
							if (genRand.Next(3) == 0)
								Main.tile[k, l].liquid = byte.MaxValue;

							Main.tile[k, l].honey(honey: true);
							Main.tile[k, l].wall = 86;
							Main.tile[k, l].active(active: false);
							Main.tile[k, l].halfBrick(halfBrick: false);
							Main.tile[k, l].slope(0);
							SquareWallFrame(k, l);
						}
						else if (num10 < num2 * 0.75 * (1.0 + (double)genRand.Next(-10, 11) * 0.005)) {
							Main.tile[k, l].liquid = 0;
							if (Main.tile[k, l].wall != 86) {
								Main.tile[k, l].active(active: true);
								Main.tile[k, l].halfBrick(halfBrick: false);
								Main.tile[k, l].slope(0);
								Main.tile[k, l].type = 225;
							}
						}

						if (num10 < num2 * 0.6 * (1.0 + (double)genRand.Next(-10, 11) * 0.005))
							Main.tile[k, l].wall = 86;

						SquareWallFrame(k, l);
						SquareTileFrame(k, l);
					}
				}

				vector += vector2;
				num3 -= 1f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
			}

			return new Vector2(vector.X, vector.Y);
		}

		public static void MineHouse(int i, int j) {
			if (i < 50 || i > Main.maxTilesX - 50 || j < 50 || j > Main.maxTilesY - 50)
				return;

			int num = genRand.Next(6, 12);
			int num2 = genRand.Next(3, 6);
			int num3 = genRand.Next(15, 30);
			int num4 = genRand.Next(15, 30);
			if (SolidTile(i, j) || Main.tile[i, j].wall > 0)
				return;

			int num5 = j - num;
			int num6 = j + num2;
			for (int k = 0; k < 2; k++) {
				bool flag = true;
				int num7 = i;
				int num8 = j;
				int num9 = -1;
				int num10 = num3;
				if (k == 1) {
					num9 = 1;
					num10 = num4;
					num7++;
				}

				while (flag) {
					if (num8 - num < num5)
						num5 = num8 - num;

					if (num8 + num2 > num6)
						num6 = num8 + num2;

					for (int l = 0; l < 2; l++) {
						int num11 = num8;
						bool flag2 = true;
						int num12 = num;
						int num13 = -1;
						if (l == 1) {
							num11++;
							num12 = num2;
							num13 = 1;
						}

						while (flag2) {
							if (num7 != i && Main.tile[num7 - num9, num11].wall != 27 && (SolidTile(num7 - num9, num11) || !Main.tile[num7 - num9, num11].active() || Main.tile[num7 - num9, num11].halfBrick() || Main.tile[num7 - num9, num11].slope() != 0)) {
								Main.tile[num7 - num9, num11].active(active: true);
								Main.tile[num7 - num9, num11].type = 30;
							}

							if (SolidTile(num7 - 1, num11) || Main.tile[num7 - 1, num11].halfBrick() || Main.tile[num7 - 1, num11].slope() != 0)
								Main.tile[num7 - 1, num11].type = 30;

							if (SolidTile(num7 + 1, num11) || Main.tile[num7 + 1, num11].halfBrick() || Main.tile[num7 + 1, num11].slope() != 0)
								Main.tile[num7 + 1, num11].type = 30;

							if (SolidTile(num7, num11) || Main.tile[num7, num11].halfBrick() || Main.tile[num7, num11].slope() != 0) {
								int num14 = 0;
								if (SolidTile(num7 - 1, num11))
									num14++;

								if (SolidTile(num7 + 1, num11))
									num14++;

								if (SolidTile(num7, num11 - 1))
									num14++;

								if (SolidTile(num7, num11 + 1))
									num14++;

								if (num14 < 2) {
									Main.tile[num7, num11].active(active: false);
								}
								else {
									flag2 = false;
									Main.tile[num7, num11].type = 30;
								}
							}
							else {
								Main.tile[num7, num11].wall = 27;
								Main.tile[num7, num11].liquid = 0;
								Main.tile[num7, num11].lava(lava: false);
							}

							num11 += num13;
							num12--;
							if (num12 <= 0) {
								if (!Main.tile[num7, num11].active()) {
									Main.tile[num7, num11].active(active: true);
									Main.tile[num7, num11].type = 30;
								}

								flag2 = false;
							}
						}
					}

					num10--;
					num7 += num9;
					if (SolidTile(num7, num8)) {
						int num15 = 0;
						int num16 = 0;
						int num17 = num8;
						bool flag3 = true;
						while (flag3) {
							num17--;
							num15++;
							if (SolidTile(num7 - num9, num17)) {
								num15 = 999;
								flag3 = false;
							}
							else if (!SolidTile(num7, num17)) {
								flag3 = false;
							}
						}

						num17 = num8;
						flag3 = true;
						while (flag3) {
							num17++;
							num16++;
							if (SolidTile(num7 - num9, num17)) {
								num16 = 999;
								flag3 = false;
							}
							else if (!SolidTile(num7, num17)) {
								flag3 = false;
							}
						}

						if (num16 <= num15) {
							if (num16 > num2)
								num10 = 0;
							else
								num8 += num16 + 1;
						}
						else if (num15 > num) {
							num10 = 0;
						}
						else {
							num8 -= num15 + 1;
						}
					}

					if (num10 <= 0)
						flag = false;
				}
			}

			int num18 = i - num3 - 1;
			int num19 = i + num4 + 2;
			int num20 = num5 - 1;
			int num21 = num6 + 2;
			for (int m = num18; m < num19; m++) {
				for (int n = num20; n < num21; n++) {
					if (Main.tile[m, n].wall == 27 && !Main.tile[m, n].active()) {
						if (Main.tile[m - 1, n].wall != 27 && m < i && !SolidTile(m - 1, n)) {
							PlaceTile(m, n, 30, mute: true);
							Main.tile[m, n].wall = 0;
						}

						if (Main.tile[m + 1, n].wall != 27 && m > i && !SolidTile(m + 1, n)) {
							PlaceTile(m, n, 30, mute: true);
							Main.tile[m, n].wall = 0;
						}

						for (int num22 = m - 1; num22 <= m + 1; num22++) {
							for (int num23 = n - 1; num23 <= n + 1; num23++) {
								if (SolidTile(num22, num23))
									Main.tile[num22, num23].type = 30;
							}
						}
					}

					if (Main.tile[m, n].type == 30 && Main.tile[m - 1, n].wall == 27 && Main.tile[m + 1, n].wall == 27 && (Main.tile[m, n - 1].wall == 27 || Main.tile[m, n - 1].active()) && (Main.tile[m, n + 1].wall == 27 || Main.tile[m, n + 1].active())) {
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = 27;
					}
				}
			}

			for (int num24 = num18; num24 < num19; num24++) {
				for (int num25 = num20; num25 < num21; num25++) {
					if (Main.tile[num24, num25].type == 30) {
						if (Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 1, num25].active()) {
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
						}

						if (!TileID.Sets.BasicChest[Main.tile[num24, num25 - 1].type] && Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].type == 30 && Main.tile[num24 + 2, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 2, num25].active()) {
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
							Main.tile[num24 + 1, num25].active(active: false);
							Main.tile[num24 + 1, num25].wall = 27;
						}

						if (Main.tile[num24, num25 - 1].wall == 27 && Main.tile[num24, num25 + 1].wall == 27 && !Main.tile[num24, num25 - 1].active() && !Main.tile[num24, num25 + 1].active()) {
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
						}
					}
				}
			}

			for (int num26 = num18; num26 < num19; num26++) {
				for (int num27 = num21; num27 > num20; num27--) {
					bool flag4 = false;
					if (Main.tile[num26, num27].active() && Main.tile[num26, num27].type == 30) {
						int num28 = -1;
						for (int num29 = 0; num29 < 2; num29++) {
							if (!SolidTile(num26 + num28, num27) && Main.tile[num26 + num28, num27].wall == 0) {
								int num30 = 0;
								int num31 = num27;
								int num32 = num27;
								while (Main.tile[num26, num31].active() && Main.tile[num26, num31].type == 30 && !SolidTile(num26 + num28, num31) && Main.tile[num26 + num28, num31].wall == 0) {
									num31--;
									num30++;
								}

								num31++;
								int num33 = num31 + 1;
								if (num30 > 4) {
									if (genRand.Next(2) == 0) {
										num31 = num32 - 1;
										bool flag5 = true;
										for (int num34 = num26 - 2; num34 <= num26 + 2; num34++) {
											for (int num35 = num31 - 2; num35 <= num31; num35++) {
												if (num34 != num26 && Main.tile[num34, num35].active())
													flag5 = false;
											}
										}

										if (flag5) {
											Main.tile[num26, num31].active(active: false);
											Main.tile[num26, num31 - 1].active(active: false);
											Main.tile[num26, num31 - 2].active(active: false);
											PlaceTile(num26, num31, 10, mute: true);
											flag4 = true;
										}
									}

									if (!flag4) {
										for (int num36 = num33; num36 < num32; num36++) {
											Main.tile[num26, num36].type = 124;
										}
									}
								}
							}

							num28 = 1;
						}
					}

					if (flag4)
						break;
				}
			}

			int num37 = genRand.Next(1, 2);
			if (genRand.Next(4) == 0)
				num37 = 0;

			if (genRand.Next(6) == 0)
				num37++;

			if (genRand.Next(10) == 0)
				num37++;

			for (int num38 = 0; num38 < num37; num38++) {
				int num39 = 0;
				int num40 = genRand.Next(num18, num19);
				int num41 = genRand.Next(num20, num21);
				while (!Main.wallHouse[Main.tile[num40, num41].wall] || Main.tile[num40, num41].active()) {
					num39++;
					if (num39 > 1000)
						break;

					num40 = genRand.Next(num18, num19);
					num41 = genRand.Next(num20, num21);
				}

				if (num39 > 1000)
					break;

				int num42 = num40;
				int num43 = num40;
				int num44 = num41;
				int num45 = num41;
				int num46 = 0;
				for (int num47 = 0; num47 < 2; num47++) {
					num42 = num40;
					num43 = num40;
					while (!Main.tile[num42, num41].active() && Main.wallHouse[Main.tile[num42, num41].wall]) {
						num42--;
					}

					num42++;
					for (; !Main.tile[num43, num41].active() && Main.wallHouse[Main.tile[num43, num41].wall]; num43++) {
					}

					num43--;
					i = (num42 + num43) / 2;
					num44 = num41;
					num45 = num41;
					while (!Main.tile[num40, num44].active() && Main.wallHouse[Main.tile[num40, num44].wall]) {
						num44--;
					}

					num44++;
					for (; !Main.tile[num40, num45].active() && Main.wallHouse[Main.tile[num40, num45].wall]; num45++) {
					}

					num45--;
					num41 = (num44 + num45) / 2;
				}

				num42 = num40;
				num43 = num40;
				while (!Main.tile[num42, num41].active() && !Main.tile[num42, num41 - 1].active() && !Main.tile[num42, num41 + 1].active()) {
					num42--;
				}

				num42++;
				for (; !Main.tile[num43, num41].active() && !Main.tile[num43, num41 - 1].active() && !Main.tile[num43, num41 + 1].active(); num43++) {
				}

				num43--;
				num44 = num41;
				num45 = num41;
				while (!Main.tile[num40, num44].active() && !Main.tile[num40 - 1, num44].active() && !Main.tile[num40 + 1, num44].active()) {
					num44--;
				}

				num44++;
				for (; !Main.tile[num40, num45].active() && !Main.tile[num40 - 1, num45].active() && !Main.tile[num40 + 1, num45].active(); num45++) {
				}

				num45--;
				num40 = (num42 + num43) / 2;
				num41 = (num44 + num45) / 2;
				int num48 = num43 - num42;
				num46 = num45 - num44;
				if (num48 <= 7 || num46 <= 5)
					continue;

				int num49 = 0;
				if (nearPicture2(i, num41))
					num49 = -1;

				if (num49 == 0) {
					Vector2 vector = randHousePicture();
					int type = (int)vector.X;
					int style = (int)vector.Y;
					if (!nearPicture(num40, num41))
						PlaceTile(num40, num41, type, mute: true, forced: false, -1, style);
				}
			}

			int num50;
			for (num50 = num18; num50 < num19; num50++) {
				bool flag6 = true;
				for (int num51 = num20; num51 < num21; num51++) {
					for (int num52 = num50 - 3; num52 <= num50 + 3; num52++) {
						if (Main.tile[num52, num51].active() && (!SolidTile(num52, num51) || Main.tile[num52, num51].type == 10))
							flag6 = false;
					}
				}

				if (flag6) {
					for (int num53 = num20; num53 < num21; num53++) {
						if (Main.tile[num50, num53].wall == 27 && !Main.tile[num50, num53].active())
							PlaceTile(num50, num53, 124, mute: true);
					}
				}

				num50 += genRand.Next(4);
			}

			for (int num54 = 0; num54 < 4; num54++) {
				int num55 = genRand.Next(num18 + 2, num19 - 1);
				int num56 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num55, num56].wall != 27) {
					num55 = genRand.Next(num18 + 2, num19 - 1);
					num56 = genRand.Next(num20 + 2, num21 - 1);
				}

				while (Main.tile[num55, num56].active()) {
					num56--;
				}

				for (; !Main.tile[num55, num56].active(); num56++) {
				}

				num56--;
				if (Main.tile[num55, num56].wall != 27)
					continue;

				if (genRand.Next(3) == 0) {
					int num57 = genRand.Next(9);
					if (num57 == 0)
						num57 = 14;

					if (num57 == 1)
						num57 = 16;

					if (num57 == 2)
						num57 = 18;

					if (num57 == 3)
						num57 = 86;

					if (num57 == 4)
						num57 = 87;

					if (num57 == 5)
						num57 = 94;

					if (num57 == 6)
						num57 = 101;

					if (num57 == 7)
						num57 = 104;

					if (num57 == 8)
						num57 = 106;

					PlaceTile(num55, num56, num57, mute: true);
				}
				else {
					int num58 = genRand.Next(2, statueList.Length);
					PlaceTile(num55, num56, statueList[num58].X, mute: true, forced: true, -1, statueList[num58].Y);
				}
			}

			for (int num59 = 0; num59 < 40; num59++) {
				int num60 = genRand.Next(num18 + 2, num19 - 1);
				int num61 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num60, num61].wall != 27) {
					num60 = genRand.Next(num18 + 2, num19 - 1);
					num61 = genRand.Next(num20 + 2, num21 - 1);
				}

				while (Main.tile[num60, num61].active()) {
					num61--;
				}

				for (; !Main.tile[num60, num61].active(); num61++) {
				}

				num61--;
				if (Main.tile[num60, num61].wall == 27 && genRand.Next(2) == 0) {
					int style2 = genRand.Next(22, 26);
					PlaceTile(num60, num61, 186, mute: true, forced: false, -1, style2);
				}
			}

			for (int num62 = 0; num62 < 20; num62++) {
				int num63 = genRand.Next(num18 + 2, num19 - 1);
				int num64 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num63, num64].wall != 27) {
					num63 = genRand.Next(num18 + 2, num19 - 1);
					num64 = genRand.Next(num20 + 2, num21 - 1);
				}

				while (Main.tile[num63, num64].active()) {
					num64--;
				}

				for (; !Main.tile[num63, num64].active(); num64++) {
				}

				num64--;
				if (Main.tile[num63, num64].wall == 27 && genRand.Next(2) == 0) {
					int x = genRand.Next(31, 34);
					PlaceSmallPile(num63, num64, x, 1, 185);
				}
			}

			for (int num65 = 0; num65 < 15; num65++) {
				int num66 = genRand.Next(num18 + 2, num19 - 1);
				int num67 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num66, num67].wall != 27) {
					num66 = genRand.Next(num18 + 2, num19 - 1);
					num67 = genRand.Next(num20 + 2, num21 - 1);
				}

				while (Main.tile[num66, num67].active()) {
					num67--;
				}

				while (num67 > 0 && !Main.tile[num66, num67 - 1].active()) {
					num67--;
				}

				if (Main.tile[num66, num67].wall != 27)
					continue;

				int num68 = 4;
				int style3 = 0;
				if (genRand.Next(10) < 9) {
					num68 = -1;
				}
				else {
					num68 = 34;
					style3 = genRand.Next(6);
				}

				if (num68 <= 0)
					continue;

				PlaceTile(num66, num67, num68, mute: true, forced: false, -1, style3);
				if (Main.tile[num66, num67].type != num68)
					continue;

				if (num68 == 4) {
					Main.tile[num66, num67].frameX += 54;
					continue;
				}

				int num69 = num66;
				int num70 = num67;
				num67 = num70 - Main.tile[num69, num70].frameY % 54 / 18;
				num66 = Main.tile[num69, num70].frameX / 18;
				if (num66 > 2)
					num66 -= 3;

				num66 = num69 - num66;
				short num71 = 54;
				if (Main.tile[num66, num67].frameX > 0)
					num71 = -54;

				for (int num72 = num66; num72 < num66 + 3; num72++) {
					for (int num73 = num67; num73 < num67 + 3; num73++) {
						Main.tile[num72, num73].frameX += num71;
					}
				}
			}
		}

		public static void CountTiles(int X) {
			if (X == 0) {
				totalEvil = totalEvil2;
				totalBlood = totalBlood2;
				totalSolid = totalSolid2;
				totalGood = totalGood2;
				tGood = (byte)Math.Round((float)totalGood / (float)totalSolid * 100f);
				tEvil = (byte)Math.Round((float)totalEvil / (float)totalSolid * 100f);
				tBlood = (byte)Math.Round((float)totalBlood / (float)totalSolid * 100f);
				if (tGood == 0 && totalGood > 0)
					tGood = 1;

				if (tEvil == 0 && totalEvil > 0)
					tEvil = 1;

				if (tBlood == 0 && totalBlood > 0)
					tBlood = 1;

				if (Main.netMode == 2)
					NetMessage.SendData(57);

				totalEvil2 = 0;
				totalSolid2 = 0;
				totalGood2 = 0;
				totalBlood2 = 0;
			}

			ushort num = 0;
			ushort num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			do {
				int num6;
				int num7;
				if (num4 == 0) {
					num6 = 0;
					num5 = (int)(Main.worldSurface + 1.0);
					num7 = 5;
				}
				else {
					num6 = num5;
					num5 = Main.maxTilesY;
					num7 = 1;
				}

				for (int i = num6; i < num5; i++) {
					Tile tile = Main.tile[X, i];
					if (tile == null)
						tile = (Main.tile[X, i] = new Tile());

					num = tile.type;
					if (num != 0 || tile.active()) {
						if (num == num2) {
							num3 += num7;
							continue;
						}

						tileCounts[num2] += num3;
						num2 = num;
						num3 = num7;
					}
				}

				tileCounts[num2] += num3;
				num3 = 0;
				num4++;
			} while (num4 < 2);

			AddUpAlignmentCounts();
		}

		public static void AddUpAlignmentCounts(bool clearCounts = false) {
			if (clearCounts) {
				totalEvil2 = 0;
				totalSolid2 = 0;
				totalGood2 = 0;
				totalBlood2 = 0;
			}

			totalGood2 += tileCounts[164] + tileCounts[109] + tileCounts[117] + tileCounts[116];
			totalEvil2 += tileCounts[23] + tileCounts[163] + tileCounts[112] + tileCounts[25];
			totalBlood2 += tileCounts[199] + tileCounts[234] + tileCounts[203] + tileCounts[200];
			totalSolid2 += tileCounts[2] + tileCounts[1] + tileCounts[60] + tileCounts[53] + tileCounts[161];
			totalSolid2 += tileCounts[164] + tileCounts[109] + tileCounts[117] + tileCounts[116];
			totalSolid2 += tileCounts[23] + tileCounts[163] + tileCounts[112] + tileCounts[25];
			totalSolid2 += tileCounts[199] + tileCounts[234] + tileCounts[203] + tileCounts[200];
			Array.Clear(tileCounts, 0, tileCounts.Length);
		}

		public static void plantDye(int i, int j, bool exoticPlant = false) {
			UnifiedRandom unifiedRandom = gen ? genRand : Main.rand;
			if (!Main.tile[i, j].active() || i < 95 || i > Main.maxTilesX - 95 || j < 95 || j > Main.maxTilesY - 95)
				return;

			int num = 90;
			if (exoticPlant)
				num = 240;

			if ((double)j < Main.worldSurface) {
				if (Main.tile[i, j - 1].active() && Main.tile[i, j - 1].type != 3 && Main.tile[i, j - 1].type != 51 && Main.tile[i, j - 1].type != 61 && Main.tile[i, j - 1].type != 73 && Main.tile[i, j - 1].type != 74 && Main.tile[i, j - 1].type != 184)
					return;

				int num2 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
				int num3 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
				int num4 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
				int num5 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
				for (int k = num2; k < num3; k++) {
					for (int l = num4; l < num5; l++) {
						if (Main.tile[k, l].active() && Main.tile[k, l].type == 227 && (!exoticPlant || Main.tile[k, l].frameX >= 272) && (exoticPlant || Main.tile[k, l].frameX < 272))
							return;
					}
				}

				if (exoticPlant) {
					int type = Main.tile[i, j].type;
					bool flag = TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] || type == 0;
					if (Main.tile[i, j - 1].liquid > 0 && Main.tile[i, j - 1].lava())
						flag = false;

					if (flag)
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
				}
				else if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 109) {
					if (unifiedRandom.Next(4) == 0)
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
					else
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 3);
				}
				else if (Main.tile[i, j].type == 60) {
					if (unifiedRandom.Next(2) == 0)
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
					else
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
				}
				else if (Main.tile[i, j].type == 53 && Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue) {
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
				}
				else {
					if (Main.tile[i, j].type != 80 || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
						return;

					try {
						bool flag2 = true;
						for (int m = i - 5; m <= i + 5; m++) {
							for (int n = j - 5; n <= j + 15; n++) {
								if (Main.tile[m, n].active() && (Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234))
									flag2 = false;
							}
						}

						if (flag2)
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 6);
					}
					catch {
					}
				}
			}
			else {
				if (j >= Main.maxTilesY - 200)
					return;

				if (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184) {
					int num6 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
					int num7 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
					int num8 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
					int num9 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
					for (int num10 = num6; num10 < num7; num10++) {
						for (int num11 = num8; num11 < num9; num11++) {
							if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 227 && (!exoticPlant || Main.tile[num10, num11].frameX >= 272) && (exoticPlant || Main.tile[num10, num11].frameX < 272))
								return;
						}
					}

					if (exoticPlant) {
						int type2 = Main.tile[i, j].type;
						if (TileID.Sets.Conversion.Grass[type2] || TileID.Sets.Conversion.Moss[type2] || type2 == 0)
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
					}
					else if (Main.tile[i, j].type == 60) {
						if (unifiedRandom.Next(2) == 0)
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
						else if (unifiedRandom.Next(2) == 0)
							PlaceTile(i, j - 1, 227, mute: true);
						else
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
					}
					else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 1 || Main.tile[i, j].type == 59) {
						if (unifiedRandom.Next(2) == 0)
							PlaceTile(i, j - 1, 227, mute: true);
						else
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
					}
					else if (Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue) {
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 5);
					}
				}

				if (Main.tile[i, j + 1].active() || exoticPlant)
					return;

				for (int num12 = i - num; num12 < i + num; num12++) {
					for (int num13 = j - num; num13 < j + num; num13++) {
						if (Main.tile[num12, num13].active() && Main.tile[num12, num13].type == 227)
							return;
					}
				}

				if (Main.tile[i, j].type == 0)
					PlaceTile(i, j + 1, 227, mute: true, forced: false, -1, 7);
			}
		}

		public static void UpdateWorld() {
			WorldHooks.PreUpdate();
			int num = 20;
			int maxValue = 40;
			if (Main.expertMode)
				maxValue = 30;

			Wiring.UpdateMech();
			TileEntity.UpdateStart();
			foreach (TileEntity value in TileEntity.ByID.Values) {
				value.Update();
			}

			TileEntity.UpdateEnd();
			UpdateLunarApocalypse();
			if (Main.netMode != 1) {
				totalD++;
				if (totalD >= 30) {
					totalD = 0;
					CountTiles(totalX);
					totalX++;
					if (totalX >= Main.maxTilesX)
						totalX = 0;
				}
			}

			if (Main.worldRate == 0)
				return;

			Liquid.skipCount++;
			if (Liquid.skipCount > 1) {
				Liquid.UpdateLiquid();
				Liquid.skipCount = 0;
			}

			float num2 = 3E-05f * (float)Main.worldRate;
			float num3 = 1.5E-05f * (float)Main.worldRate;
			bool flag = false;
			spawnDelay++;
			if (Main.invasionType > 0 || Main.eclipse)
				spawnDelay = 0;

			if (spawnDelay >= 20) {
				flag = true;
				spawnDelay = 0;
				if (prioritizedTownNPC != 37) {
					for (int i = 0; i < 200; i++) {
						if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].townNPC && Main.npc[i].type != 368) {
							prioritizedTownNPC = Main.npc[i].type;
							break;
						}
					}
				}
			}

			float num4 = (float)(Main.maxTilesX * Main.maxTilesY) * num2;
			int num5 = 151;
			int maxValue2 = (int)MathHelper.Lerp(num5, (float)num5 * 2.8f, MathHelper.Clamp((float)Main.maxTilesX / 4200f - 1f, 0f, 1f));
			for (int j = 0; (float)j < num4; j++) {
				if (Main.rand.Next(100) == 0 && Main.rand.Next(maxValue2) == 0)
					PlantAlch();

				int num6 = genRand.Next(10, Main.maxTilesX - 10);
				int num7 = genRand.Next(10, (int)Main.worldSurface - 1);
				//patch file: num6, num7
				int num8 = num6 - 1;
				int num9 = num6 + 2;
				int num10 = num7 - 1;
				int num11 = num7 + 2;
				if (num8 < 10)
					num8 = 10;

				if (num9 > Main.maxTilesX - 10)
					num9 = Main.maxTilesX - 10;

				if (num10 < 10)
					num10 = 10;

				if (num11 > Main.maxTilesY - 10)
					num11 = Main.maxTilesY - 10;

				if (Main.tile[num6, num7] == null)
					continue;

				if (Main.tileAlch[Main.tile[num6, num7].type])
					GrowAlch(num6, num7);

				if (Main.tile[num6, num7].liquid > 32) {
					if (Main.tile[num6, num7].active() && (Main.tile[num6, num7].type == 3 || Main.tile[num6, num7].type == 20 || Main.tile[num6, num7].type == 24 || Main.tile[num6, num7].type == 27 || Main.tile[num6, num7].type == 73 || Main.tile[num6, num7].type == 201)) {
						KillTile(num6, num7);
						if (Main.netMode == 2)
							NetMessage.SendData(17, -1, -1, null, 0, num6, num7);
					}
				}
				else if (Main.tile[num6, num7].nactive()) {
					hardUpdateWorld(num6, num7);
					if (Main.rand.Next(3000) == 0)
						plantDye(num6, num7);

					if (Main.rand.Next(9001) == 0)
						plantDye(num6, num7, exoticPlant: true);

					if (Main.tile[num6, num7].type == 80) {
						if (genRand.Next(15) == 0)
							GrowCactus(num6, num7);
					}
					else if (TileID.Sets.Conversion.Sand[Main.tile[num6, num7].type]) {
						if (!Main.tile[num6, num10].active()) {
							if (num6 < 250 || num6 > Main.maxTilesX - 250) {
								if (genRand.Next(500) == 0) {
									int num12 = 7;
									int num13 = 6;
									int num14 = 0;
									for (int k = num6 - num12; k <= num6 + num12; k++) {
										for (int l = num10 - num12; l <= num10 + num12; l++) {
											if (Main.tile[k, l].active() && Main.tile[k, l].type == 81)
												num14++;
										}
									}

									if (num14 < num13 && Main.tile[num6, num10].liquid == byte.MaxValue && Main.tile[num6, num10 - 1].liquid == byte.MaxValue && Main.tile[num6, num10 - 2].liquid == byte.MaxValue && Main.tile[num6, num10 - 3].liquid == byte.MaxValue && Main.tile[num6, num10 - 4].liquid == byte.MaxValue) {
										PlaceTile(num6, num10, 81, mute: true);
										if (Main.netMode == 2 && Main.tile[num6, num10].active())
											NetMessage.SendTileSquare(-1, num6, num10, 1);
									}
								}
							}
							else if (num6 > 400 && num6 < Main.maxTilesX - 400 && genRand.Next(300) == 0) {
								GrowCactus(num6, num7);
							}
						}
					}
					else if (Main.tile[num6, num7].type == 116 || Main.tile[num6, num7].type == 112 || Main.tile[num6, num7].type == 234) {
						if (!Main.tile[num6, num10].active() && num6 > 400 && num6 < Main.maxTilesX - 400 && genRand.Next(300) == 0)
							GrowCactus(num6, num7);
					}
					else if (Main.tile[num6, num7].type == 147 || Main.tile[num6, num7].type == 161 || Main.tile[num6, num7].type == 163 || Main.tile[num6, num7].type == 164 || Main.tile[num6, num7].type == 200) {
						if (Main.rand.Next(10) == 0 && !Main.tile[num6, num7 + 1].active() && !Main.tile[num6, num7 + 2].active()) {
							int num15 = num6 - 3;
							int num16 = num6 + 4;
							int num17 = 0;
							for (int m = num15; m < num16; m++) {
								if (Main.tile[m, num7].type == 165 && Main.tile[m, num7].active())
									num17++;

								if (Main.tile[m, num7 + 1].type == 165 && Main.tile[m, num7 + 1].active())
									num17++;

								if (Main.tile[m, num7 + 2].type == 165 && Main.tile[m, num7 + 2].active())
									num17++;

								if (Main.tile[m, num7 + 3].type == 165 && Main.tile[m, num7 + 3].active())
									num17++;
							}

							if (num17 < 2) {
								PlaceTight(num6, num7 + 1, 165);
								SquareTileFrame(num6, num7 + 1);
								if (Main.netMode == 2 && Main.tile[num6, num7 + 1].active())
									NetMessage.SendTileSquare(-1, num6, num7 + 1, 3);
							}
						}
					}
					else if (Main.tile[num6, num7].type == 254) {
						if (Main.rand.Next((Main.tile[num6, num7].frameX + 10) / 10) == 0)
							GrowPumpkin(num6, num7, 254);
					}
					else if (Main.tile[num6, num7].type == 78 || Main.tile[num6, num7].type == 380) {
						if (!Main.tile[num6, num10].active() && genRand.Next(2) == 0) {
							PlaceTile(num6, num10, 3, mute: true);
							if (Main.netMode == 2 && Main.tile[num6, num10].active())
								NetMessage.SendTileSquare(-1, num6, num10, 1);
						}
					}
					else if (Main.tile[num6, num7].type == 2 || Main.tile[num6, num7].type == 23 || Main.tile[num6, num7].type == 32 || Main.tile[num6, num7].type == 109 || Main.tile[num6, num7].type == 199 || Main.tile[num6, num7].type == 352) {
						int num18 = Main.tile[num6, num7].type;
						if (Main.halloween && genRand.Next(75) == 0 && (num18 == 2 || num18 == 109)) {
							int num19 = 100;
							int num20 = 0;
							for (int n = num6 - num19; n < num6 + num19; n += 2) {
								for (int num21 = num7 - num19; num21 < num7 + num19; num21 += 2) {
									if (n > 1 && n < Main.maxTilesX - 2 && num21 > 1 && num21 < Main.maxTilesY - 2 && Main.tile[n, num21].active() && Main.tile[n, num21].type == 254)
										num20++;
								}
							}

							if (num20 < 6) {
								PlacePumpkin(num6, num10);
								if (Main.netMode == 2 && Main.tile[num6, num10].type == 254)
									NetMessage.SendTileSquare(-1, num6, num10, 4);
							}
						}

						if (!Main.tile[num6, num10].active() && genRand.Next(12) == 0 && num18 == 2 && PlaceTile(num6, num10, 3, mute: true)) {
							Main.tile[num6, num10].color(Main.tile[num6, num7].color());
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num6, num10, 1);
						}

						if (!Main.tile[num6, num10].active() && genRand.Next(10) == 0 && num18 == 23 && PlaceTile(num6, num10, 24, mute: true)) {
							Main.tile[num6, num10].color(Main.tile[num6, num7].color());
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num6, num10, 1);
						}

						if (!Main.tile[num6, num10].active() && genRand.Next(10) == 0 && num18 == 109 && PlaceTile(num6, num10, 110, mute: true)) {
							Main.tile[num6, num10].color(Main.tile[num6, num7].color());
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num6, num10, 1);
						}

						if (!Main.tile[num6, num10].active() && genRand.Next(10) == 0 && num18 == 199 && PlaceTile(num6, num10, 201, mute: true)) {
							Main.tile[num6, num10].color(Main.tile[num6, num7].color());
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num6, num10, 1);
						}

						bool flag2 = false;
						for (int num22 = num8; num22 < num9; num22++) {
							for (int num23 = num10; num23 < num11; num23++) {
								if ((num6 == num22 && num7 == num23) || !Main.tile[num22, num23].active())
									continue;

								if (num18 == 32)
									num18 = 23;

								if (num18 == 352)
									num18 = 199;

								if (Main.tile[num22, num23].type == 0 || (num18 == 23 && Main.tile[num22, num23].type == 2) || (num18 == 199 && Main.tile[num22, num23].type == 2) || (num18 == 23 && Main.tile[num22, num23].type == 109)) {
									SpreadGrass(num22, num23, 0, num18, repeat: false, Main.tile[num6, num7].color());
									if (num18 == 23)
										SpreadGrass(num22, num23, 2, num18, repeat: false, Main.tile[num6, num7].color());

									if (num18 == 23)
										SpreadGrass(num22, num23, 109, num18, repeat: false, Main.tile[num6, num7].color());

									if (num18 == 199)
										SpreadGrass(num22, num23, 2, num18, repeat: false, Main.tile[num6, num7].color());

									if (num18 == 199)
										SpreadGrass(num22, num23, 109, num18, repeat: false, Main.tile[num6, num7].color());

									if (Main.tile[num22, num23].type == num18) {
										SquareTileFrame(num22, num23);
										flag2 = true;
									}
								}

								if (Main.tile[num22, num23].type == 0 || (num18 == 109 && Main.tile[num22, num23].type == 2) || (num18 == 109 && Main.tile[num22, num23].type == 23) || (num18 == 109 && Main.tile[num22, num23].type == 199)) {
									SpreadGrass(num22, num23, 0, num18, repeat: false, Main.tile[num6, num7].color());
									if (num18 == 109)
										SpreadGrass(num22, num23, 2, num18, repeat: false, Main.tile[num6, num7].color());

									if (num18 == 109)
										SpreadGrass(num22, num23, 23, num18, repeat: false, Main.tile[num6, num7].color());

									if (num18 == 109)
										SpreadGrass(num22, num23, 199, num18, repeat: false, Main.tile[num6, num7].color());

									if (Main.tile[num22, num23].type == num18) {
										SquareTileFrame(num22, num23);
										flag2 = true;
									}
								}
							}
						}

						if (Main.netMode == 2 && flag2)
							NetMessage.SendTileSquare(-1, num6, num7, 3);
					}
					else if (Main.tile[num6, num7].type == 20 && genRand.Next(20) == 0) {
						bool flag3 = PlayerLOS(num6, num7);
						bool flag4 = false;
						flag4 = ((Main.tile[num6, num7].frameX < 324 || Main.tile[num6, num7].frameX >= 540) ? GrowTree(num6, num7) : GrowPalmTree(num6, num7));
						if (flag4 && flag3)
							TreeGrowFXCheck(num6, num7);
					}

					if (Main.tile[num6, num7].type == 3 && genRand.Next(20) == 0 && Main.tile[num6, num7].frameX != 144) {
						if ((Main.tile[num6, num7].frameX < 144 && Main.rand.Next(10) == 0) || ((Main.tile[num6, num7 + 1].type == 78 || Main.tile[num6, num7 + 1].type == 380) && Main.rand.Next(2) == 0))
							Main.tile[num6, num7].frameX = (short)(198 + genRand.Next(10) * 18);

						Main.tile[num6, num7].type = 73;
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num6, num7, 3);
					}

					if (Main.tile[num6, num7].type == 110 && genRand.Next(20) == 0 && Main.tile[num6, num7].frameX < 144) {
						Main.tile[num6, num7].type = 113;
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num6, num7, 3);
					}

					if (Main.tile[num6, num7].type == 32 && genRand.Next(3) == 0) {
						int num24 = num6;
						int num25 = num7;
						int num26 = 0;
						if (Main.tile[num24 + 1, num25].active() && Main.tile[num24 + 1, num25].type == 32)
							num26++;

						if (Main.tile[num24 - 1, num25].active() && Main.tile[num24 - 1, num25].type == 32)
							num26++;

						if (Main.tile[num24, num25 + 1].active() && Main.tile[num24, num25 + 1].type == 32)
							num26++;

						if (Main.tile[num24, num25 - 1].active() && Main.tile[num24, num25 - 1].type == 32)
							num26++;

						if (num26 < 3 || Main.tile[num6, num7].type == 23) {
							switch (genRand.Next(4)) {
								case 0:
									num25--;
									break;
								case 1:
									num25++;
									break;
								case 2:
									num24--;
									break;
								case 3:
									num24++;
									break;
							}

							if (!Main.tile[num24, num25].active()) {
								num26 = 0;
								if (Main.tile[num24 + 1, num25].active() && Main.tile[num24 + 1, num25].type == 32)
									num26++;

								if (Main.tile[num24 - 1, num25].active() && Main.tile[num24 - 1, num25].type == 32)
									num26++;

								if (Main.tile[num24, num25 + 1].active() && Main.tile[num24, num25 + 1].type == 32)
									num26++;

								if (Main.tile[num24, num25 - 1].active() && Main.tile[num24, num25 - 1].type == 32)
									num26++;

								if (num26 < 2) {
									int num27 = 7;
									int num28 = num24 - num27;
									int num29 = num24 + num27;
									int num30 = num25 - num27;
									int num31 = num25 + num27;
									bool flag5 = false;
									for (int num32 = num28; num32 < num29; num32++) {
										for (int num33 = num30; num33 < num31; num33++) {
											if (Math.Abs(num32 - num24) * 2 + Math.Abs(num33 - num25) < 9 && Main.tile[num32, num33].active() && Main.tile[num32, num33].type == 23 && Main.tile[num32, num33 - 1].active() && Main.tile[num32, num33 - 1].type == 32 && Main.tile[num32, num33 - 1].liquid == 0) {
												flag5 = true;
												break;
											}
										}
									}

									if (flag5) {
										Main.tile[num24, num25].type = 32;
										Main.tile[num24, num25].active(active: true);
										SquareTileFrame(num24, num25);
										if (Main.netMode == 2)
											NetMessage.SendTileSquare(-1, num24, num25, 3);
									}
								}
							}
						}
					}

					if (Main.tile[num6, num7].type == 352 && genRand.Next(3) == 0)
						GrowSpike(num6, num7, 352, 199);
				}
				else if (flag) {
					TrySpawningTownNPC(num6, num7);
				}

				if (Main.tile[num6, num7].wall == 81 || Main.tile[num6, num7].wall == 83 || (Main.tile[num6, num7].type == 199 && Main.tile[num6, num7].active())) {
					int num34 = num6 + genRand.Next(-2, 3);
					int num35 = num7 + genRand.Next(-2, 3);
					if (Main.tile[num34, num35].wall >= 63 && Main.tile[num34, num35].wall <= 68) {
						bool flag6 = false;
						for (int num36 = num6 - num; num36 < num6 + num; num36++) {
							for (int num37 = num7 - num; num37 < num7 + num; num37++) {
								if (Main.tile[num6, num7].active()) {
									int type = Main.tile[num6, num7].type;
									if (type == 199 || type == 200 || type == 201 || type == 203 || type == 205 || type == 234 || type == 352) {
										flag6 = true;
										break;
									}
								}
							}
						}

						if (flag6) {
							Main.tile[num34, num35].wall = 81;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num34, num35, 3);
						}
					}
				}

				if (Main.tile[num6, num7].wall == 69 || Main.tile[num6, num7].wall == 3 || (Main.tile[num6, num7].type == 23 && Main.tile[num6, num7].active())) {
					int num38 = num6 + genRand.Next(-2, 3);
					int num39 = num7 + genRand.Next(-2, 3);
					if (Main.tile[num38, num39].wall >= 63 && Main.tile[num38, num39].wall <= 68) {
						bool flag7 = false;
						for (int num40 = num6 - num; num40 < num6 + num; num40++) {
							for (int num41 = num7 - num; num41 < num7 + num; num41++) {
								if (Main.tile[num40, num41].active()) {
									int type2 = Main.tile[num40, num41].type;
									if (type2 == 22 || type2 == 23 || type2 == 24 || type2 == 25 || type2 == 32 || type2 == 112 || type2 == 163) {
										flag7 = true;
										break;
									}
								}
							}
						}

						if (flag7) {
							Main.tile[num38, num39].wall = 69;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num38, num39, 3);
						}
					}
				}

				if (Main.tile[num6, num7].wall == 70 || (Main.tile[num6, num7].type == 109 && Main.tile[num6, num7].active())) {
					int num42 = num6 + genRand.Next(-2, 3);
					int num43 = num7 + genRand.Next(-2, 3);
					if (Main.tile[num42, num43].wall == 63 || Main.tile[num42, num43].wall == 65 || Main.tile[num42, num43].wall == 66 || Main.tile[num42, num43].wall == 68) {
						bool flag8 = false;
						for (int num44 = num6 - num; num44 < num6 + num; num44++) {
							for (int num45 = num7 - num; num45 < num7 + num; num45++) {
								if (Main.tile[num44, num45].active()) {
									int type3 = Main.tile[num44, num45].type;
									if (type3 == 109 || type3 == 110 || type3 == 113 || type3 == 115 || type3 == 116 || type3 == 117 || type3 == 164) {
										flag8 = true;
										break;
									}
								}
							}
						}

						if (flag8) {
							Main.tile[num42, num43].wall = 70;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num42, num43, 3);
						}
					}
				}

				SpreadDesertWalls(num, num6, num7);
				if (!Main.tile[num6, num7].active())
					continue;

				if ((Main.tile[num6, num7].type == 2 || Main.tile[num6, num7].type == 52 || (Main.tile[num6, num7].type == 192 && genRand.Next(10) == 0)) && genRand.Next(40) == 0 && !Main.tile[num6, num7 + 1].active() && !Main.tile[num6, num7 + 1].lava()) {
					bool flag9 = false;
					for (int num46 = num7; num46 > num7 - 10; num46--) {
						if (Main.tile[num6, num46].bottomSlope()) {
							flag9 = false;
							break;
						}

						if (Main.tile[num6, num46].active() && Main.tile[num6, num46].type == 2 && !Main.tile[num6, num46].bottomSlope()) {
							flag9 = true;
							break;
						}
					}

					if (flag9) {
						int num47 = num6;
						int num48 = num7 + 1;
						Main.tile[num47, num48].type = 52;
						Main.tile[num47, num48].active(active: true);
						Main.tile[num47, num48].color(Main.tile[num6, num7].color());
						SquareTileFrame(num47, num48);
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num47, num48, 3);
					}
				}

				if (Main.tile[num6, num7].type == 70) {
					int type4 = Main.tile[num6, num7].type;
					if (!Main.tile[num6, num10].active() && genRand.Next(10) == 0) {
						PlaceTile(num6, num10, 71, mute: true);
						if (Main.tile[num6, num10].active())
							Main.tile[num6, num10].color(Main.tile[num6, num7].color());

						if (Main.netMode == 2 && Main.tile[num6, num10].active())
							NetMessage.SendTileSquare(-1, num6, num10, 1);
					}

					if (genRand.Next(100) == 0) {
						bool flag10 = PlayerLOS(num6, num7);
						if (GrowTree(num6, num7) && flag10)
							TreeGrowFXCheck(num6, num7 - 1);
					}

					bool flag11 = false;
					for (int num49 = num8; num49 < num9; num49++) {
						for (int num50 = num10; num50 < num11; num50++) {
							if ((num6 != num49 || num7 != num50) && Main.tile[num49, num50].active() && Main.tile[num49, num50].type == 59) {
								SpreadGrass(num49, num50, 59, type4, repeat: false, Main.tile[num6, num7].color());
								if (Main.tile[num49, num50].type == type4) {
									SquareTileFrame(num49, num50);
									flag11 = true;
								}
							}
						}
					}

					if (Main.netMode == 2 && flag11)
						NetMessage.SendTileSquare(-1, num6, num7, 3);
				}

				if (Main.tile[num6, num7].type == 60) {
					int type5 = Main.tile[num6, num7].type;
					if (!Main.tile[num6, num10].active() && genRand.Next(7) == 0) {
						PlaceTile(num6, num10, 61, mute: true);
						if (Main.tile[num6, num10].active())
							Main.tile[num6, num10].color(Main.tile[num6, num7].color());

						if (Main.netMode == 2 && Main.tile[num6, num10].active())
							NetMessage.SendTileSquare(-1, num6, num10, 1);
					}
					else if (genRand.Next(500) == 0 && (!Main.tile[num6, num10].active() || Main.tile[num6, num10].type == 61 || Main.tile[num6, num10].type == 74 || Main.tile[num6, num10].type == 69)) {
						if (GrowTree(num6, num7) && PlayerLOS(num6, num7))
							TreeGrowFXCheck(num6, num7 - 1);
					}
					else if (genRand.Next(25) == 0 && Main.tile[num6, num10].liquid == 0) {
						PlaceJunglePlant(num6, num10, 233, genRand.Next(8), 0);
						if (Main.tile[num6, num10].type == 233) {
							if (Main.netMode == 2) {
								NetMessage.SendTileSquare(-1, num6, num10, 4);
							}
							else {
								PlaceJunglePlant(num6, num10, 233, genRand.Next(12), 1);
								if (Main.tile[num6, num10].type == 233 && Main.netMode == 2)
									NetMessage.SendTileSquare(-1, num6, num10, 3);
							}
						}
					}

					bool flag12 = false;
					for (int num51 = num8; num51 < num9; num51++) {
						for (int num52 = num10; num52 < num11; num52++) {
							if ((num6 != num51 || num7 != num52) && Main.tile[num51, num52].active() && Main.tile[num51, num52].type == 59) {
								SpreadGrass(num51, num52, 59, type5, repeat: false, Main.tile[num6, num7].color());
								if (Main.tile[num51, num52].type == type5) {
									SquareTileFrame(num51, num52);
									flag12 = true;
								}
							}
						}
					}

					if (Main.netMode == 2 && flag12)
						NetMessage.SendTileSquare(-1, num6, num7, 3);
				}

				if (Main.tile[num6, num7].type == 61 && genRand.Next(3) == 0 && Main.tile[num6, num7].frameX < 144) {
					if (Main.rand.Next(4) == 0)
						Main.tile[num6, num7].frameX = (short)(162 + genRand.Next(8) * 18);

					Main.tile[num6, num7].type = 74;
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, num6, num7, 3);
				}

				if ((Main.tile[num6, num7].type == 60 || Main.tile[num6, num7].type == 62) && genRand.Next(15) == 0 && !Main.tile[num6, num7 + 1].active() && !Main.tile[num6, num7 + 1].lava()) {
					bool flag13 = false;
					for (int num53 = num7; num53 > num7 - 10; num53--) {
						if (Main.tile[num6, num53].bottomSlope()) {
							flag13 = false;
							break;
						}

						if (Main.tile[num6, num53].active() && Main.tile[num6, num53].type == 60 && !Main.tile[num6, num53].bottomSlope()) {
							flag13 = true;
							break;
						}
					}

					if (flag13) {
						int num54 = num6;
						int num55 = num7 + 1;
						Main.tile[num54, num55].type = 62;
						Main.tile[num54, num55].active(active: true);
						SquareTileFrame(num54, num55);
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num54, num55, 3);
					}
				}

				if ((Main.tile[num6, num7].type == 109 || Main.tile[num6, num7].type == 115) && genRand.Next(15) == 0 && !Main.tile[num6, num7 + 1].active() && !Main.tile[num6, num7 + 1].lava()) {
					bool flag14 = false;
					for (int num56 = num7; num56 > num7 - 10; num56--) {
						if (Main.tile[num6, num56].bottomSlope()) {
							flag14 = false;
							break;
						}

						if (Main.tile[num6, num56].active() && Main.tile[num6, num56].type == 109 && !Main.tile[num6, num56].bottomSlope()) {
							flag14 = true;
							break;
						}
					}

					if (flag14) {
						int num57 = num6;
						int num58 = num7 + 1;
						Main.tile[num57, num58].type = 115;
						Main.tile[num57, num58].active(active: true);
						SquareTileFrame(num57, num58);
						if (Main.netMode == 2)
							NetMessage.SendTileSquare(-1, num57, num58, 3);
					}
				}

				TileLoader.RandomUpdate(num6, num7, Main.tile[num6, num7].type);
				WallLoader.RandomUpdate(num6, num7, Main.tile[num6, num7].wall);

				if ((Main.tile[num6, num7].type != 199 && Main.tile[num6, num7].type != 205) || genRand.Next(15) != 0 || Main.tile[num6, num7 + 1].active() || Main.tile[num6, num7 + 1].lava())
					continue;

				bool flag15 = false;
				for (int num59 = num7; num59 > num7 - 10; num59--) {
					if (Main.tile[num6, num59].bottomSlope()) {
						flag15 = false;
						break;
					}

					if (Main.tile[num6, num59].active() && Main.tile[num6, num59].type == 199 && !Main.tile[num6, num59].bottomSlope()) {
						flag15 = true;
						break;
					}
				}

				if (flag15) {
					int num60 = num6;
					int num61 = num7 + 1;
					Main.tile[num60, num61].type = 205;
					Main.tile[num60, num61].active(active: true);
					SquareTileFrame(num60, num61);
					if (Main.netMode == 2)
						NetMessage.SendTileSquare(-1, num60, num61, 3);
				}
			}

			for (int num62 = 0; (float)num62 < (float)(Main.maxTilesX * Main.maxTilesY) * num3; num62++) {
				int num63 = genRand.Next(10, Main.maxTilesX - 10);
				int num64 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
				int num65 = num63 - 1;
				int num66 = num63 + 2;
				int num67 = num64 - 1;
				int num68 = num64 + 2;
				if (num65 < 10)
					num65 = 10;

				if (num66 > Main.maxTilesX - 10)
					num66 = Main.maxTilesX - 10;

				if (num67 < 10)
					num67 = 10;

				if (num68 > Main.maxTilesY - 10)
					num68 = Main.maxTilesY - 10;

				if (Main.tile[num63, num64] == null)
					continue;

				if (Main.tileAlch[Main.tile[num63, num64].type])
					GrowAlch(num63, num64);

				if (Main.tile[num63, num64].liquid <= 32) {
					if (Main.tile[num63, num64].nactive()) {
						hardUpdateWorld(num63, num64);
						if (Main.rand.Next(3000) == 0)
							plantDye(num63, num64);

						if (Main.rand.Next(4500) == 0)
							plantDye(num63, num64, exoticPlant: true);

						if (Main.tile[num63, num64].type == 23 && !Main.tile[num63, num67].active() && genRand.Next(1) == 0) {
							PlaceTile(num63, num67, 24, mute: true);
							if (Main.netMode == 2 && Main.tile[num63, num67].active())
								NetMessage.SendTileSquare(-1, num63, num67, 1);
						}

						if (Main.tile[num63, num64].type == 32 && genRand.Next(3) == 0) {
							int num69 = num63;
							int num70 = num64;
							int num71 = 0;
							if (Main.tile[num69 + 1, num70].active() && Main.tile[num69 + 1, num70].type == 32)
								num71++;

							if (Main.tile[num69 - 1, num70].active() && Main.tile[num69 - 1, num70].type == 32)
								num71++;

							if (Main.tile[num69, num70 + 1].active() && Main.tile[num69, num70 + 1].type == 32)
								num71++;

							if (Main.tile[num69, num70 - 1].active() && Main.tile[num69, num70 - 1].type == 32)
								num71++;

							if (num71 < 3 || Main.tile[num63, num64].type == 23) {
								switch (genRand.Next(4)) {
									case 0:
										num70--;
										break;
									case 1:
										num70++;
										break;
									case 2:
										num69--;
										break;
									case 3:
										num69++;
										break;
								}

								if (!Main.tile[num69, num70].active()) {
									num71 = 0;
									if (Main.tile[num69 + 1, num70].active() && Main.tile[num69 + 1, num70].type == 32)
										num71++;

									if (Main.tile[num69 - 1, num70].active() && Main.tile[num69 - 1, num70].type == 32)
										num71++;

									if (Main.tile[num69, num70 + 1].active() && Main.tile[num69, num70 + 1].type == 32)
										num71++;

									if (Main.tile[num69, num70 - 1].active() && Main.tile[num69, num70 - 1].type == 32)
										num71++;

									if (num71 < 2) {
										int num72 = 7;
										int num73 = num69 - num72;
										int num74 = num69 + num72;
										int num75 = num70 - num72;
										int num76 = num70 + num72;
										bool flag16 = false;
										for (int num77 = num73; num77 < num74; num77++) {
											for (int num78 = num75; num78 < num76; num78++) {
												if (Math.Abs(num77 - num69) * 2 + Math.Abs(num78 - num70) < 9 && Main.tile[num77, num78].active() && Main.tile[num77, num78].type == 23 && Main.tile[num77, num78 - 1].active() && Main.tile[num77, num78 - 1].type == 32 && Main.tile[num77, num78 - 1].liquid == 0) {
													flag16 = true;
													break;
												}
											}
										}

										if (flag16) {
											Main.tile[num69, num70].type = 32;
											Main.tile[num69, num70].active(active: true);
											SquareTileFrame(num69, num70);
											if (Main.netMode == 2)
												NetMessage.SendTileSquare(-1, num69, num70, 3);
										}
									}
								}
							}
						}

						if (Main.tile[num63, num64].type == 352 && genRand.Next(3) == 0)
							GrowSpike(num63, num64, 352, 199);

						if (Main.tile[num63, num64].type == 199) {
							int type6 = Main.tile[num63, num64].type;
							bool flag17 = false;
							for (int num79 = num65; num79 < num66; num79++) {
								for (int num80 = num67; num80 < num68; num80++) {
									if ((num63 != num79 || num64 != num80) && Main.tile[num79, num80].active() && Main.tile[num79, num80].type == 0) {
										SpreadGrass(num79, num80, 0, type6, repeat: false, Main.tile[num63, num64].color());
										if (Main.tile[num79, num80].type == type6) {
											SquareTileFrame(num79, num80);
											flag17 = true;
										}
									}
								}
							}

							if (Main.netMode == 2 && flag17)
								NetMessage.SendTileSquare(-1, num63, num64, 3);
						}

						if (Main.tile[num63, num64].type == 60) {
							int type7 = Main.tile[num63, num64].type;
							if (!Main.tile[num63, num67].active() && genRand.Next(10) == 0) {
								PlaceTile(num63, num67, 61, mute: true);
								if (Main.netMode == 2 && Main.tile[num63, num67].active())
									NetMessage.SendTileSquare(-1, num63, num67, 1);
							}
							else if (genRand.Next(25) == 0 && Main.tile[num63, num67].liquid == 0) {
								if (Main.hardMode && NPC.downedMechBoss1 && NPC.downedMechBoss2 && NPC.downedMechBoss3 && genRand.Next(60) == 0) {
									bool flag18 = true;
									int num81 = 150;
									for (int num82 = num63 - num81; num82 < num63 + num81; num82 += 2) {
										for (int num83 = num64 - num81; num83 < num64 + num81; num83 += 2) {
											if (num82 > 1 && num82 < Main.maxTilesX - 2 && num83 > 1 && num83 < Main.maxTilesY - 2 && Main.tile[num82, num83].active() && Main.tile[num82, num83].type == 238) {
												flag18 = false;
												break;
											}
										}
									}

									if (flag18) {
										PlaceJunglePlant(num63, num67, 238, 0, 0);
										SquareTileFrame(num63, num67);
										SquareTileFrame(num63 + 1, num67 + 1);
										if (Main.tile[num63, num67].type == 238 && Main.netMode == 2)
											NetMessage.SendTileSquare(-1, num63, num67, 4);
									}
								}

								if (Main.hardMode && NPC.downedMechBossAny && genRand.Next(maxValue) == 0) {
									bool flag19 = true;
									int num84 = 60;
									if (Main.expertMode)
										num84 -= 10;

									for (int num85 = num63 - num84; num85 < num63 + num84; num85 += 2) {
										for (int num86 = num64 - num84; num86 < num64 + num84; num86 += 2) {
											if (num85 > 1 && num85 < Main.maxTilesX - 2 && num86 > 1 && num86 < Main.maxTilesY - 2 && Main.tile[num85, num86].active() && Main.tile[num85, num86].type == 236) {
												flag19 = false;
												break;
											}
										}
									}

									if (flag19) {
										PlaceJunglePlant(num63, num67, 236, genRand.Next(3), 0);
										SquareTileFrame(num63, num67);
										SquareTileFrame(num63 + 1, num67 + 1);
										if (Main.tile[num63, num67].type == 236 && Main.netMode == 2)
											NetMessage.SendTileSquare(-1, num63, num67, 4);
									}
								}
								else {
									PlaceJunglePlant(num63, num67, 233, genRand.Next(8), 0);
									if (Main.tile[num63, num67].type == 233) {
										if (Main.netMode == 2) {
											NetMessage.SendTileSquare(-1, num63, num67, 4);
										}
										else {
											PlaceJunglePlant(num63, num67, 233, genRand.Next(12), 1);
											if (Main.tile[num63, num67].type == 233 && Main.netMode == 2)
												NetMessage.SendTileSquare(-1, num63, num67, 3);
										}
									}
								}
							}

							bool flag20 = false;
							for (int num87 = num65; num87 < num66; num87++) {
								for (int num88 = num67; num88 < num68; num88++) {
									if ((num63 != num87 || num64 != num88) && Main.tile[num87, num88].active() && Main.tile[num87, num88].type == 59) {
										SpreadGrass(num87, num88, 59, type7, repeat: false, Main.tile[num63, num64].color());
										if (Main.tile[num87, num88].type == type7) {
											SquareTileFrame(num87, num88);
											flag20 = true;
										}
									}
								}
							}

							if (Main.netMode == 2 && flag20)
								NetMessage.SendTileSquare(-1, num63, num64, 3);
						}

						if (Main.tile[num63, num64].type == 61 && genRand.Next(3) == 0 && Main.tile[num63, num64].frameX < 144) {
							if (Main.rand.Next(4) == 0)
								Main.tile[num63, num64].frameX = (short)(162 + genRand.Next(8) * 18);

							Main.tile[num63, num64].type = 74;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num63, num64, 3);
						}

						if ((Main.tile[num63, num64].type == 60 || Main.tile[num63, num64].type == 62) && genRand.Next(5) == 0 && !Main.tile[num63, num64 + 1].active() && !Main.tile[num63, num64 + 1].lava()) {
							bool flag21 = false;
							for (int num89 = num64; num89 > num64 - 10; num89--) {
								if (Main.tile[num63, num89].bottomSlope()) {
									flag21 = false;
									break;
								}

								if (Main.tile[num63, num89].active() && Main.tile[num63, num89].type == 60 && !Main.tile[num63, num89].bottomSlope()) {
									flag21 = true;
									break;
								}
							}

							if (flag21) {
								int num90 = num63;
								int num91 = num64 + 1;
								Main.tile[num90, num91].type = 62;
								Main.tile[num90, num91].active(active: true);
								SquareTileFrame(num90, num91);
								if (Main.netMode == 2)
									NetMessage.SendTileSquare(-1, num90, num91, 3);
							}
						}

						if ((Main.tile[num63, num64].type == 60 || Main.tile[num63, num64].type == 62) && genRand.Next(80) == 0 && !PlayerLOS(num63, num64)) {
							bool flag22 = true;
							int num92 = num64;
							if (Main.tile[num63, num64].type == 60)
								num92++;

							for (int num93 = num63; num93 < num63 + 2; num93++) {
								int num94 = num92 - 1;
								if (!AnchorValid(Framing.GetTileSafely(num93, num94), AnchorType.SolidTile) || Main.tile[num93, num94].bottomSlope())
									flag22 = false;

								if (Main.tile[num93, num94].liquid > 0 || Main.wallHouse[Main.tile[num93, num94].wall])
									flag22 = false;

								if (!flag22)
									break;

								for (int num95 = num92; num95 < num92 + 2; num95++) {
									if ((Main.tile[num93, num95].active() && (!Main.tileCut[Main.tile[num93, num95].type] || Main.tile[num93, num95].type == 444)) || Main.tile[num93, num95].lava())
										flag22 = false;

									if (!flag22)
										break;
								}

								if (!flag22)
									break;
							}

							if (flag22 && CountNearBlocksTypes(num63, num64, 20, 1, 444) > 0)
								flag22 = false;

							if (flag22) {
								for (int num96 = num63; num96 < num63 + 2; num96++) {
									Main.tile[num96, num92 - 1].slope(0);
									Main.tile[num96, num92 - 1].halfBrick(halfBrick: false);
									for (int num97 = num92; num97 < num92 + 2; num97++) {
										if (Main.tile[num96, num97].active())
											KillTile(num96, num97);
									}
								}

								for (int num98 = num63; num98 < num63 + 2; num98++) {
									for (int num99 = num92; num99 < num92 + 2; num99++) {
										Main.tile[num98, num99].active(active: true);
										Main.tile[num98, num99].type = 444;
										Main.tile[num98, num99].frameX = (short)((num98 - num63) * 18);
										Main.tile[num98, num99].frameY = (short)((num99 - num92) * 18);
									}
								}

								if (Main.netMode == 2)
									NetMessage.SendTileSquare(-1, num63, num92, 3);
							}
						}

						if (Main.tile[num63, num64].type == 69 && genRand.Next(3) == 0) {
							int num100 = num63;
							int num101 = num64;
							int num102 = 0;
							if (Main.tile[num100 + 1, num101].active() && Main.tile[num100 + 1, num101].type == 69)
								num102++;

							if (Main.tile[num100 - 1, num101].active() && Main.tile[num100 - 1, num101].type == 69)
								num102++;

							if (Main.tile[num100, num101 + 1].active() && Main.tile[num100, num101 + 1].type == 69)
								num102++;

							if (Main.tile[num100, num101 - 1].active() && Main.tile[num100, num101 - 1].type == 69)
								num102++;

							if (num102 < 3 || Main.tile[num63, num64].type == 60) {
								switch (genRand.Next(4)) {
									case 0:
										num101--;
										break;
									case 1:
										num101++;
										break;
									case 2:
										num100--;
										break;
									case 3:
										num100++;
										break;
								}

								if (!Main.tile[num100, num101].active()) {
									num102 = 0;
									if (Main.tile[num100 + 1, num101].active() && Main.tile[num100 + 1, num101].type == 69)
										num102++;

									if (Main.tile[num100 - 1, num101].active() && Main.tile[num100 - 1, num101].type == 69)
										num102++;

									if (Main.tile[num100, num101 + 1].active() && Main.tile[num100, num101 + 1].type == 69)
										num102++;

									if (Main.tile[num100, num101 - 1].active() && Main.tile[num100, num101 - 1].type == 69)
										num102++;

									if (num102 < 2) {
										int num103 = 7;
										int num104 = num100 - num103;
										int num105 = num100 + num103;
										int num106 = num101 - num103;
										int num107 = num101 + num103;
										bool flag23 = false;
										for (int num108 = num104; num108 < num105; num108++) {
											for (int num109 = num106; num109 < num107; num109++) {
												if (Math.Abs(num108 - num100) * 2 + Math.Abs(num109 - num101) < 9 && Main.tile[num108, num109].active() && Main.tile[num108, num109].type == 60 && Main.tile[num108, num109 - 1].active() && Main.tile[num108, num109 - 1].type == 69 && Main.tile[num108, num109 - 1].liquid == 0) {
													flag23 = true;
													break;
												}
											}
										}

										if (flag23) {
											Main.tile[num100, num101].type = 69;
											Main.tile[num100, num101].active(active: true);
											SquareTileFrame(num100, num101);
											if (Main.netMode == 2)
												NetMessage.SendTileSquare(-1, num100, num101, 3);
										}
									}
								}
							}
						}
						else if (Main.tile[num63, num64].type == 147 || Main.tile[num63, num64].type == 161 || Main.tile[num63, num64].type == 163 || Main.tile[num63, num64].type == 164 || Main.tile[num63, num64].type == 200) {
							if (Main.rand.Next(10) == 0 && !Main.tile[num63, num64 + 1].active() && !Main.tile[num63, num64 + 2].active()) {
								int num110 = num63 - 3;
								int num111 = num63 + 4;
								int num112 = 0;
								for (int num113 = num110; num113 < num111; num113++) {
									if (Main.tile[num113, num64].type == 165 && Main.tile[num113, num64].active())
										num112++;

									if (Main.tile[num113, num64 + 1].type == 165 && Main.tile[num113, num64 + 1].active())
										num112++;

									if (Main.tile[num113, num64 + 2].type == 165 && Main.tile[num113, num64 + 2].active())
										num112++;

									if (Main.tile[num113, num64 + 3].type == 165 && Main.tile[num113, num64 + 3].active())
										num112++;
								}

								if (num112 < 2) {
									PlaceTight(num63, num64 + 1, 165);
									SquareTileFrame(num63, num64 + 1);
									if (Main.netMode == 2 && Main.tile[num63, num64 + 1].active())
										NetMessage.SendTileSquare(-1, num63, num64 + 1, 3);
								}
							}
						}
						else if (Main.tileMoss[Main.tile[num63, num64].type]) {
							int type8 = Main.tile[num63, num64].type;
							bool flag24 = false;
							for (int num114 = num65; num114 < num66; num114++) {
								for (int num115 = num67; num115 < num68; num115++) {
									if ((num63 != num114 || num64 != num115) && Main.tile[num114, num115].active() && Main.tile[num114, num115].type == 1) {
										SpreadGrass(num114, num115, 1, type8, repeat: false, Main.tile[num63, num64].color());
										if (Main.tile[num114, num115].type == type8) {
											SquareTileFrame(num114, num115);
											flag24 = true;
										}
									}
								}
							}

							if (Main.netMode == 2 && flag24)
								NetMessage.SendTileSquare(-1, num63, num64, 3);

							if (genRand.Next(6) == 0) {
								int num116 = num63;
								int num117 = num64;
								switch (genRand.Next(4)) {
									case 0:
										num116--;
										break;
									case 1:
										num116++;
										break;
									case 2:
										num117--;
										break;
									default:
										num117++;
										break;
								}

								if (!Main.tile[num116, num117].active()) {
									PlaceTile(num116, num117, 184, mute: true);
									if (Main.netMode == 2 && Main.tile[num116, num117].active())
										NetMessage.SendTileSquare(-1, num116, num117, 1);
								}
							}
						}

						if (Main.tile[num63, num64].type == 70) {
							int type9 = Main.tile[num63, num64].type;
							if (!Main.tile[num63, num67].active() && genRand.Next(10) == 0) {
								PlaceTile(num63, num67, 71, mute: true);
								if (Main.netMode == 2 && Main.tile[num63, num67].active())
									NetMessage.SendTileSquare(-1, num63, num67, 1);
							}

							if (genRand.Next(200) == 0 && GrowShroom(num63, num64) && PlayerLOS(num63, num64))
								TreeGrowFXCheck(num63, num64 - 1);

							bool flag25 = false;
							for (int num118 = num65; num118 < num66; num118++) {
								for (int num119 = num67; num119 < num68; num119++) {
									if ((num63 != num118 || num64 != num119) && Main.tile[num118, num119].active() && Main.tile[num118, num119].type == 59) {
										SpreadGrass(num118, num119, 59, type9, repeat: false, Main.tile[num63, num64].color());
										if (Main.tile[num118, num119].type == type9) {
											SquareTileFrame(num118, num119);
											flag25 = true;
										}
									}
								}
							}

							if (Main.netMode == 2 && flag25)
								NetMessage.SendTileSquare(-1, num63, num64, 3);
						}
					}
					else {
						if (Main.tile[num63, num64].wall == 62 && Main.tile[num63, num64].liquid == 0 && genRand.Next(10) == 0) {
							int num120 = genRand.Next(2, 4);
							int num121 = num63 - num120;
							int num122 = num63 + num120;
							int num123 = num64 - num120;
							int num124 = num64 + num120;
							bool flag26 = false;
							for (int num125 = num121; num125 <= num122; num125++) {
								for (int num126 = num123; num126 <= num124; num126++) {
									if (SolidTile(num125, num126)) {
										flag26 = true;
										break;
									}
								}
							}

							if (flag26 && !Main.tile[num63, num64].active()) {
								PlaceTile(num63, num64, 51, mute: true);
								TileFrame(num63, num64, resetFrame: true);
								if (Main.netMode == 2)
									NetMessage.SendTileSquare(-1, num63, num64, 3);
							}
						}

						if (flag)
							TrySpawningTownNPC(num63, num64);
					}
				}

				if (Main.tile[num63, num64].wall == 81 || Main.tile[num63, num64].wall == 83 || (Main.tile[num63, num64].type == 199 && Main.tile[num63, num64].active())) {
					int num127 = num63 + genRand.Next(-2, 3);
					int num128 = num64 + genRand.Next(-2, 3);
					if (Main.tile[num127, num128].wall >= 63 && Main.tile[num127, num128].wall <= 68) {
						bool flag27 = false;
						for (int num129 = num63 - num; num129 < num63 + num; num129++) {
							for (int num130 = num64 - num; num130 < num64 + num; num130++) {
								if (Main.tile[num63, num64].active()) {
									int type10 = Main.tile[num63, num64].type;
									if (type10 == 199 || type10 == 200 || type10 == 201 || type10 == 203 || type10 == 205 || type10 == 234 || type10 == 352) {
										flag27 = true;
										break;
									}
								}
							}
						}

						if (flag27) {
							Main.tile[num127, num128].wall = 81;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num127, num128, 3);
						}
					}
				}

				if (Main.tile[num63, num64].wall == 69 || Main.tile[num63, num64].wall == 3 || (Main.tile[num63, num64].type == 23 && Main.tile[num63, num64].active())) {
					int num131 = num63 + genRand.Next(-2, 3);
					int num132 = num64 + genRand.Next(-2, 3);
					if (Main.tile[num131, num132].wall >= 63 && Main.tile[num131, num132].wall <= 68) {
						bool flag28 = false;
						for (int num133 = num63 - num; num133 < num63 + num; num133++) {
							for (int num134 = num64 - num; num134 < num64 + num; num134++) {
								if (Main.tile[num63, num64].active()) {
									int type11 = Main.tile[num63, num64].type;
									if (type11 == 22 || type11 == 23 || type11 == 24 || type11 == 25 || type11 == 32 || type11 == 112 || type11 == 163) {
										flag28 = true;
										break;
									}
								}
							}
						}

						if (flag28) {
							Main.tile[num131, num132].wall = 69;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num131, num132, 3);
						}
					}
				}

				if (Main.tile[num63, num64].wall == 70 || (Main.tile[num63, num64].type == 109 && Main.tile[num63, num64].active())) {
					int num135 = num63 + genRand.Next(-2, 3);
					int num136 = num64 + genRand.Next(-2, 3);
					if (Main.tile[num135, num136].wall == 63 || Main.tile[num135, num136].wall == 65 || Main.tile[num135, num136].wall == 66 || Main.tile[num135, num136].wall == 68) {
						bool flag29 = false;
						for (int num137 = num63 - num; num137 < num63 + num; num137++) {
							for (int num138 = num64 - num; num138 < num64 + num; num138++) {
								if (Main.tile[num63, num64].active()) {
									int type12 = Main.tile[num63, num64].type;
									if (type12 == 109 || type12 == 110 || type12 == 113 || type12 == 115 || type12 == 116 || type12 == 117 || type12 == 164) {
										flag29 = true;
										break;
									}
								}
							}
						}

						if (flag29) {
							Main.tile[num135, num136].wall = 70;
							if (Main.netMode == 2)
								NetMessage.SendTileSquare(-1, num135, num136, 3);
						}
					}
				}

				SpreadDesertWalls(num, num63, num64);
				TileLoader.RandomUpdate(num63, num64, Main.tile[num63, num64].type);
				WallLoader.RandomUpdate(num63, num64, Main.tile[num63, num64].wall);
			}

			if (!Main.dayTime) {
				float num139 = Main.maxTilesX / 4200f; // Selfish fix for falling stars on extra small worlds
				if ((float)Main.rand.Next(8000) < 10f * num139) {
					int num140 = Main.rand.Next(Main.maxTilesX - 50) + 100;
					num140 *= 16;
					int num141 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
					num141 *= 16;
					Vector2 vector = new Vector2(num140, num141);
					float num142 = Main.rand.Next(-100, 101);
					float num143 = Main.rand.Next(200) + 100;
					float num144 = (float)Math.Sqrt(num142 * num142 + num143 * num143);
					num144 = 12f / num144;
					num142 *= num144;
					num143 *= num144;
					Projectile.NewProjectile(vector.X, vector.Y, num142, num143, 12, 1000, 10f, Main.myPlayer);
				}
			}

			WorldHooks.PostUpdate();
		}

		private static void TrySpawningTownNPC(int x, int y) {
			if (prioritizedTownNPC <= 0)
				return;

			if (Main.tile[x, y].wall == 34) {
				if (Main.rand.Next(4) == 0)
					SpawnTownNPC(x, y);
			}
			else {
				SpawnTownNPC(x, y);
			}
		}

		public static void SpreadDesertWalls(int wallDist, int i, int j) {
			if (!WallID.Sets.Conversion.Sandstone[Main.tile[i, j].wall] && (!Main.tile[i, j].active() || !TileID.Sets.Conversion.Sandstone[Main.tile[i, j].type]) && !WallID.Sets.Conversion.HardenedSand[Main.tile[i, j].wall])
				return;

			int num = 0;
			int wall = Main.tile[i, j].wall;
			int type = Main.tile[i, j].type;
			if (WallID.Sets.Corrupt[wall] || TileID.Sets.Corrupt[type])
				num = 1;

			if (WallID.Sets.Hallow[wall] || TileID.Sets.Hallow[type])
				num = 2;

			if (WallID.Sets.Crimson[wall] || TileID.Sets.Crimson[type])
				num = 3;

			if (num == 0)
				return;

			int num2 = i + genRand.Next(-2, 3);
			int num3 = j + genRand.Next(-2, 3);
			bool flag = false;
			if (WallID.Sets.Conversion.Sandstone[Main.tile[num2, num3].wall] || WallID.Sets.Conversion.HardenedSand[Main.tile[num2, num3].wall]) {
				switch (num) {
					case 3: {
							for (int m = i - wallDist; m < i + wallDist; m++) {
								for (int n = j - wallDist; n < j + wallDist; n++) {
									if (Main.tile[m, n].active() && TileID.Sets.Crimson[Main.tile[m, n].type]) {
										flag = true;
										break;
									}
								}

								if (flag)
									break;
							}

							break;
						}
					case 2: {
							for (int num4 = i - wallDist; num4 < i + wallDist; num4++) {
								for (int num5 = j - wallDist; num5 < j + wallDist; num5++) {
									if (Main.tile[num4, num5].active() && TileID.Sets.Hallow[Main.tile[num4, num5].type]) {
										flag = true;
										break;
									}
								}

								if (flag)
									break;
							}

							break;
						}
					case 1: {
							for (int k = i - wallDist; k < i + wallDist; k++) {
								for (int l = j - wallDist; l < j + wallDist; l++) {
									if (Main.tile[k, l].active() && TileID.Sets.Corrupt[Main.tile[k, l].type]) {
										flag = true;
										break;
									}
								}

								if (flag)
									break;
							}

							break;
						}
				}
			}

			if (!flag)
				return;

			byte? b = null;
			if (WallID.Sets.Conversion.Sandstone[Main.tile[num2, num3].wall]) {
				switch (num) {
					case 3:
						b = 221;
						break;
					case 2:
						b = 222;
						break;
					case 1:
						b = 220;
						break;
				}
			}

			if (WallID.Sets.Conversion.HardenedSand[Main.tile[num2, num3].wall]) {
				switch (num) {
					case 3:
						b = 218;
						break;
					case 2:
						b = 219;
						break;
					case 1:
						b = 217;
						break;
				}
			}

			if (b.HasValue && Main.tile[num2, num3].wall != b.Value) {
				Main.tile[num2, num3].wall = b.Value;
				if (Main.netMode == 2)
					NetMessage.SendTileSquare(-1, num2, num3, 3);
			}
		}

		public static void PlaceWall(int i, int j, int type, bool mute = false) {
			if (i <= 1 || j <= 1 || i >= Main.maxTilesX - 2 || j >= Main.maxTilesY - 2)
				return;

			if (Main.tile[i, j] == null)
				Main.tile[i, j] = new Tile();

			if (Main.tile[i, j].wall == 0) {
				Main.tile[i, j].wall = (ushort)type;
				SquareWallFrame(i, j);
				if (!mute)
					Main.PlaySound(0, i * 16, j * 16);
			}
		}

		public static void AddPlants() {
			for (int i = 0; i < Main.maxTilesX; i++) {
				for (int j = 1; j < Main.maxTilesY; j++) {
					if (Main.tile[i, j].type == 2 && Main.tile[i, j].nactive()) {
						if (!Main.tile[i, j - 1].active())
							PlaceTile(i, j - 1, 3, mute: true);
					}
					else if (Main.tile[i, j].type == 23 && Main.tile[i, j].nactive()) {
						if (!Main.tile[i, j - 1].active())
							PlaceTile(i, j - 1, 24, mute: true);
					}
					else if (Main.tile[i, j].type == 199 && Main.tile[i, j].nactive() && !Main.tile[i, j - 1].active()) {
						PlaceTile(i, j - 1, 201, mute: true);
					}
				}
			}
		}

		public static void SpreadGrass(int i, int j, int dirt = 0, int grass = 2, bool repeat = true, byte color = 0) {
			try {
				if (!InWorld(i, j, 1) || Main.tile[i, j].type != dirt || !Main.tile[i, j].active() || ((double)j >= Main.worldSurface && dirt == 0))
					return;

				int num = i - 1;
				int num2 = i + 2;
				int num3 = j - 1;
				int num4 = j + 2;
				if (num < 0)
					num = 0;

				if (num2 > Main.maxTilesX)
					num2 = Main.maxTilesX;

				if (num3 < 0)
					num3 = 0;

				if (num4 > Main.maxTilesY)
					num4 = Main.maxTilesY;

				bool flag = true;
				for (int k = num; k < num2; k++) {
					for (int l = num3; l < num4; l++) {
						if (!Main.tile[k, l].active() || !Main.tileSolid[Main.tile[k, l].type])
							flag = false;

						if (Main.tile[k, l].lava() && Main.tile[k, l].liquid > 0) {
							flag = true;
							break;
						}
					}
				}

				if (flag || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[i, j].type] || (grass == 23 && Main.tile[i, j - 1].type == 27) || (grass == 199 && Main.tile[i, j - 1].type == 27))
					return;

				Main.tile[i, j].type = (ushort)grass;
				Main.tile[i, j].color(color);
				for (int m = num; m < num2; m++) {
					for (int n = num3; n < num4; n++) {
						if (!Main.tile[m, n].active() || Main.tile[m, n].type != dirt)
							continue;

						try {
							if (repeat && grassSpread < 1000) {
								grassSpread++;
								SpreadGrass(m, n, dirt, grass, repeat: true, 0);
								grassSpread--;
							}
						}
						catch {
						}
					}
				}
			}
			catch {
			}
		}

		public static void ChasmRunnerSideways(int i, int j, int direction, int steps) {
			float num = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(10, 21) * 0.1f * (float)direction;
			vector2.Y = (float)genRand.Next(-10, 10) * 0.01f;
			double num2 = genRand.Next(5) + 7;
			while (num2 > 0.0) {
				if (num > 0f) {
					num2 += (double)genRand.Next(3);
					num2 -= (double)genRand.Next(3);
					if (num2 < 7.0)
						num2 = 7.0;

					if (num2 > 20.0)
						num2 = 20.0;

					if (num == 1f && num2 < 10.0)
						num2 = 10.0;
				}
				else {
					num2 -= (double)genRand.Next(4);
				}

				if ((double)vector.Y > Main.rockLayer && num > 0f)
					num = 0f;

				num -= 1f;
				int num3 = (int)((double)vector.X - num2 * 0.5);
				int num4 = (int)((double)vector.X + num2 * 0.5);
				int num5 = (int)((double)vector.Y - num2 * 0.5);
				int num6 = (int)((double)vector.Y + num2 * 0.5);
				if (num3 < 0)
					num3 = 0;

				if (num4 > Main.maxTilesX - 1)
					num4 = Main.maxTilesX - 1;

				if (num5 < 0)
					num5 = 0;

				if (num6 > Main.maxTilesY)
					num6 = Main.maxTilesY;

				for (int k = num3; k < num4; k++) {
					for (int l = num5; l < num6; l++) {
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
							Main.tile[k, l].active(active: false);
					}
				}

				vector += vector2;
				vector2.Y += (float)genRand.Next(-10, 10) * 0.1f;
				if (vector.Y < (float)(j - 20))
					vector2.Y += (float)genRand.Next(20) * 0.01f;

				if (vector.Y > (float)(j + 20))
					vector2.Y -= (float)genRand.Next(20) * 0.01f;

				if ((double)vector2.Y < -0.5)
					vector2.Y = -0.5f;

				if ((double)vector2.Y > 0.5)
					vector2.Y = 0.5f;

				vector2.X += (float)genRand.Next(-10, 11) * 0.01f;
				switch (direction) {
					case -1:
						if ((double)vector2.X > -0.5)
							vector2.X = -0.5f;
						if (vector2.X < -2f)
							vector2.X = -2f;
						break;
					case 1:
						if ((double)vector2.X < 0.5)
							vector2.X = 0.5f;
						if (vector2.X > 2f)
							vector2.X = 2f;
						break;
				}

				num3 = (int)((double)vector.X - num2 * 1.1);
				num4 = (int)((double)vector.X + num2 * 1.1);
				num5 = (int)((double)vector.Y - num2 * 1.1);
				num6 = (int)((double)vector.Y + num2 * 1.1);
				if (num3 < 1)
					num3 = 1;

				if (num4 > Main.maxTilesX - 1)
					num4 = Main.maxTilesX - 1;

				if (num5 < 0)
					num5 = 0;

				if (num6 > Main.maxTilesY)
					num6 = Main.maxTilesY;

				for (int m = num3; m < num4; m++) {
					for (int n = num5; n < num6; n++) {
						if ((double)(Math.Abs((float)m - vector.X) + Math.Abs((float)n - vector.Y)) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[m, n].wall != 3) {
							if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
								Main.tile[m, n].active(active: true);

							Main.tile[m, n].active(active: true);
							if (Main.tile[m, n].type != 31 && Main.tile[m, n].type != 22)
								Main.tile[m, n].type = 25;

							if (Main.tile[m, n].wall == 2)
								Main.tile[m, n].wall = 0;
						}
					}
				}

				for (int num7 = num3; num7 < num4; num7++) {
					for (int num8 = num5; num8 < num6; num8++) {
						if ((double)(Math.Abs((float)num7 - vector.X) + Math.Abs((float)num8 - vector.Y)) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[num7, num8].wall != 3) {
							if (Main.tile[num7, num8].type != 31 && Main.tile[num7, num8].type != 22)
								Main.tile[num7, num8].type = 25;

							Main.tile[num7, num8].active(active: true);
							PlaceWall(num7, num8, 3, mute: true);
						}
					}
				}
			}

			if (genRand.Next(3) == 0) {
				int num9 = (int)vector.X;
				int num10;
				for (num10 = (int)vector.Y; !Main.tile[num9, num10].active(); num10++) {
				}

				TileRunner(num9, num10, genRand.Next(2, 6), genRand.Next(3, 7), 22);
			}
		}

		public static void CrimStart(int i, int j) {
			int crimDir = 1;
			heartCount = 0;
			// crimson = true;
			int k = j;
			if ((double)k > Main.worldSurface)
				k = (int)Main.worldSurface;

			for (; !SolidTile(i, k); k++) {
			}

			int num = k;
			Vector2 position = new Vector2(i, k);
			Vector2 vector = new Vector2((float)genRand.Next(-20, 21) * 0.1f, (float)genRand.Next(20, 201) * 0.01f);
			if (vector.X < 0f)
				crimDir = -1;

			float num2 = genRand.Next(15, 26);
			bool flag = true;
			int num3 = 0;
			while (flag) {
				num2 += (float)genRand.Next(-50, 51) * 0.01f;
				if (num2 < 15f)
					num2 = 15f;

				if (num2 > 25f)
					num2 = 25f;

				for (int l = (int)(position.X - num2 / 2f); (float)l < position.X + num2 / 2f; l++) {
					for (int m = (int)(position.Y - num2 / 2f); (float)m < position.Y + num2 / 2f; m++) {
						if (m > num) {
							if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.3) {
								Main.tile[l, m].active(active: false);
								Main.tile[l, m].wall = 83;
							}
							else if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.8 && Main.tile[l, m].wall != 83) {
								Main.tile[l, m].active(active: true);
								Main.tile[l, m].type = 203;
								if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.6)
									Main.tile[l, m].wall = 83;
							}
						}
						else if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.3 && Main.tile[l, m].active()) {
							Main.tile[l, m].active(active: false);
							Main.tile[l, m].wall = 83;
						}
					}
				}

				if (position.X > (float)(i + 50))
					num3 = -100;

				if (position.X < (float)(i - 50))
					num3 = 100;

				if (num3 < 0)
					vector.X -= (float)genRand.Next(20, 51) * 0.01f;
				else if (num3 > 0)
					vector.X += (float)genRand.Next(20, 51) * 0.01f;
				else
					vector.X += (float)genRand.Next(-50, 51) * 0.01f;

				vector.Y += (float)genRand.Next(-50, 51) * 0.01f;
				if ((double)vector.Y < 0.25)
					vector.Y = 0.25f;

				if (vector.Y > 2f)
					vector.Y = 2f;

				if (vector.X < -2f)
					vector.X = -2f;

				if (vector.X > 2f)
					vector.X = 2f;

				position += vector;
				if ((double)position.Y > Main.worldSurface + 100.0)
					flag = false;
			}

			num2 = genRand.Next(40, 55);
			for (int n = 0; n < 50; n++) {
				int num4 = (int)position.X + genRand.Next(-20, 21);
				int num5 = (int)position.Y + genRand.Next(-20, 21);
				for (int num6 = (int)((float)num4 - num2 / 2f); (float)num6 < (float)num4 + num2 / 2f; num6++) {
					for (int num7 = (int)((float)num5 - num2 / 2f); (float)num7 < (float)num5 + num2 / 2f; num7++) {
						float num8 = Math.Abs(num6 - num4);
						float num9 = Math.Abs(num7 - num5);
						float num10 = 1f + (float)genRand.Next(-20, 21) * 0.01f;
						float num11 = 1f + (float)genRand.Next(-20, 21) * 0.01f;
						float num12 = num8 * num10;
						num9 *= num11;
						double num13 = Math.Sqrt(num12 * num12 + num9 * num9);
						if (num13 < (double)num2 * 0.25) {
							Main.tile[num6, num7].active(active: false);
							Main.tile[num6, num7].wall = 83;
						}
						else if (num13 < (double)num2 * 0.4 && Main.tile[num6, num7].wall != 83) {
							Main.tile[num6, num7].active(active: true);
							Main.tile[num6, num7].type = 203;
							if (num13 < (double)num2 * 0.35)
								Main.tile[num6, num7].wall = 83;
						}
					}
				}
			}

			int num14 = genRand.Next(5, 9);
			Vector2[] array = new Vector2[num14];
			for (int num15 = 0; num15 < num14; num15++) {
				int num16 = (int)position.X;
				int num17 = (int)position.Y;
				int num18 = 0;
				bool flag2 = true;
				Vector2 vector2 = new Vector2((float)genRand.Next(-20, 21) * 0.15f, (float)genRand.Next(0, 21) * 0.15f);
				while (flag2) {
					vector2 = new Vector2((float)genRand.Next(-20, 21) * 0.15f, (float)genRand.Next(0, 21) * 0.15f);
					while ((double)(Math.Abs(vector2.X) + Math.Abs(vector2.Y)) < 1.5) {
						vector2 = new Vector2((float)genRand.Next(-20, 21) * 0.15f, (float)genRand.Next(0, 21) * 0.15f);
					}

					flag2 = false;
					for (int num19 = 0; num19 < num15; num19++) {
						if ((double)vector.X > (double)array[num19].X - 0.75 && (double)vector.X < (double)array[num19].X + 0.75 && (double)vector.Y > (double)array[num19].Y - 0.75 && (double)vector.Y < (double)array[num19].Y + 0.75) {
							flag2 = true;
							num18++;
							break;
						}
					}

					if (num18 > 10000)
						break;
				}

				array[num15] = vector2;
				CrimVein(new Vector2(num16, num17), vector2);
			}

			for (int num20 = 0; num20 < heartCount; num20++) {
				num2 = genRand.Next(16, 21);
				int num21 = (int)heartPos[num20].X;
				int num22 = (int)heartPos[num20].Y;
				for (int num23 = (int)((float)num21 - num2 / 2f); (float)num23 < (float)num21 + num2 / 2f; num23++) {
					for (int num24 = (int)((float)num22 - num2 / 2f); (float)num24 < (float)num22 + num2 / 2f; num24++) {
						float num25 = Math.Abs(num23 - num21);
						float num26 = Math.Abs(num24 - num22);
						if (Math.Sqrt(num25 * num25 + num26 * num26) < (double)num2 * 0.4) {
							Main.tile[num23, num24].active(active: true);
							Main.tile[num23, num24].type = 203;
							Main.tile[num23, num24].wall = 83;
						}
					}
				}
			}

			for (int num27 = 0; num27 < heartCount; num27++) {
				num2 = genRand.Next(10, 14);
				int num28 = (int)heartPos[num27].X;
				int num29 = (int)heartPos[num27].Y;
				for (int num30 = (int)((float)num28 - num2 / 2f); (float)num30 < (float)num28 + num2 / 2f; num30++) {
					for (int num31 = (int)((float)num29 - num2 / 2f); (float)num31 < (float)num29 + num2 / 2f; num31++) {
						float num32 = Math.Abs(num30 - num28);
						float num33 = Math.Abs(num31 - num29);
						if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num2 * 0.3) {
							Main.tile[num30, num31].active(active: false);
							Main.tile[num30, num31].wall = 83;
						}
					}
				}
			}

			for (int num34 = 0; num34 < heartCount; num34++) {
				AddShadowOrb((int)heartPos[num34].X, (int)heartPos[num34].Y, false);
			}

			int num35 = Main.maxTilesX;
			int num36 = 0;
			position.X = i;
			position.Y = num;
			num2 = genRand.Next(25, 35);
			float num37 = genRand.Next(0, 6);
			for (int num38 = 0; num38 < 50; num38++) {
				if (num37 > 0f) {
					float num39 = (float)genRand.Next(10, 30) * 0.01f;
					num37 -= num39;
					position.Y -= num39;
				}

				int num40 = (int)position.X + genRand.Next(-2, 3);
				int num41 = (int)position.Y + genRand.Next(-2, 3);
				for (int num42 = (int)((float)num40 - num2 / 2f); (float)num42 < (float)num40 + num2 / 2f; num42++) {
					for (int num43 = (int)((float)num41 - num2 / 2f); (float)num43 < (float)num41 + num2 / 2f; num43++) {
						float num44 = Math.Abs(num42 - num40);
						float num45 = Math.Abs(num43 - num41);
						float num46 = 1f + (float)genRand.Next(-20, 21) * 0.005f;
						float num47 = 1f + (float)genRand.Next(-20, 21) * 0.005f;
						float num48 = num44 * num46;
						num45 *= num47;
						double num49 = Math.Sqrt(num48 * num48 + num45 * num45);
						if (num49 < (double)num2 * 0.2 * ((double)genRand.Next(90, 111) * 0.01)) {
							Main.tile[num42, num43].active(active: false);
							Main.tile[num42, num43].wall = 83;
						}
						else {
							if (!(num49 < (double)num2 * 0.45))
								continue;

							if (num42 < num35)
								num35 = num42;

							if (num42 > num36)
								num36 = num42;

							if (Main.tile[num42, num43].wall != 83) {
								Main.tile[num42, num43].active(active: true);
								Main.tile[num42, num43].type = 203;
								if (num49 < (double)num2 * 0.35)
									Main.tile[num42, num43].wall = 83;
							}
						}
					}
				}
			}

			for (int num50 = num35; num50 <= num36; num50++) {
				int num51;
				for (num51 = num; (Main.tile[num50, num51].type == 203 && Main.tile[num50, num51].active()) || Main.tile[num50, num51].wall == 83; num51++) {
				}

				int num52 = genRand.Next(15, 20);
				for (; !Main.tile[num50, num51].active(); num51++) {
					if (num52 <= 0)
						break;

					if (Main.tile[num50, num51].wall == 83)
						break;

					num52--;
					Main.tile[num50, num51].type = 203;
					Main.tile[num50, num51].active(active: true);
				}
			}

			CrimEnt(position, crimDir);
		}

		public static void CrimEnt(Vector2 position, int crimDir) {
			float num = 0f;
			float num2 = genRand.Next(6, 11);
			bool flag = true;
			Vector2 vector = new Vector2(2f, (float)genRand.Next(-20, 0) * 0.01f);
			vector.X *= -crimDir;
			while (flag) {
				num += 1f;
				if (num >= 20f)
					flag = false;

				num2 += (float)genRand.Next(-10, 11) * 0.02f;
				if (num2 < 6f)
					num2 = 6f;

				if (num2 > 10f)
					num2 = 10f;

				for (int i = (int)(position.X - num2 / 2f); (float)i < position.X + num2 / 2f; i++) {
					for (int j = (int)(position.Y - num2 / 2f); (float)j < position.Y + num2 / 2f; j++) {
						float num3 = Math.Abs((float)i - position.X);
						float num4 = Math.Abs((float)j - position.Y);
						if (Math.Sqrt(num3 * num3 + num4 * num4) < (double)num2 * 0.5 && Main.tile[i, j].active() && Main.tile[i, j].type == 203) {
							Main.tile[i, j].active(active: false);
							flag = true;
							num = 0f;
						}
					}
				}

				position += vector;
			}
		}

		public static void CrimVein(Vector2 position, Vector2 velocity) {
			float num = genRand.Next(15, 26);
			bool flag = true;
			Vector2 vector = velocity;
			Vector2 vector2 = position;
			int num2 = genRand.Next(100, 150);
			if (velocity.Y < 0f)
				num2 -= 25;

			while (flag) {
				num += (float)genRand.Next(-50, 51) * 0.02f;
				if (num < 15f)
					num = 15f;

				if (num > 25f)
					num = 25f;

				for (int i = (int)(position.X - num / 2f); (float)i < position.X + num / 2f; i++) {
					for (int j = (int)(position.Y - num / 2f); (float)j < position.Y + num / 2f; j++) {
						float num3 = Math.Abs((float)i - position.X);
						float num4 = Math.Abs((float)j - position.Y);
						double num5 = Math.Sqrt(num3 * num3 + num4 * num4);
						if (num5 < (double)num * 0.2) {
							Main.tile[i, j].active(active: false);
							Main.tile[i, j].wall = 83;
						}
						else if (num5 < (double)num * 0.5 && Main.tile[i, j].wall != 83) {
							Main.tile[i, j].active(active: true);
							Main.tile[i, j].type = 203;
							if (num5 < (double)num * 0.4)
								Main.tile[i, j].wall = 83;
						}
					}
				}

				velocity.X += (float)genRand.Next(-50, 51) * 0.05f;
				velocity.Y += (float)genRand.Next(-50, 51) * 0.05f;
				if ((double)velocity.Y < (double)vector.Y - 0.75)
					velocity.Y = vector.Y - 0.75f;

				if ((double)velocity.Y > (double)vector.Y + 0.75)
					velocity.Y = vector.Y + 0.75f;

				if ((double)velocity.X < (double)vector.X - 0.75)
					velocity.X = vector.X - 0.75f;

				if ((double)velocity.X > (double)vector.X + 0.75)
					velocity.X = vector.X + 0.75f;

				position += velocity;
				if (Math.Abs(position.X - vector2.X) + Math.Abs(position.Y - vector2.Y) > (float)num2)
					flag = false;
			}

			heartPos[heartCount] = position;
			heartCount++;
		}

		public static void ChasmRunner(int i, int j, int steps, bool makeOrb = false) {
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			if (!makeOrb)
				flag2 = true;

			float num = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(11) * 0.2f + 0.5f;
			int num2 = 5;
			double num3 = genRand.Next(5) + 7;
			while (num3 > 0.0) {
				if (num > 0f) {
					num3 += (double)genRand.Next(3);
					num3 -= (double)genRand.Next(3);
					if (num3 < 7.0)
						num3 = 7.0;

					if (num3 > 20.0)
						num3 = 20.0;

					if (num == 1f && num3 < 10.0)
						num3 = 10.0;
				}
				else if ((double)vector.Y > Main.worldSurface + 45.0) {
					num3 -= (double)genRand.Next(4);
				}

				if ((double)vector.Y > Main.rockLayer && num > 0f)
					num = 0f;

				num -= 1f;
				if (!flag && (double)vector.Y > Main.worldSurface + 20.0) {
					flag = true;
					ChasmRunnerSideways((int)vector.X, (int)vector.Y, -1, genRand.Next(20, 40));
					ChasmRunnerSideways((int)vector.X, (int)vector.Y, 1, genRand.Next(20, 40));
				}

				int num4;
				int num5;
				int num6;
				int num7;
				if (num > (float)num2) {
					num4 = (int)((double)vector.X - num3 * 0.5);
					num5 = (int)((double)vector.X + num3 * 0.5);
					num6 = (int)((double)vector.Y - num3 * 0.5);
					num7 = (int)((double)vector.Y + num3 * 0.5);
					if (num4 < 0)
						num4 = 0;

					if (num5 > Main.maxTilesX - 1)
						num5 = Main.maxTilesX - 1;

					if (num6 < 0)
						num6 = 0;

					if (num7 > Main.maxTilesY)
						num7 = Main.maxTilesY;

					for (int k = num4; k < num5; k++) {
						for (int l = num6; l < num7; l++) {
							if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num3 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
								Main.tile[k, l].active(active: false);
						}
					}
				}

				if (num <= 2f && (double)vector.Y < Main.worldSurface + 45.0)
					num = 2f;

				if (num <= 0f) {
					if (!flag2 && !Main.setting.NoOrbHeart) {
						flag2 = true;
						WorldGen.AddShadowOrb((int)vector.X, (int)vector.Y, true);
					}
					else if (!flag3) {
						flag3 = false;
						bool flag4 = false;
						int num8 = 0;
						while (!flag4) {
							int num9 = genRand.Next((int)vector.X - 25, (int)vector.X + 25);
							int num10 = genRand.Next((int)vector.Y - 50, (int)vector.Y);
							if (num9 < 5)
								num9 = 5;

							if (num9 > Main.maxTilesX - 5)
								num9 = Main.maxTilesX - 5;

							if (num10 < 5)
								num10 = 5;

							if (num10 > Main.maxTilesY - 5)
								num10 = Main.maxTilesY - 5;

							if ((double)num10 > Main.worldSurface) {
								if (Main.setting.NoAltar)
								{
									flag4 = true;
								}
								else
								{
									WorldGen.Place3x2(num9, num10, 26, 0);
								}
								if (Main.tile[num9, num10].type == 26) {
									flag4 = true;
									continue;
								}

								num8++;
								if (num8 >= 10000)
									flag4 = true;
							}
							else {
								flag4 = true;
							}
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.01f;
				if ((double)vector2.X > 0.3)
					vector2.X = 0.3f;

				if ((double)vector2.X < -0.3)
					vector2.X = -0.3f;

				num4 = (int)((double)vector.X - num3 * 1.1);
				num5 = (int)((double)vector.X + num3 * 1.1);
				num6 = (int)((double)vector.Y - num3 * 1.1);
				num7 = (int)((double)vector.Y + num3 * 1.1);
				if (num4 < 1)
					num4 = 1;

				if (num5 > Main.maxTilesX - 1)
					num5 = Main.maxTilesX - 1;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				for (int m = num4; m < num5; m++) {
					for (int n = num6; n < num7; n++) {
						if ((double)(Math.Abs((float)m - vector.X) + Math.Abs((float)n - vector.Y)) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)) {
							if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
								Main.tile[m, n].active(active: true);

							if (steps <= num2)
								Main.tile[m, n].active(active: true);

							if (Main.tile[m, n].type != 31)
								Main.tile[m, n].type = 25;
						}
					}
				}

				for (int num11 = num4; num11 < num5; num11++) {
					for (int num12 = num6; num12 < num7; num12++) {
						if ((double)(Math.Abs((float)num11 - vector.X) + Math.Abs((float)num12 - vector.Y)) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)) {
							if (Main.tile[num11, num12].type != 31)
								Main.tile[num11, num12].type = 25;

							if (steps <= num2)
								Main.tile[num11, num12].active(active: true);

							if (num12 > j + genRand.Next(3, 20))
								Main.tile[num11, num12].wall = 3;
						}
					}
				}
			}
		}

		public static void JungleRunner(int i, int j) {
			double num = genRand.Next(5, 11);
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(10, 20) * 0.1f;
			int num2 = 0;
			bool flag = true;
			while (flag) {
				if ((double)vector.Y < Main.worldSurface) {
					int value = (int)vector.X;
					int value2 = (int)vector.Y;
					value = Utils.Clamp(value, 10, Main.maxTilesX - 10);
					value2 = Utils.Clamp(value2, 10, Main.maxTilesY - 10);
					if (value2 < 5)
						value2 = 5;

					if (Main.tile[value, value2].wall == 0 && !Main.tile[value, value2].active() && Main.tile[value, value2 - 3].wall == 0 && !Main.tile[value, value2 - 3].active() && Main.tile[value, value2 - 1].wall == 0 && !Main.tile[value, value2 - 1].active() && Main.tile[value, value2 - 4].wall == 0 && !Main.tile[value, value2 - 4].active() && Main.tile[value, value2 - 2].wall == 0 && !Main.tile[value, value2 - 2].active() && Main.tile[value, value2 - 5].wall == 0 && !Main.tile[value, value2 - 5].active())
						flag = false;
				}

				JungleX = (int)vector.X;
				num += (double)((float)genRand.Next(-20, 21) * 0.1f);
				if (num < 5.0)
					num = 5.0;

				if (num > 10.0)
					num = 10.0;

				int value3 = (int)((double)vector.X - num * 0.5);
				int value4 = (int)((double)vector.X + num * 0.5);
				int value5 = (int)((double)vector.Y - num * 0.5);
				int value6 = (int)((double)vector.Y + num * 0.5);
				int num3 = Utils.Clamp(value3, 10, Main.maxTilesX - 10);
				value4 = Utils.Clamp(value4, 10, Main.maxTilesX - 10);
				value5 = Utils.Clamp(value5, 10, Main.maxTilesY - 10);
				value6 = Utils.Clamp(value6, 10, Main.maxTilesY - 10);
				for (int k = num3; k < value4; k++) {
					for (int l = value5; l < value6; l++) {
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
							KillTile(k, l);
					}
				}

				num2++;
				if (num2 > 10 && genRand.Next(50) < num2) {
					num2 = 0;
					int num4 = -2;
					if (genRand.Next(2) == 0)
						num4 = 2;

					TileRunner((int)vector.X, (int)vector.Y, genRand.Next(3, 20), genRand.Next(10, 100), -1, addTile: false, num4);
				}

				vector += vector2;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.01f;
				if (vector2.Y > 0f)
					vector2.Y = 0f;

				if (vector2.Y < -2f)
					vector2.Y = -2f;

				vector2.X += (float)genRand.Next(-10, 11) * 0.1f;
				if (vector.X < (float)(i - 200))
					vector2.X += (float)genRand.Next(5, 21) * 0.1f;

				if (vector.X > (float)(i + 200))
					vector2.X -= (float)genRand.Next(5, 21) * 0.1f;

				if ((double)vector2.X > 1.5)
					vector2.X = 1.5f;

				if ((double)vector2.X < -1.5)
					vector2.X = -1.5f;
			}
		}

		public static void GERunner(int i, int j, float speedX = 0f, float speedY = 0f, bool good = true) {
			int num = genRand.Next(200, 250);
			float num2 = Main.maxTilesX / 4200f;
			num = (int)((float)num * num2);
			double num3 = num;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			if (speedX != 0f || speedY != 0f) {
				vector2.X = speedX;
				vector2.Y = speedY;
			}

			bool flag = true;
			while (flag) {
				int num4 = (int)((double)vector.X - num3 * 0.5);
				int num5 = (int)((double)vector.X + num3 * 0.5);
				int num6 = (int)((double)vector.Y - num3 * 0.5);
				int num7 = (int)((double)vector.Y + num3 * 0.5);
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				for (int k = num4; k < num5; k++) {
					for (int l = num6; l < num7; l++) {
						if (!((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < (double)num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
							continue;

						if (good) {
							if (Main.tile[k, l].wall == 63 || Main.tile[k, l].wall == 65 || Main.tile[k, l].wall == 66 || Main.tile[k, l].wall == 68 || Main.tile[k, l].wall == 69 || Main.tile[k, l].wall == 81)
								Main.tile[k, l].wall = 70;
							else if (Main.tile[k, l].wall == 216)
								Main.tile[k, l].wall = 219;
							else if (Main.tile[k, l].wall == 187)
								Main.tile[k, l].wall = 222;

							if (Main.tile[k, l].wall == 3 || Main.tile[k, l].wall == 83)
								Main.tile[k, l].wall = 28;

							if (Main.tile[k, l].type == 2) {
								Main.tile[k, l].type = 109;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 1) {
								Main.tile[k, l].type = 117;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 53 || Main.tile[k, l].type == 123) {
								Main.tile[k, l].type = 116;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 23 || Main.tile[k, l].type == 199) {
								Main.tile[k, l].type = 109;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 25 || Main.tile[k, l].type == 203) {
								Main.tile[k, l].type = 117;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 112 || Main.tile[k, l].type == 234) {
								Main.tile[k, l].type = 116;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 161 || Main.tile[k, l].type == 163 || Main.tile[k, l].type == 200) {
								Main.tile[k, l].type = 164;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 396) {
								Main.tile[k, l].type = 403;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 397) {
								Main.tile[k, l].type = 402;
								SquareTileFrame(k, l);
							}
						}
						else if (crimson) {
							if (Main.tile[k, l].wall == 63 || Main.tile[k, l].wall == 65 || Main.tile[k, l].wall == 66 || Main.tile[k, l].wall == 68)
								Main.tile[k, l].wall = 81;
							else if (Main.tile[k, l].wall == 216)
								Main.tile[k, l].wall = 218;
							else if (Main.tile[k, l].wall == 187)
								Main.tile[k, l].wall = 221;

							if (Main.tile[k, l].type == 2) {
								Main.tile[k, l].type = 199;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 1) {
								Main.tile[k, l].type = 203;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 53 || Main.tile[k, l].type == 123) {
								Main.tile[k, l].type = 234;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 109) {
								Main.tile[k, l].type = 199;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 117) {
								Main.tile[k, l].type = 203;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 116) {
								Main.tile[k, l].type = 234;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 161 || Main.tile[k, l].type == 164) {
								Main.tile[k, l].type = 200;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 396) {
								Main.tile[k, l].type = 401;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 397) {
								Main.tile[k, l].type = 399;
								SquareTileFrame(k, l);
							}
						}
						else {
							if (Main.tile[k, l].wall == 63 || Main.tile[k, l].wall == 65 || Main.tile[k, l].wall == 66 || Main.tile[k, l].wall == 68)
								Main.tile[k, l].wall = 69;
							else if (Main.tile[k, l].wall == 216)
								Main.tile[k, l].wall = 217;
							else if (Main.tile[k, l].wall == 187)
								Main.tile[k, l].wall = 220;

							if (Main.tile[k, l].type == 2) {
								Main.tile[k, l].type = 23;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 1) {
								Main.tile[k, l].type = 25;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 53 || Main.tile[k, l].type == 123) {
								Main.tile[k, l].type = 112;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 109) {
								Main.tile[k, l].type = 23;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 117) {
								Main.tile[k, l].type = 25;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 116) {
								Main.tile[k, l].type = 112;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 161 || Main.tile[k, l].type == 164) {
								Main.tile[k, l].type = 163;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 396) {
								Main.tile[k, l].type = 400;
								SquareTileFrame(k, l);
							}
							else if (Main.tile[k, l].type == 397) {
								Main.tile[k, l].type = 398;
								SquareTileFrame(k, l);
							}
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > speedX + 1f)
					vector2.X = speedX + 1f;

				if (vector2.X < speedX - 1f)
					vector2.X = speedX - 1f;

				if (vector.X < (float)(-num) || vector.Y < (float)(-num) || vector.X > (float)(Main.maxTilesX + num) || vector.Y > (float)(Main.maxTilesX + num))
					flag = false;
			}
		}

		public static void TileRunner(int i, int j, double strength, int steps, int type, bool addTile = false, float speedX = 0f, float speedY = 0f, bool noYChange = false, bool overRide = true) {
			double num = strength;
			float num2 = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			if (speedX != 0f || speedY != 0f) {
				vector2.X = speedX;
				vector2.Y = speedY;
			}

			bool flag = type == 368;
			bool flag2 = type == 367;
			while (num > 0.0 && num2 > 0f) {
				if (vector.Y < 0f && num2 > 0f && type == 59)
					num2 = 0f;

				num = strength * (double)(num2 / (float)steps);
				num2 -= 1f;
				int num3 = (int)((double)vector.X - num * 0.5);
				int num4 = (int)((double)vector.X + num * 0.5);
				int num5 = (int)((double)vector.Y - num * 0.5);
				int num6 = (int)((double)vector.Y + num * 0.5);
				if (num3 < 1)
					num3 = 1;

				if (num4 > Main.maxTilesX - 1)
					num4 = Main.maxTilesX - 1;

				if (num5 < 1)
					num5 = 1;

				if (num6 > Main.maxTilesY - 1)
					num6 = Main.maxTilesY - 1;

				for (int k = num3; k < num4; k++) {
					for (int l = num5; l < num6; l++) {
						if (!((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
							continue;

						if (mudWall && (double)l > Main.worldSurface && Main.tile[k, l - 1].wall != 2 && l < Main.maxTilesY - 210 - genRand.Next(3)) {
							if (l > lavaLine - genRand.Next(0, 4) - 50) {
								if (Main.tile[k, l - 1].wall != 64 && Main.tile[k, l + 1].wall != 64 && Main.tile[k - 1, l].wall != 64 && Main.tile[k, l + 1].wall != 64)
									PlaceWall(k, l, 15, mute: true);
							}
							else if (Main.tile[k, l - 1].wall != 15 && Main.tile[k, l + 1].wall != 15 && Main.tile[k - 1, l].wall != 15 && Main.tile[k, l + 1].wall != 15) {
								PlaceWall(k, l, 64, mute: true);
							}
						}

						if (type < 0) {
							if (type == -2 && Main.tile[k, l].active() && (l < waterLine || l > lavaLine)) {
								Main.tile[k, l].liquid = byte.MaxValue;
								if (l > lavaLine)
									Main.tile[k, l].lava(lava: true);
							}

							Main.tile[k, l].active(active: false);
							continue;
						}

						if (flag && (double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
							PlaceWall(k, l, 180, mute: true);

						if (flag2 && (double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
							PlaceWall(k, l, 178, mute: true);

						if (overRide || !Main.tile[k, l].active()) {
							Tile tile = Main.tile[k, l];
							bool flag3 = false;
							flag3 = (Main.tileStone[type] && tile.type != 1);
							if (!TileID.Sets.CanBeClearedDuringGeneration[tile.type])
								flag3 = true;

							switch (tile.type) {
								case 53:
									if (type == 40)
										flag3 = true;
									if ((double)l < Main.worldSurface && type != 59)
										flag3 = true;
									break;
								case 45:
								case 147:
								case 189:
								case 190:
								case 196:
									flag3 = true;
									break;
								case 396:
								case 397:
									flag3 = !TileID.Sets.Ore[type];
									break;
								case 1:
									if (type == 59 && (double)l < Main.worldSurface + (double)genRand.Next(-50, 50))
										flag3 = true;
									break;
								case 367:
								case 368:
									if (type == 59)
										flag3 = true;
									break;
							}

							if (!flag3)
								tile.type = (ushort)type;
						}

						if (addTile) {
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].liquid = 0;
							Main.tile[k, l].lava(lava: false);
						}

						if (noYChange && (double)l < Main.worldSurface && type != 59)
							Main.tile[k, l].wall = 2;

						if (type == 59 && l > waterLine && Main.tile[k, l].liquid > 0) {
							Main.tile[k, l].lava(lava: false);
							Main.tile[k, l].liquid = 0;
						}
					}
				}

				vector += vector2;
				if (num > 50.0) {
					vector += vector2;
					num2 -= 1f;
					vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
					vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
					if (num > 100.0) {
						vector += vector2;
						num2 -= 1f;
						vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
						vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
						if (num > 150.0) {
							vector += vector2;
							num2 -= 1f;
							vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
							vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
							if (num > 200.0) {
								vector += vector2;
								num2 -= 1f;
								vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
								vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
								if (num > 250.0) {
									vector += vector2;
									num2 -= 1f;
									vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
									vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
									if (num > 300.0) {
										vector += vector2;
										num2 -= 1f;
										vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
										vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
										if (num > 400.0) {
											vector += vector2;
											num2 -= 1f;
											vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
											vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
											if (num > 500.0) {
												vector += vector2;
												num2 -= 1f;
												vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
												vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
												if (num > 600.0) {
													vector += vector2;
													num2 -= 1f;
													vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
													vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
													if (num > 700.0) {
														vector += vector2;
														num2 -= 1f;
														vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
														vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
														if (num > 800.0) {
															vector += vector2;
															num2 -= 1f;
															vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
															vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
															if (num > 900.0) {
																vector += vector2;
																num2 -= 1f;
																vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
																vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}

				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if (!noYChange) {
					vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
					if (vector2.Y > 1f)
						vector2.Y = 1f;

					if (vector2.Y < -1f)
						vector2.Y = -1f;
				}
				else if (type != 59 && num < 3.0) {
					if (vector2.Y > 1f)
						vector2.Y = 1f;

					if (vector2.Y < -1f)
						vector2.Y = -1f;
				}

				if (type == 59 && !noYChange) {
					if ((double)vector2.Y > 0.5)
						vector2.Y = 0.5f;

					if ((double)vector2.Y < -0.5)
						vector2.Y = -0.5f;

					if ((double)vector.Y < Main.rockLayer + 100.0)
						vector2.Y = 1f;

					if (vector.Y > (float)(Main.maxTilesY - 300))
						vector2.Y = -1f;
				}
			}
		}

		public static void STileRunner(int i, int j, double strength, int steps, int type, bool addTile = false, float speedX = 0f, float speedY = 0f, bool noYChange = false, bool overRide = true) {
			double num = strength;
			float num2 = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			if (speedX != 0f || speedY != 0f) {
				vector2.X = speedX;
				vector2.Y = speedY;
			}

			bool flag = type == 368;
			bool flag2 = type == 367;
			while (num > 0.0 && num2 > 0f) {
				if (vector.Y < 0f && num2 > 0f && type == 59)
					num2 = 0f;

				num = strength * (double)(num2 / (float)steps);
				num2 -= 1f;
				int num3 = (int)((double)vector.X - num * 0.5);
				int num4 = (int)((double)vector.X + num * 0.5);
				int num5 = (int)((double)vector.Y - num * 0.5);
				int num6 = (int)((double)vector.Y + num * 0.5);
				if (num3 < 1)
					num3 = 1;

				if (num4 > Main.maxTilesX - 1)
					num4 = Main.maxTilesX - 1;

				if (num5 < 1)
					num5 = 1;

				if (num6 > Main.maxTilesY - 1)
					num6 = Main.maxTilesY - 1;

				for (int k = num3; k < num4; k++) {
					for (int l = num5; l < num6; l++) {
						if (!((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
							continue;

						if (mudWall && (double)l > Main.worldSurface && Main.tile[k, l - 1].wall != 2 && l < Main.maxTilesY - 210 - genRand.Next(3)) {
							if (l > lavaLine - genRand.Next(0, 4) - 50) {
								if (Main.tile[k, l - 1].wall != 64 && Main.tile[k, l + 1].wall != 64 && Main.tile[k - 1, l].wall != 64 && Main.tile[k, l + 1].wall != 64)
									PlaceWall(k, l, 15, mute: true);
							}
							else if (Main.tile[k, l - 1].wall != 15 && Main.tile[k, l + 1].wall != 15 && Main.tile[k - 1, l].wall != 15 && Main.tile[k, l + 1].wall != 15) {
								PlaceWall(k, l, 64, mute: true);
							}
						}

						if (type < 0) {
							if (type == -2 && Main.tile[k, l].active() && (l < waterLine || l > lavaLine)) {
								Main.tile[k, l].liquid = byte.MaxValue;
								if (l > lavaLine)
									Main.tile[k, l].lava(lava: true);
							}

							Main.tile[k, l].active(active: false);
							continue;
						}

						if (flag && (double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
							PlaceWall(k, l, 180, mute: true);

						if (flag2 && (double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
							PlaceWall(k, l, 178, mute: true);

						if (overRide || !Main.tile[k, l].active()) {
							Tile tile = Main.tile[k, l];
							bool flag3 = false;
							flag3 = (Main.tileStone[type] && tile.type != 1);
							if (!(TileID.Sets.CanBeClearedDuringGeneration[tile.type] || tile.type == 147 || tile.type == 53) || tile.type == 460)
								flag3 = true;

							switch (tile.type) {
								//case 53:
									//if (type == 40)
									//	flag3 = true;
									//if ((double)l < Main.worldSurface && type != 59)
									//	flag3 = true;
									//break;
								case 45:
								//case 147:
								case 189:
								case 190:
								case 196:
									flag3 = true;
									break;
								case 396:
								case 397:
									flag3 = !TileID.Sets.Ore[type];
									break;
								case 1:
									if (type == 59 && (double)l < Main.worldSurface + (double)genRand.Next(-50, 50))
										flag3 = true;
									break;
								case 367:
								case 368:
									if (type == 59)
										flag3 = true;
									break;
							}

							if (!flag3)
								tile.type = (ushort)type;
						}

						if (addTile) {
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].liquid = 0;
							Main.tile[k, l].lava(lava: false);
						}

						if (noYChange && (double)l < Main.worldSurface && type != 59)
							Main.tile[k, l].wall = 2;

						if (type == 59 && l > waterLine && Main.tile[k, l].liquid > 0) {
							Main.tile[k, l].lava(lava: false);
							Main.tile[k, l].liquid = 0;
						}
					}
				}

				vector += vector2;
				if (num > 50.0) {
					vector += vector2;
					num2 -= 1f;
					vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
					vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
					if (num > 100.0) {
						vector += vector2;
						num2 -= 1f;
						vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
						vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
						if (num > 150.0) {
							vector += vector2;
							num2 -= 1f;
							vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
							vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
							if (num > 200.0) {
								vector += vector2;
								num2 -= 1f;
								vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
								vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
								if (num > 250.0) {
									vector += vector2;
									num2 -= 1f;
									vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
									vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
									if (num > 300.0) {
										vector += vector2;
										num2 -= 1f;
										vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
										vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
										if (num > 400.0) {
											vector += vector2;
											num2 -= 1f;
											vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
											vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
											if (num > 500.0) {
												vector += vector2;
												num2 -= 1f;
												vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
												vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
												if (num > 600.0) {
													vector += vector2;
													num2 -= 1f;
													vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
													vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
													if (num > 700.0) {
														vector += vector2;
														num2 -= 1f;
														vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
														vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
														if (num > 800.0) {
															vector += vector2;
															num2 -= 1f;
															vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
															vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
															if (num > 900.0) {
																vector += vector2;
																num2 -= 1f;
																vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
																vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}

				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if (!noYChange) {
					vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
					if (vector2.Y > 1f)
						vector2.Y = 1f;

					if (vector2.Y < -1f)
						vector2.Y = -1f;
				}
				else if (type != 59 && num < 3.0) {
					if (vector2.Y > 1f)
						vector2.Y = 1f;

					if (vector2.Y < -1f)
						vector2.Y = -1f;
				}

				if (type == 59 && !noYChange) {
					if ((double)vector2.Y > 0.5)
						vector2.Y = 0.5f;

					if ((double)vector2.Y < -0.5)
						vector2.Y = -0.5f;

					if ((double)vector.Y < Main.rockLayer + 100.0)
						vector2.Y = 1f;

					if (vector.Y > (float)(Main.maxTilesY - 300))
						vector2.Y = -1f;
				}
			}
		}

		public static void DirtyRockRunner(int i, int j) {
			double num = genRand.Next(2, 6);
			float num2 = genRand.Next(5, 50);
			float num3 = num2;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			while (num > 0.0 && num3 > 0f) {
				double num4 = num * (double)(num3 / num2);
				num3 -= 1f;
				int num5 = (int)((double)vector.X - num4 * 0.5);
				int num6 = (int)((double)vector.X + num4 * 0.5);
				int num7 = (int)((double)vector.Y - num4 * 0.5);
				int num8 = (int)((double)vector.Y + num4 * 0.5);
				if (num5 < 0)
					num5 = 0;

				if (num6 > Main.maxTilesX)
					num6 = Main.maxTilesX;

				if (num7 < 0)
					num7 = 0;

				if (num8 > Main.maxTilesY)
					num8 = Main.maxTilesY;

				for (int k = num5; k < num6; k++) {
					for (int l = num7; l < num8; l++) {
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].wall == 2)
							Main.tile[k, l].wall = 59;
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.Y > 1f)
					vector2.Y = 1f;

				if (vector2.Y < -1f)
					vector2.Y = -1f;
			}
		}

		public static void MudWallRunner(int i, int j) {
			double num = genRand.Next(8, 21);
			float num2 = genRand.Next(8, 33);
			float num3 = num2;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			while (num > 0.0 && num3 > 0f) {
				double num4 = num * (double)(num3 / num2);
				num3 -= 1f;
				int num5 = (int)((double)vector.X - num4 * 0.5);
				int num6 = (int)((double)vector.X + num4 * 0.5);
				int num7 = (int)((double)vector.Y - num4 * 0.5);
				int num8 = (int)((double)vector.Y + num4 * 0.5);
				if (num5 < 0)
					num5 = 0;

				if (num6 > Main.maxTilesX)
					num6 = Main.maxTilesX;

				if (num7 < 0)
					num7 = 0;

				if (num8 > Main.maxTilesY)
					num8 = Main.maxTilesY;

				for (int k = num5; k < num6; k++) {
					for (int l = num7; l < num8; l++) {
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && (double)l > Main.worldSurface)
							Main.tile[k, l].wall = 0;
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.Y > 1f)
					vector2.Y = 1f;

				if (vector2.Y < -1f)
					vector2.Y = -1f;
			}
		}

		public static void CloudIsland(int i, int j) {
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++) {
					if (genRand.Next(2) == 0)
						num12 += (float)genRand.Next(-1, 2);

					if (num12 < vector.Y)
						num12 = vector.Y;

					if (num12 > vector.Y + 2f)
						num12 = vector.Y + 2f;

					for (int l = num10; l < num11; l++) {
						if (!((float)l > num12))
							continue;

						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4) {
							if (k < num4)
								num4 = k;

							if (k > num5)
								num5 = k;

							if (l < num6)
								num6 = l;

							if (l > num7)
								num7 = l;

							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5))) {
				int num16 = num7;
				while (!Main.tile[num15, num16].active()) {
					num16--;
				}

				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
					num18 = 196;

				for (int m = num15 - num17; m <= num15 + num17; m++) {
					for (int n = num16 - num17; n <= num16 + num17; n++) {
						if (n > num6) {
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2))) {
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}

			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++) {
					if (genRand.Next(2) == 0)
						num21 += (float)genRand.Next(-1, 2);

					if (num21 < vector.Y)
						num21 = vector.Y;

					if (num21 > vector.Y + 2f)
						num21 = vector.Y + 2f;

					for (int num23 = num10; num23 < num11; num23++) {
						if ((float)num23 > num21) {
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189) {
								Main.tile[num22, num23].type = 0;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5) {
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 0) && num26 < num5) {
					num27--;
					if (num27 < num6) {
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}

				if (num26 >= num5)
					continue;

				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++) {
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++) {
						if (num31 > num6) {
							float num32 = Math.Abs(num30 - num26);
							float num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28) {
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}

				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}

			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++) {
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++) {
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++) {
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++) {
							if (!Main.tile[num36, num37].active())
								flag = false;
						}
					}

					if (flag) {
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}

			for (int num38 = num4; num38 <= num5; num38++) {
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++) {
				}

				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
					continue;

				if (genRand.Next(10) == 0) {
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++) {
						if (Main.tile[num41, num39].type == 189) {
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}

						if (Main.tile[num41, num39 + 1].type == 189) {
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}

						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189) {
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}

				if (genRand.Next(5) == 0)
					Main.tile[num38, num39].liquid = byte.MaxValue;

				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}

			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++) {
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
					num47 = 196;

				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++) {
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++) {
						float num50 = Math.Abs(num48 - num44);
						float num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2))) {
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}

				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++) {
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++) {
					}

					Main.tile[num52, num53].active(active: false);
					Main.tile[num52, num53].liquid = byte.MaxValue;
					SquareTileFrame(num52, num53);
				}
			}
		}

		public static void SnowIsland(int i, int j) {
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++) {
					if (genRand.Next(2) == 0)
						num12 += (float)genRand.Next(-1, 2);

					if (num12 < vector.Y)
						num12 = vector.Y;

					if (num12 > vector.Y + 2f)
						num12 = vector.Y + 2f;

					for (int l = num10; l < num11; l++) {
						if (!((float)l > num12))
							continue;

						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4) {
							if (k < num4)
								num4 = k;

							if (k > num5)
								num5 = k;

							if (l < num6)
								num6 = l;

							if (l > num7)
								num7 = l;

							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5))) {
				int num16 = num7;
				while (!Main.tile[num15, num16].active()) {
					num16--;
				}

				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
					num18 = 460;

				for (int m = num15 - num17; m <= num15 + num17; m++) {
					for (int n = num16 - num17; n <= num16 + num17; n++) {
						if (n > num6) {
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2))) {
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}

			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++) {
					if (genRand.Next(2) == 0)
						num21 += (float)genRand.Next(-1, 2);

					if (num21 < vector.Y)
						num21 = vector.Y;

					if (num21 > vector.Y + 2f)
						num21 = vector.Y + 2f;

					for (int num23 = num10; num23 < num11; num23++) {
						if ((float)num23 > num21) {
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189) {
								Main.tile[num22, num23].type = 147;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5) {
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 147) && num26 < num5) {
					num27--;
					if (num27 < num6) {
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}

				if (num26 >= num5)
					continue;

				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++) {
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++) {
						if (num31 > num6) {
							float num32 = Math.Abs(num30 - num26);
							float num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28) {
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}

				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}

			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++) {
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++) {
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++) {
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++) {
							if (!Main.tile[num36, num37].active())
								flag = false;
						}
					}

					if (flag) {
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}

			for (int num38 = num4; num38 <= num5; num38++) {
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++) {
				}

				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
					continue;

				if (genRand.Next(10) == 0) {
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++) {
						if (Main.tile[num41, num39].type == 189) {
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}

						if (Main.tile[num41, num39 + 1].type == 189) {
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}

						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189) {
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}

				if (genRand.Next(5) == 0)
					Main.tile[num38, num39].liquid = byte.MaxValue;

				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}

			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++) {
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
					num47 = 460;

				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++) {
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++) {
						float num50 = Math.Abs(num48 - num44);
						float num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2))) {
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}

				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++) {
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++) {
					}

					Main.tile[num52, num53].active(active: false);
					Main.tile[num52, num53].liquid = byte.MaxValue;
					SquareTileFrame(num52, num53);
				}
			}
		}

		public static void SandIsland(int i, int j) {
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++) {
					if (genRand.Next(2) == 0)
						num12 += (float)genRand.Next(-1, 2);

					if (num12 < vector.Y)
						num12 = vector.Y;

					if (num12 > vector.Y + 2f)
						num12 = vector.Y + 2f;

					for (int l = num10; l < num11; l++) {
						if (!((float)l > num12))
							continue;

						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4) {
							if (k < num4)
								num4 = k;

							if (k > num5)
								num5 = k;

							if (l < num6)
								num6 = l;

							if (l > num7)
								num7 = l;

							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5))) {
				int num16 = num7;
				while (!Main.tile[num15, num16].active()) {
					num16--;
				}

				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				//if (genRand.Next(4) == 0)
				//	num18 = 460;

				for (int m = num15 - num17; m <= num15 + num17; m++) {
					for (int n = num16 - num17; n <= num16 + num17; n++) {
						if (n > num6) {
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2))) {
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}

			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++) {
					if (genRand.Next(2) == 0)
						num21 += (float)genRand.Next(-1, 2);

					if (num21 < vector.Y)
						num21 = vector.Y;

					if (num21 > vector.Y + 2f)
						num21 = vector.Y + 2f;

					for (int num23 = num10; num23 < num11; num23++) {
						if ((float)num23 > num21) {
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189) {
								Main.tile[num22, num23].type = 53;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5) {
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 53) && num26 < num5) {
					num27--;
					if (num27 < num6) {
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}

				if (num26 >= num5)
					continue;

				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++) {
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++) {
						if (num31 > num6) {
							float num32 = Math.Abs(num30 - num26);
							float num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28) {
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}

				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}

			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++) {
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++) {
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++) {
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++) {
							if (!Main.tile[num36, num37].active())
								flag = false;
						}
					}

					if (flag) {
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}

			for (int num38 = num4; num38 <= num5; num38++) {
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++) {
				}

				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
					continue;

				if (genRand.Next(10) == 0) {
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++) {
						if (Main.tile[num41, num39].type == 189) {
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = 0;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}

						if (Main.tile[num41, num39 + 1].type == 189) {
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = 0;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}

						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189) {
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = 0;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}

				if (genRand.Next(5) == 0)
					Main.tile[num38, num39].liquid = 0;

				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}

			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++) {
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				//if (genRand.Next(2) == 0)
				//	num47 = 460;

				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++) {
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++) {
						float num50 = Math.Abs(num48 - num44);
						float num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2))) {
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}

				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++) {
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++) {
					}

					Main.tile[num52, num53].active(active: false);
					Main.tile[num52, num53].liquid = 0;
					SquareTileFrame(num52, num53);
				}
			}
		}

		public static void SpecialIsland(int i, int j, int Ground = 0, int Rain = 196, int Fluid = 1, int Cloud = 189, bool GrassRunner = false, int GrassType = 0, int CloudPaint = 0) {
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++) {
					if (genRand.Next(2) == 0)
						num12 += (float)genRand.Next(-1, 2);

					if (num12 < vector.Y)
						num12 = vector.Y;

					if (num12 > vector.Y + 2f)
						num12 = vector.Y + 2f;

					for (int l = num10; l < num11; l++) {
						if (!((float)l > num12))
							continue;

						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4) {
							if (k < num4)
								num4 = k;

							if (k > num5)
								num5 = k;

							if (l < num6)
								num6 = l;

							if (l > num7)
								num7 = l;

							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = (ushort)Cloud;
							if (CloudPaint > 0) {
								WorldGen.paintTile(k, l, (byte)CloudPaint);
							}
							SquareTileFrame(k, l);
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5))) {
				int num16 = num7;
				while (!Main.tile[num15, num16].active()) {
					num16--;
				}

				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = Cloud;
				if (genRand.Next(4) == 0)
					num18 = Rain;

				for (int m = num15 - num17; m <= num15 + num17; m++) {
					for (int n = num16 - num17; n <= num16 + num17; n++) {
						if (n > num6) {
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2))) {
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								if (CloudPaint > 0 && num18 == Cloud) {
									WorldGen.paintTile(m, n, (byte)CloudPaint);
								}
								else {
									WorldGen.paintTile(m, n, 0);
								}
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}

			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++) {
					if (genRand.Next(2) == 0)
						num21 += (float)genRand.Next(-1, 2);

					if (num21 < vector.Y)
						num21 = vector.Y;

					if (num21 > vector.Y + 2f)
						num21 = vector.Y + 2f;

					for (int num23 = num10; num23 < num11; num23++) {
						if ((float)num23 > num21) {
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == Cloud) {
								Main.tile[num22, num23].type = (ushort)Ground;
								WorldGen.paintTile(num22, num23, 0);
								SquareTileFrame(num22, num23);
							}
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5) {
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != Ground) && num26 < num5) {
					num27--;
					if (num27 < num6) {
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}

				if (num26 >= num5)
					continue;

				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = Cloud;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++) {
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++) {
						if (num31 > num6) {
							float num32 = Math.Abs(num30 - num26);
							float num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28) {
								Main.tile[num30, num31].type = (ushort)num29;
								if (CloudPaint > 0) {
									WorldGen.paintTile(num30, num31, (byte)CloudPaint);
								}
								SquareTileFrame(num30, num31);
							}
						}
					}
				}

				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}

			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++) {
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++) {
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++) {
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++) {
							if (!Main.tile[num36, num37].active())
								flag = false;
						}
					}

					if (flag) {
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}

			for (int num38 = num4; num38 <= num5; num38++) {
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++) {
				}

				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != Cloud)
					continue;

				if (genRand.Next(10) == 0) {
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++) {
						if (Main.tile[num41, num39].type == Cloud) {
							Main.tile[num41, num39].active(active: false);
							if (Fluid == 1) {
								Main.tile[num41, num39].liquid = byte.MaxValue;
								Main.tile[num41, num39].lava(lava: false);
							}
							else if (Fluid == 2) {
								Main.tile[num41, num39].liquid = byte.MaxValue;
								Main.tile[num41, num39].lava(lava: true);
							}
							else if (Fluid == 2) {
								Main.tile[num41, num39].liquid = byte.MaxValue;
								Main.tile[num41, num39].honey(honey: true);
							}
							else {
								Main.tile[num41, num39].liquid = 0;
								Main.tile[num41, num39].lava(lava: false);
							}
							SquareTileFrame(num38, num39);
						}

						if (Main.tile[num41, num39 + 1].type == Cloud) {
							Main.tile[num41, num39 + 1].active(active: false);
							if (Fluid == 1) {
								Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
								Main.tile[num41, num39 + 1].lava(lava: false);
							}
							else if (Fluid == 2) {
								Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
								Main.tile[num41, num39 + 1].lava(lava: true);
							}
							else if (Fluid == 2) {
								Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
								Main.tile[num41, num39 + 1].honey(honey: true);
							}
							else {
								Main.tile[num41, num39 + 1].liquid = 0;
								Main.tile[num41, num39 + 1].lava(lava: false);
							}
							SquareTileFrame(num38, num39 + 1);
						}

						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == Cloud) {
							Main.tile[num41, num39 + 2].active(active: false);
							if (Fluid == 1) {
								Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
								Main.tile[num41, num39 + 2].lava(lava: false);
							}
							else if (Fluid == 2) {
								Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
								Main.tile[num41, num39 + 2].lava(lava: true);
							}
							else if (Fluid == 2) {
								Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
								Main.tile[num41, num39 + 2].honey(honey: true);
							}
							else {
								Main.tile[num41, num39 + 2].liquid = 0;
								Main.tile[num41, num39 + 2].lava(lava: false);
							}
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}

				if (genRand.Next(5) == 0) {
					if (Fluid == 1) {
						Main.tile[num38, num39].liquid = byte.MaxValue;
						Main.tile[num38, num39].lava(lava: false);
					}
					else if (Fluid == 2) {
						Main.tile[num38, num39].liquid = byte.MaxValue;
						Main.tile[num38, num39].lava(lava: true);
					}
					else if (Fluid == 2) {
						Main.tile[num38, num39].liquid = byte.MaxValue;
						Main.tile[num38, num39].honey(honey: true);
					}
					else {
						Main.tile[num38, num39].liquid = 0;
						Main.tile[num38, num39].lava(lava: false);
					}
				}
				SquareTileFrame(num38, num39);
			}

			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++) {
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = Cloud;
				if (genRand.Next(2) == 0)
					num47 = Rain;

				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++) {
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++) {
						float num50 = Math.Abs(num48 - num44);
						float num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2))) {
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							if (CloudPaint > 0 && num47 == Cloud) {
								WorldGen.paintTile(num48, num49, (byte)CloudPaint);
							}
							else {
								WorldGen.paintTile(num48, num49, 0);
							}
							SquareTileFrame(num48, num49);
						}
					}
				}

				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++) {
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++) {
					}

					Main.tile[num52, num53].active(active: false);
					if (Fluid == 1) {
						Main.tile[num52, num53].liquid = byte.MaxValue;
						Main.tile[num52, num53].lava(lava: false);
					}
					else if (Fluid == 2) {
						Main.tile[num52, num53].liquid = byte.MaxValue;
						Main.tile[num52, num53].lava(lava: true);
					}
					else if (Fluid == 2) {
						Main.tile[num52, num53].liquid = byte.MaxValue;
						Main.tile[num52, num53].honey(honey: true);
					}
					else {
						Main.tile[num52, num53].liquid = 0;
						Main.tile[num52, num53].lava(lava: false);
					}
					SquareTileFrame(num52, num53);
				}
			}
			if (GrassRunner == true) {
				for (int num601 = (int)(i - num); num601 < (int)(i + num); num601++) {
					for (int num602 = (int)(j - num); num602 < (int)(j + num); num602++) {
						if (Main.tile[num601, num602].active()) {
							grassSpread = 0;
							SpreadGrass(num601, num602, Ground, GrassType, repeat: true, 0);
							int GrassID = GrassType;
							//if (Main.setting.SwapShroomJungle) {
							//	GrassID = 70;
							//}
							WorldGen.SpreadGrass(num601, num602, Ground, GrassID, repeat: true, 0);
						}

						//progress.Set(0.2f * ((float)(num601 * Main.maxTilesY + num602) / (float)(Main.maxTilesX * Main.maxTilesY)));
					}
				}

				//for (int num603 = i - num; num603 < i + num; num603++) {
				//	for (int num604 = j - num; num604 < j + num; num604++) {
				//		if (Main.tile[num603, num604].active() && tileCounter(num603, num604) < tileCounterMax)
				//			tileCounterKill();

						//float num605 = (float)((num603 - 10) * (Main.maxTilesY - 20) + (num604 - 10)) / (float)((Main.maxTilesX - 20) * (Main.maxTilesY - 20));
						//progress.Set(0.2f + num605 * 0.8f);
					//}
				//}
			}
		}


		public static void CloudLake(int i, int j) {
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++) {
					if (genRand.Next(2) == 0)
						num12 += (float)genRand.Next(-1, 2);

					if (num12 < vector.Y)
						num12 = vector.Y;

					if (num12 > vector.Y + 2f)
						num12 = vector.Y + 2f;

					for (int l = num10; l < num11; l++) {
						if (!((float)l > num12))
							continue;

						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4) {
							if (k < num4)
								num4 = k;

							if (k > num5)
								num5 = k;

							if (l < num6)
								num6 = l;

							if (l > num7)
								num7 = l;

							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5))) {
				int num16 = num7;
				while (!Main.tile[num15, num16].active()) {
					num16--;
				}

				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
					num18 = 196;

				for (int m = num15 - num17; m <= num15 + num17; m++) {
					for (int n = num16 - num17; n <= num16 + num17; n++) {
						if (n > num6) {
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2))) {
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}

			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
					num8 = 0;

				if (num9 > Main.maxTilesX)
					num9 = Main.maxTilesX;

				if (num10 < 0)
					num10 = 0;

				if (num11 > Main.maxTilesY)
					num11 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++) {
					if (genRand.Next(2) == 0)
						num21 += (float)genRand.Next(-1, 2);

					if (num21 < vector.Y)
						num21 = vector.Y;

					if (num21 > vector.Y + 2f)
						num21 = vector.Y + 2f;

					for (int num23 = num10; num23 < num11; num23++) {
						if ((float)num23 > num21) {
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189) {
								Main.tile[num22, num23].active(active: false);
								Main.tile[num22, num23].liquid = byte.MaxValue;
								Main.tile[num22, num23].honey(honey: false);
								Main.tile[num22, num23].lava(lava: false);
							}
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}

			for (int num26 = num4 - 20; num26 <= num5 + 20; num26++) {
				for (int num27 = num6 - 20; num27 <= num7 + 20; num27++) {
					bool flag = true;
					for (int num28 = num26 - 1; num28 <= num26 + 1; num28++) {
						for (int num29 = num27 - 1; num29 <= num27 + 1; num29++) {
							if (!Main.tile[num28, num29].active())
								flag = false;
						}
					}

					if (flag)
						Main.tile[num26, num27].wall = 73;
				}
			}

			for (int num30 = num4; num30 <= num5; num30++) {
				int num31;
				for (num31 = num6 - 10; !Main.tile[num30, num31 + 1].active(); num31++) {
				}

				if (num31 >= num7 || Main.tile[num30, num31 + 1].type != 189)
					continue;

				if (genRand.Next(10) == 0) {
					int num32 = genRand.Next(1, 3);
					for (int num33 = num30 - num32; num33 <= num30 + num32; num33++) {
						if (Main.tile[num33, num31].type == 189) {
							Main.tile[num33, num31].active(active: false);
							Main.tile[num33, num31].liquid = byte.MaxValue;
							Main.tile[num33, num31].lava(lava: false);
							SquareTileFrame(num30, num31);
						}

						if (Main.tile[num33, num31 + 1].type == 189) {
							Main.tile[num33, num31 + 1].active(active: false);
							Main.tile[num33, num31 + 1].liquid = byte.MaxValue;
							Main.tile[num33, num31 + 1].lava(lava: false);
							SquareTileFrame(num30, num31 + 1);
						}

						if (num33 > num30 - num32 && num33 < num30 + 2 && Main.tile[num33, num31 + 2].type == 189) {
							Main.tile[num33, num31 + 2].active(active: false);
							Main.tile[num33, num31 + 2].liquid = byte.MaxValue;
							Main.tile[num33, num31 + 2].lava(lava: false);
							SquareTileFrame(num30, num31 + 2);
						}
					}
				}

				if (genRand.Next(5) == 0)
					Main.tile[num30, num31].liquid = byte.MaxValue;

				Main.tile[num30, num31].lava(lava: false);
				SquareTileFrame(num30, num31);
			}

			int num34 = genRand.Next(1, 4);
			for (int num35 = 0; num35 <= num34; num35++) {
				int num36 = genRand.Next(num4 - 5, num5 + 5);
				int num37 = num6 - genRand.Next(20, 40);
				int num38 = genRand.Next(4, 8);
				int num39 = 189;
				if (genRand.Next(4) != 0)
					num39 = 196;

				for (int num40 = num36 - num38; num40 <= num36 + num38; num40++) {
					for (int num41 = num37 - num38; num41 <= num37 + num38; num41++) {
						float num42 = Math.Abs(num40 - num36);
						float num43 = Math.Abs(num41 - num37) * 2;
						if (Math.Sqrt(num42 * num42 + num43 * num43) < (double)(num38 + genRand.Next(-1, 2))) {
							Main.tile[num40, num41].active(active: true);
							Main.tile[num40, num41].type = (ushort)num39;
							SquareTileFrame(num40, num41);
						}
					}
				}

				for (int num44 = num36 - num38 + 2; num44 <= num36 + num38 - 2; num44++) {
					int num45;
					for (num45 = num37 - num38; !Main.tile[num44, num45].active(); num45++) {
					}

					Main.tile[num44, num45].active(active: false);
					Main.tile[num44, num45].liquid = byte.MaxValue;
					SquareTileFrame(num44, num45);
				}
			}
		}

		public static void FloatingIsland(int i, int j) {
			double num = genRand.Next(80, 120);
			double num2 = num;
			float num3 = genRand.Next(20, 25);
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f) {
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}

			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num * 0.5);
				int num5 = (int)((double)vector.X + num * 0.5);
				int num6 = (int)((double)vector.Y - num * 0.5);
				int num7 = (int)((double)vector.Y + num * 0.5);
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num8 = vector.Y + 1f;
				for (int k = num4; k < num5; k++) {
					if (genRand.Next(2) == 0)
						num8 += (float)genRand.Next(-1, 2);

					if (num8 < vector.Y)
						num8 = vector.Y;

					if (num8 > vector.Y + 2f)
						num8 = vector.Y + 2f;

					for (int l = num6; l < num7; l++) {
						if (!((float)l > num8))
							continue;

						float num9 = Math.Abs((float)k - vector.X);
						float num10 = Math.Abs((float)l - vector.Y) * 2f;
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4) {
							Main.tile[k, l].active(active: true);
							if (Main.tile[k, l].type == 59)
								Main.tile[k, l].type = 0;
						}
					}
				}

				num4 = (int)((double)vector.X - num * 0.4);
				num5 = (int)((double)vector.X + num * 0.4);
				num6 = (int)((double)vector.Y - num * 0.4);
				num7 = (int)((double)vector.Y + num * 0.4);
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int m = num4; m < num5; m++) {
					for (int n = num6; n < num7; n++) {
						if ((float)n > vector.Y + 2f) {
							float num11 = Math.Abs((float)m - vector.X);
							float num12 = Math.Abs((float)n - vector.Y) * 2f;
							if (Math.Sqrt(num11 * num11 + num12 * num12) < num2 * 0.4)
								Main.tile[m, n].wall = 2;
						}
					}
				}

				vector += vector2;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
					vector2.X = 1f;

				if (vector2.X < -1f)
					vector2.X = -1f;

				if ((double)vector2.Y > 0.2)
					vector2.Y = -0.2f;

				if ((double)vector2.Y < -0.2)
					vector2.Y = -0.2f;
			}
		}

		public static void Caverer(int X, int Y) {
			switch (genRand.Next(2)) {
				case 0: {
						int num4 = genRand.Next(7, 9);
						float num5 = (float)genRand.Next(100) * 0.01f;
						float num6 = 1f - num5;
						if (genRand.Next(2) == 0)
							num5 = 0f - num5;

						if (genRand.Next(2) == 0)
							num6 = 0f - num6;

						Vector2 vector2 = new Vector2(X, Y);
						for (int j = 0; j < num4; j++) {
							vector2 = digTunnel(vector2.X, vector2.Y, num5, num6, genRand.Next(6, 20), genRand.Next(4, 9));
							num5 += (float)genRand.Next(-20, 21) * 0.1f;
							num6 += (float)genRand.Next(-20, 21) * 0.1f;
							if ((double)num5 < -1.5)
								num5 = -1.5f;

							if ((double)num5 > 1.5)
								num5 = 1.5f;

							if ((double)num6 < -1.5)
								num6 = -1.5f;

							if ((double)num6 > 1.5)
								num6 = 1.5f;

							float num7 = (float)genRand.Next(100) * 0.01f;
							float num8 = 1f - num7;
							if (genRand.Next(2) == 0)
								num7 = 0f - num7;

							if (genRand.Next(2) == 0)
								num8 = 0f - num8;

							Vector2 vector3 = digTunnel(vector2.X, vector2.Y, num7, num8, genRand.Next(30, 50), genRand.Next(3, 6));
							TileRunner((int)vector3.X, (int)vector3.Y, genRand.Next(10, 20), genRand.Next(5, 10), -1);
						}

						break;
					}
				case 1: {
						int num = genRand.Next(15, 30);
						float num2 = (float)genRand.Next(100) * 0.01f;
						float num3 = 1f - num2;
						if (genRand.Next(2) == 0)
							num2 = 0f - num2;

						if (genRand.Next(2) == 0)
							num3 = 0f - num3;

						Vector2 vector = new Vector2(X, Y);
						for (int i = 0; i < num; i++) {
							vector = digTunnel(vector.X, vector.Y, num2, num3, genRand.Next(5, 15), genRand.Next(2, 6), Wet: true);
							num2 += (float)genRand.Next(-20, 21) * 0.1f;
							num3 += (float)genRand.Next(-20, 21) * 0.1f;
							if ((double)num2 < -1.5)
								num2 = -1.5f;

							if ((double)num2 > 1.5)
								num2 = 1.5f;

							if ((double)num3 < -1.5)
								num3 = -1.5f;

							if ((double)num3 > 1.5)
								num3 = 1.5f;
						}

						break;
					}
			}
		}

		public static Vector2 digTunnel(float X, float Y, float xDir, float yDir, int Steps, int Size, bool Wet = false) {
			float num = X;
			float num2 = Y;
			try {
				float num3 = 0f;
				float num4 = 0f;
				float num5 = Size;
				num = MathHelper.Clamp(num, num5 + 1f, (float)Main.maxTilesX - num5 - 1f);
				num2 = MathHelper.Clamp(num2, num5 + 1f, (float)Main.maxTilesY - num5 - 1f);
				for (int i = 0; i < Steps; i++) {
					for (int j = (int)(num - num5); (float)j <= num + num5; j++) {
						for (int k = (int)(num2 - num5); (float)k <= num2 + num5; k++) {
							if ((double)(Math.Abs((float)j - num) + Math.Abs((float)k - num2)) < (double)num5 * (1.0 + (double)genRand.Next(-10, 11) * 0.005) && j >= 0 && j < Main.maxTilesX && k >= 0 && k < Main.maxTilesY) {
								Main.tile[j, k].active(active: false);
								if (Wet)
									Main.tile[j, k].liquid = byte.MaxValue;
							}
						}
					}

					num5 += (float)genRand.Next(-50, 51) * 0.03f;
					if ((double)num5 < (double)Size * 0.6)
						num5 = (float)Size * 0.6f;

					if (num5 > (float)(Size * 2))
						num5 = (float)Size * 2f;

					num3 += (float)genRand.Next(-20, 21) * 0.01f;
					num4 += (float)genRand.Next(-20, 21) * 0.01f;
					if (num3 < -1f)
						num3 = -1f;

					if (num3 > 1f)
						num3 = 1f;

					if (num4 < -1f)
						num4 = -1f;

					if (num4 > 1f)
						num4 = 1f;

					num += (xDir + num3) * 0.6f;
					num2 += (yDir + num4) * 0.6f;
				}
			}
			catch {
			}

			return new Vector2(num, num2);
		}

		public static void IslandHouse(int i, int j, int t) {
			byte type = 202;
			byte wall = 82;
			if (t == 1) {
				type = 75;
				wall = 14;
			}
			Vector2 vector = new Vector2(i, j);
			int num = 1;
			if (genRand.Next(2) == 0)
				num = -1;

			int num2 = genRand.Next(7, 12);
			int num3 = genRand.Next(5, 7);
			vector.X = i + (num2 + 2) * num;
			for (int k = j - 15; k < j + 30; k++) {
				if (Main.tile[(int)vector.X, k].active()) {
					vector.Y = k - 1;
					break;
				}
			}

			vector.X = i;
			int num4 = (int)(vector.X - (float)num2 - 1f);
			int num5 = (int)(vector.X + (float)num2 + 1f);
			int num6 = (int)(vector.Y - (float)num3 - 1f);
			int num7 = (int)(vector.Y + 2f);
			if (num4 < 0)
				num4 = 0;

			if (num5 > Main.maxTilesX)
				num5 = Main.maxTilesX;

			if (num6 < 0)
				num6 = 0;

			if (num7 > Main.maxTilesY)
				num7 = Main.maxTilesY;

			for (int l = num4; l <= num5; l++) {
				for (int m = num6 - 1; m < num7 + 1; m++) {
					if (m != num6 - 1 || (l != num4 && l != num5)) {
						Main.tile[l, m].active(active: true);
						Main.tile[l, m].liquid = 0;
						Main.tile[l, m].type = type;
						Main.tile[l, m].wall = 0;
						Main.tile[l, m].halfBrick(halfBrick: false);
						Main.tile[l, m].slope(0);
					}
				}
			}

			num4 = (int)(vector.X - (float)num2);
			num5 = (int)(vector.X + (float)num2);
			num6 = (int)(vector.Y - (float)num3);
			num7 = (int)(vector.Y + 1f);
			if (num4 < 0)
				num4 = 0;

			if (num5 > Main.maxTilesX)
				num5 = Main.maxTilesX;

			if (num6 < 0)
				num6 = 0;

			if (num7 > Main.maxTilesY)
				num7 = Main.maxTilesY;

			for (int n = num4; n <= num5; n++) {
				for (int num8 = num6; num8 < num7; num8++) {
					if ((num8 != num6 || (n != num4 && n != num5)) && Main.tile[n, num8].wall == 0) {
						Main.tile[n, num8].active(active: false);
						Main.tile[n, num8].wall = wall;
					}
				}
			}

			int num9 = i + (num2 + 1) * num;
			int num10 = (int)vector.Y;
			for (int num11 = num9 - 2; num11 <= num9 + 2; num11++) {
				Main.tile[num11, num10].active(active: false);
				Main.tile[num11, num10 - 1].active(active: false);
				Main.tile[num11, num10 - 2].active(active: false);
			}

			PlaceTile(num9, num10, 10, mute: true, forced: false, -1, 9);
			num9 = i + (num2 + 1) * -num - num;
			for (int num12 = num6; num12 <= num7 + 1; num12++) {
				Main.tile[num9, num12].active(active: true);
				Main.tile[num9, num12].liquid = 0;
				Main.tile[num9, num12].type = type;
				Main.tile[num9, num12].wall = 0;
				Main.tile[num9, num12].halfBrick(halfBrick: false);
				Main.tile[num9, num12].slope(0);
			}

			int contain = 0;
			int num13 = houseCount;
			if (num13 > 2)
				num13 = genRand.Next(3);

			switch (num13) {
				case 0:
					contain = 159;
					break;
				case 1:
					contain = 65;
					break;
				case 2:
					contain = 158;
					break;
			}
			if (t == 0) {
				AddBuriedChest(i, num10 - 3, contain, notNearOtherChests: false, 13);
			}
			else if (t == 1) {
				WorldGen.AddBuriedChest(i, num10 - 3, 0, false, 99);
			}
			houseCount++;
			int num14 = i - num2 / 2 + 1;
			int num15 = i + num2 / 2 - 1;
			int num16 = 1;
			if (num2 > 10)
				num16 = 2;

			int num17 = (num6 + num7) / 2 - 1;
			for (int num18 = num14 - num16; num18 <= num14 + num16; num18++) {
				for (int num19 = num17 - 1; num19 <= num17 + 1; num19++) {
					Main.tile[num18, num19].wall = 21;
				}
			}

			for (int num20 = num15 - num16; num20 <= num15 + num16; num20++) {
				for (int num21 = num17 - 1; num21 <= num17 + 1; num21++) {
					Main.tile[num20, num21].wall = 21;
				}
			}

			int num22 = i + (num2 / 2 + 1) * -num;
			if (t == 0) {
				PlaceTile(num22, num7 - 1, 14, mute: true, forced: false, -1, 7);
				PlaceTile(num22 - 2, num7 - 1, 15, mute: true, forced: false, 0, 10);
			}
			else if (t == 1) {
				PlaceTile(num22, num7 - 1, 14, mute: true, forced: false, -1, 13);
				PlaceTile(num22 - 2, num7 - 1, 15, mute: true, forced: false, 0, 16);
			}
			Main.tile[num22 - 2, num7 - 1].frameX += 18;
			Main.tile[num22 - 2, num7 - 2].frameX += 18;
			if (t == 0) {
				PlaceTile(num22 + 2, num7 - 1, 15, mute: true, forced: false, 0, 10);
			}
			else if (t == 1) {
				PlaceTile(num22 + 2, num7 - 1, 15, mute: true, forced: false, 0, 16);
			}
			int i2 = num4 + 1;
			int j2 = num6;
			int V1 = 7;
			int V2 = 10;
			if (t == 0) {
				V1 = 17;
				V2 = 21;
			}
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(V1, V2));
			i2 = num5 - 1;
			j2 = num6;
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(V1, V2));
			if (num > 0) {
				i2 = num4;
				j2 = num6 + 1;
			}
			else {
				i2 = num5;
				j2 = num6 + 1;
			}

			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(V1, V2));
		}

		public static void Mountinater(int i, int j) {
			double num = genRand.Next(80, 120);
			double num2 = num;
			float num3 = genRand.Next(40, 55);
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j + num3 / 2f;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-20, -10) * 0.1f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num * 0.5);
				int num5 = (int)((double)vector.X + num * 0.5);
				int num6 = (int)((double)vector.Y - num * 0.5);
				int num7 = (int)((double)vector.Y + num * 0.5);
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num4; k < num5; k++) {
					for (int l = num6; l < num7; l++) {
						float num8 = Math.Abs((float)k - vector.X);
						float num9 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4 && !Main.tile[k, l].active()) {
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 0;
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if ((double)vector2.X > 0.5)
					vector2.X = 0.5f;

				if ((double)vector2.X < -0.5)
					vector2.X = -0.5f;

				if ((double)vector2.Y > -0.5)
					vector2.Y = -0.5f;

				if ((double)vector2.Y < -1.5)
					vector2.Y = -1.5f;
			}
		}

		public static void MakeWateryIceThing(int i, int j) {
			if (Main.tile[i, j].liquid <= 0 || Main.tile[i, j].active() || Main.tile[i, j].lava())
				return;

			int num = j;
			while (!Main.tile[i, num].active() && Main.tile[i, num].liquid > 0) {
				num++;
				if (num > Main.maxTilesY - 50)
					return;
			}

			if (Main.tile[i, num].type != 147 && Main.tile[i, num].type != 161)
				return;

			num--;
			while (Main.tile[i, num].liquid > 0) {
				num--;
				if (num < 10)
					return;
			}

			if (Main.tile[i, num].active())
				return;

			num++;
			if (!Main.tile[i, num].active()) {
				int num2 = i;
				while (!Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 - 1, num].halfBrick()) {
					PlaceTile(num2, num, 162, mute: true);
					num2--;
				}

				for (num2 = i + 1; !Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 + 1, num].halfBrick(); num2++) {
					PlaceTile(num2, num, 162, mute: true);
				}
			}
		}

		public static void Lakinater(int i, int j) {
			double num = genRand.Next(25, 50) * Main.setting.LakeScale;
			double num2 = num;
			float num3 = genRand.Next(30, 80) * Main.setting.LakeScale;
			if (genRand.Next(5) == 0) {
				num *= 1.5;
				num2 *= 1.5;
				num3 *= 1.2f;
			}

			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j - num3 * 0.3f;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-20, -10) * 0.1f;
			while (num > 0.0 && num3 > 0f) {
				if ((double)vector.Y + num2 * 0.5 > Main.worldSurface)
					num3 = 0f;

				num -= (double)genRand.Next(3);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num * 0.5);
				int num5 = (int)((double)vector.X + num * 0.5);
				int num6 = (int)((double)vector.Y - num * 0.5);
				int num7 = (int)((double)vector.Y + num * 0.5);
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num4; k < num5; k++) {
					for (int l = num6; l < num7; l++) {
						float num8 = Math.Abs((float)k - vector.X);
						float num9 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4) {
							if (Main.tile[k, l].active())
								Main.tile[k, l].liquid = byte.MaxValue;

							Main.tile[k, l].active(active: false);
						}
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if ((double)vector2.X > 0.5)
					vector2.X = 0.5f;

				if ((double)vector2.X < -0.5)
					vector2.X = -0.5f;

				if ((double)vector2.Y > 1.5)
					vector2.Y = 1.5f;

				if ((double)vector2.Y < 0.5)
					vector2.Y = 0.5f;
			}
		}

		public static void ShroomPatch(int i, int j) {
			double num = genRand.Next(40, 70);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			if (genRand.Next(5) == 0) {
				num *= 1.5;
				num2 *= 1.5;
				num3 *= 1.2f;
			}

			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j - num3 * 0.3f;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-20, -10) * 0.1f;
			while (num > 0.0 && num3 > 0f) {
				num -= (double)genRand.Next(3);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num * 0.5);
				int num5 = (int)((double)vector.X + num * 0.5);
				int num6 = (int)((double)vector.Y - num * 0.5);
				int num7 = (int)((double)vector.Y + num * 0.5);
				if (num4 < 0)
					num4 = 0;

				if (num5 > Main.maxTilesX)
					num5 = Main.maxTilesX;

				if (num6 < 0)
					num6 = 0;

				if (num7 > Main.maxTilesY)
					num7 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num4; k < num5; k++) {
					for (int l = num6; l < num7; l++) {
						float num8 = Math.Abs((float)k - vector.X);
						float num9 = Math.Abs(((float)l - vector.Y) * 2.3f);
						if (!(Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4))
							continue;

						if ((double)l < (double)vector.Y + num2 * 0.02) {
							if (Main.tile[k, l].type != 59)
								Main.tile[k, l].active(active: false);
						}
						else {
							Main.tile[k, l].type = 59;
						}

						Main.tile[k, l].liquid = 0;
						Main.tile[k, l].lava(lava: false);
					}
				}

				vector += vector2;
				vector.X += vector2.X;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y -= (float)genRand.Next(11) * 0.05f;
				if ((double)vector2.X > -0.5 && (double)vector2.X < 0.5) {
					if (vector2.X < 0f)
						vector2.X = -0.5f;
					else
						vector2.X = 0.5f;
				}

				if (vector2.X > 2f)
					vector2.X = 1f;

				if (vector2.X < -2f)
					vector2.X = -1f;

				if (vector2.Y > 1f)
					vector2.Y = 1f;

				if (vector2.Y < -1f)
					vector2.Y = -1f;

				for (int m = 0; m < 2; m++) {
					int num10 = (int)vector.X + genRand.Next(-20, 20);
					int num11 = (int)vector.Y + genRand.Next(0, 20);
					while (!Main.tile[num10, num11].active() && Main.tile[num10, num11].type != 59) {
						num10 = (int)vector.X + genRand.Next(-20, 20);
						num11 = (int)vector.Y + genRand.Next(0, 20);
					}

					int num12 = genRand.Next(7, 10);
					int num13 = genRand.Next(7, 10);
					TileRunner(num10, num11, num12 * Main.setting.MushroomScale, num13 + (int)(Main.setting.MushroomScale - 1) / 2, 59, addTile: false, 0f, 2f, noYChange: true);
					if (genRand.Next(3) == 0)
						TileRunner(num10, num11, num12 - 4 + Main.setting.MushroomScale, num13 - 3 + (int)(Main.setting.MushroomScale - 1) / 2, -1, addTile: false, 0f, 2f, noYChange: true);
				}
			}
		}

		public static void Cavinator(int i, int j, int steps) {
			double num = genRand.Next(7, 15);
			double num2 = num;
			int num3 = 1;
			if (genRand.Next(2) == 0)
				num3 = -1;

			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num4 = genRand.Next(20, 40);
			Vector2 vector2 = default(Vector2);
			vector2.Y = (float)genRand.Next(10, 20) * 0.01f;
			vector2.X = num3;
			while (num4 > 0) {
				num4--;
				int num5 = (int)((double)vector.X - num * 0.5);
				int num6 = (int)((double)vector.X + num * 0.5);
				int num7 = (int)((double)vector.Y - num * 0.5);
				int num8 = (int)((double)vector.Y + num * 0.5);
				if (num5 < 0)
					num5 = 0;

				if (num6 > Main.maxTilesX)
					num6 = Main.maxTilesX;

				if (num7 < 0)
					num7 = 0;

				if (num8 > Main.maxTilesY)
					num8 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num5; k < num6; k++) {
					for (int l = num7; l < num8; l++) {
						float num9 = Math.Abs((float)k - vector.X);
						float num10 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[k, l].type])
							Main.tile[k, l].active(active: false);
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > (float)num3 + 0.5f)
					vector2.X = (float)num3 + 0.5f;

				if (vector2.X < (float)num3 - 0.5f)
					vector2.X = (float)num3 - 0.5f;

				if (vector2.Y > 2f)
					vector2.Y = 2f;

				if (vector2.Y < 0f)
					vector2.Y = 0f;
			}

			if (steps > 0 && (double)(int)vector.Y < Main.rockLayer + 50.0)
				Cavinator((int)vector.X, (int)vector.Y, steps - 1);
		}

		public static void CaveOpenater(int i, int j) {
			double num = genRand.Next(7, 12);
			double num2 = num;
			int num3 = 1;
			if (genRand.Next(2) == 0)
				num3 = -1;

			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num4 = 100;
			Vector2 vector2 = default(Vector2);
			vector2.Y = 0f;
			vector2.X = num3;
			while (num4 > 0) {
				if (Main.tile[(int)vector.X, (int)vector.Y].wall == 0)
					num4 = 0;

				num4--;
				int num5 = (int)((double)vector.X - num * 0.5);
				int num6 = (int)((double)vector.X + num * 0.5);
				int num7 = (int)((double)vector.Y - num * 0.5);
				int num8 = (int)((double)vector.Y + num * 0.5);
				if (num5 < 0)
					num5 = 0;

				if (num6 > Main.maxTilesX)
					num6 = Main.maxTilesX;

				if (num7 < 0)
					num7 = 0;

				if (num8 > Main.maxTilesY)
					num8 = Main.maxTilesY;

				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num5; k < num6; k++) {
					for (int l = num7; l < num8; l++) {
						float num9 = Math.Abs((float)k - vector.X);
						float num10 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4)
							Main.tile[k, l].active(active: false);
					}
				}

				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > (float)num3 + 0.5f)
					vector2.X = (float)num3 + 0.5f;

				if (vector2.X < (float)num3 - 0.5f)
					vector2.X = (float)num3 - 0.5f;

				if (vector2.Y > 0f)
					vector2.Y = 0f;

				if ((double)vector2.Y < -0.5)
					vector2.Y = -0.5f;
			}
		}

		public static void DiamondTileFrame(int i, int j) {
			TileFrame(i - 1, j);
			TileFrame(i, j - 1);
			TileFrame(i, j + 1);
			TileFrame(i + 1, j);
		}

		public static void SquareTileFrame(int i, int j, bool resetFrame = true) {
			TileFrame(i - 1, j - 1);
			TileFrame(i - 1, j);
			TileFrame(i - 1, j + 1);
			TileFrame(i, j - 1);
			TileFrame(i, j, resetFrame);
			TileFrame(i, j + 1);
			TileFrame(i + 1, j - 1);
			TileFrame(i + 1, j);
			TileFrame(i + 1, j + 1);
		}

		public static void SquareWallFrame(int i, int j, bool resetFrame = true) {
			Framing.WallFrame(i - 1, j - 1);
			Framing.WallFrame(i - 1, j);
			Framing.WallFrame(i - 1, j + 1);
			Framing.WallFrame(i, j - 1);
			Framing.WallFrame(i, j, resetFrame);
			Framing.WallFrame(i, j + 1);
			Framing.WallFrame(i + 1, j - 1);
			Framing.WallFrame(i + 1, j);
			Framing.WallFrame(i + 1, j + 1);
		}

		public static void SectionTileFrameWithCheck(int startX, int startY, int endX, int endY) {
			int sectionX = Netplay.GetSectionX(startX);
			int sectionY = Netplay.GetSectionY(startY);
			int sectionX2 = Netplay.GetSectionX(endX);
			int sectionY2 = Netplay.GetSectionY(endY);
			for (int i = sectionX; i <= sectionX2; i++) {
				for (int j = sectionY; j <= sectionY2; j++) {
					if (Main.sectionManager.SectionLoaded(i, j) && !Main.sectionManager.SectionFramed(i, j)) {
						SectionTileFrame(i, j, i, j);
						if (Main.sectionManager.FrameSectionsLeft == 0)
							return;
					}
				}
			}
		}

		public static void SectionTileFrame(int startX, int startY, int endX, int endY) {
			Main.mapTime = Main.mapTimeMax + 10;
			noMapUpdate = true;
			int num = startX * 200;
			int num2 = (endX + 1) * 200;
			int num3 = startY * 150;
			int num4 = (endY + 1) * 150;
			if (num < 1)
				num = 1;

			if (num3 < 1)
				num3 = 1;

			if (num > Main.maxTilesX - 2)
				num = Main.maxTilesX - 2;

			if (num3 > Main.maxTilesY - 2)
				num3 = Main.maxTilesY - 2;

			if (num2 > Main.maxTilesX - 2)
				num2 = Main.maxTilesX - 2;

			if (num4 > Main.maxTilesY - 2)
				num4 = Main.maxTilesY - 2;

			for (int i = num - 1; i < num2 + 1; i++) {
				for (int j = num3 - 1; j < num4 + 1; j++) {
					if (Main.tile[i, j] == null)
						Main.tile[i, j] = new Tile();

					TileFrame(i, j, resetFrame: true, noBreak: true);
					Framing.WallFrame(i, j, resetFrame: true);
				}
			}

			for (int k = startX; k <= endX; k++) {
				for (int l = startY; l <= endY; l++) {
					Main.sectionManager.SetSectionFramed(k, l);
				}
			}

			noMapUpdate = false;
		}

		public static void RangeFrame(int startX, int startY, int endX, int endY) {
			int num = endX + 1;
			int num2 = endY + 1;
			for (int i = startX - 1; i < num + 1; i++) {
				for (int j = startY - 1; j < num2 + 1; j++) {
					TileFrame(i, j);
					Framing.WallFrame(i, j);
				}
			}
		}

		public static void WaterCheck() {
			Liquid.numLiquid = 0;
			LiquidBuffer.numLiquidBuffer = 0;
			for (int i = 1; i < Main.maxTilesX - 1; i++) {
				for (int num = Main.maxTilesY - 2; num > 0; num--) {
					Tile tile = Main.tile[i, num];
					tile.checkingLiquid(checkingLiquid: false);
					if (tile.liquid > 0 && tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type]) {
						tile.liquid = 0;
					}
					else if (tile.liquid > 0) {
						if (tile.active()) {
							if (tile.lava()) {
								if (TileObjectData.CheckLavaDeath(tile))
									KillTile(i, num);
							}
							else if (TileObjectData.CheckWaterDeath(tile)) {
								KillTile(i, num);
							}
						}

						Tile tile2 = Main.tile[i, num + 1];
						if ((!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]) && tile2.liquid < byte.MaxValue) {
							if (tile2.liquid > 250)
								tile2.liquid = byte.MaxValue;
							else
								Liquid.AddWater(i, num);
						}

						Tile tile3 = Main.tile[i - 1, num];
						Tile tile4 = Main.tile[i + 1, num];
						if ((!tile3.nactive() || !Main.tileSolid[tile3.type] || Main.tileSolidTop[tile3.type]) && tile3.liquid != tile.liquid)
							Liquid.AddWater(i, num);
						else if ((!tile4.nactive() || !Main.tileSolid[tile4.type] || Main.tileSolidTop[tile4.type]) && tile4.liquid != tile.liquid)
							Liquid.AddWater(i, num);

						if (tile.lava()) {
							if (tile3.liquid > 0 && !tile3.lava())
								Liquid.AddWater(i, num);
							else if (tile4.liquid > 0 && !tile4.lava())
								Liquid.AddWater(i, num);
							else if (Main.tile[i, num - 1].liquid > 0 && !Main.tile[i, num - 1].lava())
								Liquid.AddWater(i, num);
							else if (tile2.liquid > 0 && !tile2.lava())
								Liquid.AddWater(i, num);
						}
					}
				}
			}
		}

		public static void EveryTileFrame() {
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			noLiquidCheck = true;
			noTileActions = true;
			for (int i = 0; i < Main.maxTilesX; i++) {
				float num = (float)i / (float)Main.maxTilesX;
				Main.statusText = Lang.gen[55].Value + " " + (int)(num * 100f + 1f) + "%";
				for (int j = 0; j < Main.maxTilesY; j++) {
					if (Main.tile[i, j].active())
						TileFrame(i, j, resetFrame: true);

					if (Main.tile[i, j].wall > 0)
						Framing.WallFrame(i, j, resetFrame: true);
				}
			}

			noLiquidCheck = false;
			noTileActions = false;
			_ = stopwatch.ElapsedMilliseconds;
		}

		public static void PlantCheck(int i, int j) {
			int num = -1;
			int num2 = Main.tile[i, j].type;
			_ = i - 1;
			_ = 0;
			_ = i + 1;
			_ = Main.maxTilesX;
			_ = j - 1;
			_ = 0;
			if (j + 1 >= Main.maxTilesY)
				num = num2;

			if (i - 1 >= 0 && Main.tile[i - 1, j] != null && Main.tile[i - 1, j].nactive())
				_ = Main.tile[i - 1, j].type;

			if (i + 1 < Main.maxTilesX && Main.tile[i + 1, j] != null && Main.tile[i + 1, j].nactive())
				_ = Main.tile[i + 1, j].type;

			if (j - 1 >= 0 && Main.tile[i, j - 1] != null && Main.tile[i, j - 1].nactive())
				_ = Main.tile[i, j - 1].type;

			if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1] != null && Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].slope() == 0)
				num = Main.tile[i, j + 1].type;

			if (i - 1 >= 0 && j - 1 >= 0 && Main.tile[i - 1, j - 1] != null && Main.tile[i - 1, j - 1].nactive())
				_ = Main.tile[i - 1, j - 1].type;

			if (i + 1 < Main.maxTilesX && j - 1 >= 0 && Main.tile[i + 1, j - 1] != null && Main.tile[i + 1, j - 1].nactive())
				_ = Main.tile[i + 1, j - 1].type;

			if (i - 1 >= 0 && j + 1 < Main.maxTilesY && Main.tile[i - 1, j + 1] != null && Main.tile[i - 1, j + 1].nactive())
				_ = Main.tile[i - 1, j + 1].type;

			if (i + 1 < Main.maxTilesX && j + 1 < Main.maxTilesY && Main.tile[i + 1, j + 1] != null && Main.tile[i + 1, j + 1].nactive())
				_ = Main.tile[i + 1, j + 1].type;

			if ((num2 != 3 || num == 2 || num == 78 || num == 380) && (num2 != 24 || num == 23) && (num2 != 61 || num == 60) && (num2 != 71 || num == 70) && (num2 != 73 || num == 2 || num == 78 || num == 380) && (num2 != 74 || num == 60) && (num2 != 110 || num == 109) && (num2 != 113 || num == 109) && (num2 != 201 || num == 199))
				return;

			if ((num2 == 3 || num2 == 73) && num != 2 && Main.tile[i, j].frameX >= 162)
				Main.tile[i, j].frameX = 126;

			if (num2 == 74 && num != 60 && Main.tile[i, j].frameX >= 162)
				Main.tile[i, j].frameX = 126;

			switch (num) {
				case 23:
					num2 = 24;
					if (Main.tile[i, j].frameX >= 162)
						Main.tile[i, j].frameX = 126;
					break;
				case 2:
					num2 = ((num2 != 113) ? 3 : 73);
					break;
				case 109:
					num2 = ((num2 != 73) ? 110 : 113);
					break;
				case 199:
					num2 = 201;
					break;
				case 70:
					num2 = 71;
					while (Main.tile[i, j].frameX > 72) {
						Main.tile[i, j].frameX -= 72;
					}
					break;
			}

			if (num2 != Main.tile[i, j].type)
				Main.tile[i, j].type = (ushort)num2;
			else
				KillTile(i, j);
		}

		public static bool CheckPound(int i, int j) {
			if (Main.tile[i, j] == null)
				Main.tile[i, j] = new Tile();

			if (Main.tile[i, j - 1] == null)
				Main.tile[i, j - 1] = new Tile();

			if (Main.tile[i, j + 1] == null)
				Main.tile[i, j + 1] = new Tile();

			switch (Main.tile[i, j].type) {
				case 10:
				case 48:
				case 137:
				case 138:
				case 232:
				case 380:
				case 387:
				case 388:
					return false;
				default:
					if (gen) {
						if (Main.tile[i, j].type == 190)
							return false;

						if (Main.tile[i, j].type == 30)
							return false;
					}
					if (Main.tile[i, j - 1].active()) {
						if (TileID.Sets.BasicChest[Main.tile[i, j - 1].type])
							return false;
						switch (Main.tile[i, j - 1].type) {
							case 5:
							case 21:
							case 26:
							case 72:
							case 77:
							case 88:
							case 235:
							case 237:
							case 323:
							case 441:
							case 467:
							case 468:
								return false;
						}
					}
					return true;
			}
		}

		public static bool SlopeTile(int i, int j, int slope = 0) {
			if (!CheckPound(i, j))
				return false;

			Main.tile[i, j].halfBrick(halfBrick: false);
			Main.tile[i, j].slope((byte)slope);
			if (!gen) {
				KillTile(i, j, fail: true, effectOnly: true);
				Main.PlaySound(0, i * 16, j * 16);
				SquareTileFrame(i, j);
				if (Main.tile[i, j].slope() == 0) {
					Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
					for (int k = 0; k < 255; k++) {
						if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height))) {
							Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
							Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
						}
					}
				}
			}

			return true;
		}

		public static bool PoundTile(int i, int j) {
			if (!CheckPound(i, j))
				return false;

			if (!Main.tile[i, j].halfBrick())
				Main.tile[i, j].halfBrick(halfBrick: true);
			else
				Main.tile[i, j].halfBrick(halfBrick: false);

			if (!gen) {
				KillTile(i, j, fail: true, effectOnly: true);
				Main.PlaySound(0, i * 16, j * 16);
				SquareTileFrame(i, j);
				if (!Main.tile[i, j].halfBrick()) {
					Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
					for (int k = 0; k < 255; k++) {
						if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height))) {
							Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
							Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
						}
					}
				}
			}

			return true;
		}

		public static void PoundPlatform(int x, int y) {
			if (Main.tile[x, y].halfBrick()) {
				PoundTile(x, y);
				if (Main.netMode == 1)
					NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);

				return;
			}

			int num = 1;
			int slope = 2;
			if (TileID.Sets.Platforms[Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type] || (SolidTile(x + 1, y) && !SolidTile(x - 1, y))) {
				num = 2;
				slope = 1;
			}

			if (Main.tile[x, y].slope() == 0) {
				SlopeTile(x, y, num);
				int num2 = Main.tile[x, y].slope();
				if (Main.netMode == 1)
					NetMessage.SendData(17, -1, -1, null, 14, x, y, num2);

				return;
			}

			if (Main.tile[x, y].slope() == num) {
				SlopeTile(x, y, slope);
				int num3 = Main.tile[x, y].slope();
				if (Main.netMode == 1)
					NetMessage.SendData(17, -1, -1, null, 14, x, y, num3);

				return;
			}

			SlopeTile(x, y);
			int num4 = Main.tile[x, y].slope();
			if (Main.netMode == 1)
				NetMessage.SendData(17, -1, -1, null, 14, x, y, num4);

			PoundTile(x, y);
			if (Main.netMode == 1)
				NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
		}

		public static int PlatformProperSides(int x, int y, bool acceptNonOpposing = false) {
			Tile tile = Main.tile[x, y];
			if (!tile.active() || !TileID.Sets.Platforms[tile.type])
				return 0;

			int num = tile.slope();
			int num2 = -1;
			if (num == 1)
				num2 = 2;

			if (num == 2)
				num2 = 1;

			int num3 = 0;
			int num4 = 1;
			int num5 = 0;
			if (num == 1)
				num5 = 1;

			if (num == 2)
				num5 = -1;

			if (acceptNonOpposing) {
				if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
					num3++;
			}
			else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num) {
				num3++;
			}

			num4 *= -1;
			num5 *= -1;
			if (acceptNonOpposing) {
				if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
					num3++;
			}
			else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num) {
				num3++;
			}

			return num3;
		}

		public static bool UpdateMapTile(int i, int j, bool addToList = true) {
			bool result = false;
#if CLIENT
			if (Main.mapEnabled && !noMapUpdate && !gen && Main.Map[i, j].Light > 0 && Main.Map.UpdateType(i, j) && addToList) {
				result = true;
				if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1) {
					MapHelper.updateTileX[MapHelper.numUpdateTile] = (short)i;
					MapHelper.updateTileY[MapHelper.numUpdateTile] = (short)j;
					MapHelper.numUpdateTile++;
				}
				else {
					Main.refreshMap = true;
				}
			}

#endif
			return result;
		}

		public static void TileMergeAttemptFrametest(int i, int j, int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight) {
			if (up == lookfor) {
				TileFrame(i, j - 1);
				if (mergeDown)
					up = myType;
			}

			if (down == lookfor) {
				TileFrame(i, j + 1);
				if (mergeUp)
					down = myType;
			}

			if (left == lookfor) {
				TileFrame(i - 1, j);
				if (mergeRight)
					left = myType;
			}

			if (right == lookfor) {
				TileFrame(i + 1, j);
				if (mergeLeft)
					right = myType;
			}

			if (upLeft == lookfor)
				upLeft = myType;

			if (upRight == lookfor)
				upRight = myType;

			if (downLeft == lookfor)
				downLeft = myType;

			if (downRight == lookfor)
				downRight = myType;
		}

		public static void TileMergeAttemptFrametest(int i, int j, int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight) {
			if (up > -1 && lookfor[up]) {
				TileFrame(i, j - 1);
				if (mergeDown)
					up = myType;
			}

			if (down > -1 && lookfor[down]) {
				TileFrame(i, j + 1);
				if (mergeUp)
					down = myType;
			}

			if (left > -1 && lookfor[left]) {
				TileFrame(i - 1, j);
				if (mergeRight)
					left = myType;
			}

			if (right > -1 && lookfor[right]) {
				TileFrame(i + 1, j);
				if (mergeLeft)
					right = myType;
			}

			if (upLeft > -1 && lookfor[upLeft])
				upLeft = myType;

			if (upRight > -1 && lookfor[upRight])
				upRight = myType;

			if (downLeft > -1 && lookfor[downLeft])
				downLeft = myType;

			if (downRight > -1 && lookfor[downRight])
				downRight = myType;
		}

		public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right) {
			if (lookfor == up)
				up = myType;

			if (lookfor == down)
				down = myType;

			if (lookfor == left)
				left = myType;

			if (lookfor == right)
				right = myType;
		}

		public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight) {
			if (lookfor == up)
				up = myType;

			if (lookfor == down)
				down = myType;

			if (lookfor == left)
				left = myType;

			if (lookfor == right)
				right = myType;

			if (lookfor == upLeft)
				upLeft = myType;

			if (lookfor == upRight)
				upRight = myType;

			if (lookfor == downLeft)
				downLeft = myType;

			if (lookfor == downRight)
				downRight = myType;
		}

		public static void TileMergeAttempt(int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight) {
			if (up > -1 && lookfor[up])
				up = myType;

			if (down > -1 && lookfor[down])
				down = myType;

			if (left > -1 && lookfor[left])
				left = myType;

			if (right > -1 && lookfor[right])
				right = myType;

			if (upLeft > -1 && lookfor[upLeft])
				upLeft = myType;

			if (upRight > -1 && lookfor[upRight])
				upRight = myType;

			if (downLeft > -1 && lookfor[downLeft])
				downLeft = myType;

			if (downRight > -1 && lookfor[downRight])
				downRight = myType;
		}

		public static void TileMergeAttempt(int myType, bool[] lookfor, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight) {
			if (up > -1 && !exclude[up] && lookfor[up])
				up = myType;

			if (down > -1 && !exclude[down] && lookfor[down])
				down = myType;

			if (left > -1 && !exclude[left] && lookfor[left])
				left = myType;

			if (right > -1 && !exclude[right] && lookfor[right])
				right = myType;

			if (upLeft > -1 && !exclude[upLeft] && lookfor[upLeft])
				upLeft = myType;

			if (upRight > -1 && !exclude[upRight] && lookfor[upRight])
				upRight = myType;

			if (downLeft > -1 && !exclude[downLeft] && lookfor[downLeft])
				downLeft = myType;

			if (downRight > -1 && !exclude[downRight] && lookfor[downRight])
				downRight = myType;
		}

		public static void TileMergeAttemptWeird(int myType, int changeTo, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight) {
			if (up > -1 && !exclude[up] && up != myType)
				up = changeTo;

			if (down > -1 && !exclude[down] && down != myType)
				down = changeTo;

			if (left > -1 && !exclude[left] && left != myType)
				left = changeTo;

			if (right > -1 && !exclude[right] && right != myType)
				right = changeTo;

			if (upLeft > -1 && !exclude[upLeft] && upLeft != myType)
				upLeft = changeTo;

			if (upRight > -1 && !exclude[upRight] && upRight != myType)
				upRight = changeTo;

			if (downLeft > -1 && !exclude[downLeft] && downLeft != myType)
				downLeft = changeTo;

			if (downRight > -1 && !exclude[downRight] && downRight != myType)
				downRight = changeTo;
		}

		public static void TileFrame(int i, int j, bool resetFrame = false, bool noBreak = false) {
			bool addToList = false;
			try {
				if (i > 5 && j > 5 && i < Main.maxTilesX - 5 && j < Main.maxTilesY - 5 && Main.tile[i, j] != null) {
					addToList = UpdateMapTile(i, j);
					Tile tile = Main.tile[i, j];
					if (!tile.active()) {
						tile.halfBrick(halfBrick: false);
						tile.color(0);
						tile.slope(0);
					}

					if (tile.liquid > 0 && Main.netMode != 1 && !noLiquidCheck)
						Liquid.AddWater(i, j);

					if (tile.active()) {
						if (!TileLoader.TileFrame(i, j, tile.type, ref resetFrame, ref noBreak))
							return;

						if (noBreak && Main.tileFrameImportant[tile.type] && !TileLoader.IsTorch(tile.type))
							return;

						int num = tile.type;
						if (Main.tileStone[num])
							num = 1;

						int frameX = tile.frameX;
						int frameY = tile.frameY;
						Rectangle rectangle = new Rectangle(-1, -1, 0, 0);
						if (Main.tileFrameImportant[tile.type]) {
							switch (num) {
								case int _ when TileLoader.IsTorch(num): {
										Tile tile16 = Main.tile[i, j - 1];
										Tile tile17 = Main.tile[i, j + 1];
										Tile tile10 = Main.tile[i - 1, j];
										Tile tile11 = Main.tile[i + 1, j];
										Tile tile12 = Main.tile[i - 1, j + 1];
										Tile tile13 = Main.tile[i + 1, j + 1];
										Tile tile14 = Main.tile[i - 1, j - 1];
										Tile tile15 = Main.tile[i + 1, j - 1];
										short num31 = 0;
										if (tile.frameX >= 66)
											num31 = 66;

										int num32 = -1;
										int num33 = -1;
										int num34 = -1;
										int num35 = -1;
										int num36 = -1;
										int num37 = -1;
										int num38 = -1;
										if (tile16 != null && tile16.active() && !tile16.bottomSlope())
											_ = tile16.type;

										if (tile17 != null && tile17.active() && !tile17.halfBrick() && !tile17.topSlope())
											num32 = tile17.type;

										if (tile10 != null && tile10.active() && (tile10.slope() == 0 || (int)tile10.slope() % 2 != 1))
											num33 = tile10.type;

										if (tile11 != null && tile11.active() && (tile11.slope() == 0 || (int)tile11.slope() % 2 != 0))
											num34 = tile11.type;

										if (tile12 != null && tile12.active())
											num35 = tile12.type;

										if (tile13 != null && tile13.active())
											num36 = tile13.type;

										if (tile14 != null && tile14.active())
											num37 = tile14.type;

										if (tile15 != null && tile15.active())
											num38 = tile15.type;

										if (num32 >= 0 && Main.tileSolid[num32] && (!Main.tileNoAttach[num32] || TileID.Sets.Platforms[num32]))
											tile.frameX = num31;
										else if ((num33 >= 0 && Main.tileSolid[num33] && !Main.tileNoAttach[num33]) || num33 == 124 || (num33 == 5 && num37 == 5 && num35 == 5))
											tile.frameX = (short)(22 + num31);
										else if ((num34 >= 0 && Main.tileSolid[num34] && !Main.tileNoAttach[num34]) || num34 == 124 || (num34 == 5 && num38 == 5 && num36 == 5))
											tile.frameX = (short)(44 + num31);
										else if (tile.wall > 0)
											tile.frameX = num31;
										else
											KillTile(i, j);

										break;
									}
								case 442: {
										Tile tile16 = Main.tile[i, j - 1];
										Tile tile17 = Main.tile[i, j + 1];
										Tile tile10 = Main.tile[i - 1, j];
										Tile tile11 = Main.tile[i + 1, j];
										Tile tile12 = Main.tile[i - 1, j + 1];
										Tile tile13 = Main.tile[i + 1, j + 1];
										Tile tile14 = Main.tile[i - 1, j - 1];
										Tile tile15 = Main.tile[i + 1, j - 1];
										int num39 = -1;
										int num40 = -1;
										int num41 = -1;
										int num42 = -1;
										int num43 = -1;
										int num44 = -1;
										int num45 = -1;
										int num46 = -1;
										if (tile16 != null && tile16.nactive() && !tile16.bottomSlope())
											num40 = tile16.type;

										if (tile17 != null && tile17.nactive() && !tile17.halfBrick() && !tile17.topSlope())
											num39 = tile17.type;

										if (tile10 != null && tile10.nactive() && (tile10.slope() == 0 || (int)tile10.slope() % 2 != 1))
											num41 = tile10.type;

										if (tile11 != null && tile11.nactive() && (tile11.slope() == 0 || (int)tile11.slope() % 2 != 0))
											num42 = tile11.type;

										if (tile12 != null && tile12.nactive())
											num43 = tile12.type;

										if (tile13 != null && tile13.nactive())
											num44 = tile13.type;

										if (tile14 != null && tile14.nactive())
											num45 = tile14.type;

										if (tile15 != null && tile15.nactive())
											num46 = tile15.type;

										bool flag3 = false;
										bool flag4 = false;
										bool flag5 = false;
										bool flag6 = false;
										if (num39 >= 0 && Main.tileSolid[num39] && (!Main.tileNoAttach[num39] || TileID.Sets.Platforms[num39]) && (tile17.bottomSlope() || tile17.slope() == 0) && !tile17.halfBrick())
											flag6 = true;

										if (num40 >= 0 && Main.tileSolid[num40] && (!Main.tileNoAttach[num40] || (TileID.Sets.Platforms[num40] && tile16.halfBrick())) && (tile16.topSlope() || tile16.slope() == 0 || tile16.halfBrick()))
											flag3 = true;

										if ((num41 >= 0 && Main.tileSolid[num41] && !Main.tileNoAttach[num41] && (tile10.leftSlope() || tile10.slope() == 0) && !tile10.halfBrick()) || num41 == 124 || (num41 == 5 && num45 == 5 && num43 == 5))
											flag4 = true;

										if ((num42 >= 0 && Main.tileSolid[num42] && !Main.tileNoAttach[num42] && (tile11.rightSlope() || tile11.slope() == 0) && !tile11.halfBrick()) || num42 == 124 || (num42 == 5 && num46 == 5 && num44 == 5))
											flag5 = true;

										int num47 = tile.frameX / 22;
										bool flag7 = false;
										switch (num47) {
											case 0:
												flag7 = !flag6;
												break;
											case 1:
												flag7 = !flag3;
												break;
											case 2:
												flag7 = !flag4;
												break;
											case 3:
												flag7 = !flag5;
												break;
											default:
												flag7 = true;
												break;
										}

										if (flag7) {
											if (flag6)
												tile.frameX = 0;
											else if (flag3)
												tile.frameX = 22;
											else if (flag4)
												tile.frameX = 44;
											else if (flag5)
												tile.frameX = 66;
											else
												KillTile(i, j);
										}

										break;
									}
								case 136: {
										Tile tile16 = Main.tile[i, j - 1];
										Tile tile17 = Main.tile[i, j + 1];
										Tile tile10 = Main.tile[i - 1, j];
										Tile tile11 = Main.tile[i + 1, j];
										Tile tile12 = Main.tile[i - 1, j + 1];
										Tile tile13 = Main.tile[i + 1, j + 1];
										Tile tile14 = Main.tile[i - 1, j - 1];
										Tile tile15 = Main.tile[i + 1, j - 1];
										int num48 = -1;
										int num49 = -1;
										int num50 = -1;
										int num51 = -1;
										int num52 = -1;
										int num53 = -1;
										int num54 = -1;
										if (tile16 != null && tile16.nactive())
											_ = tile16.type;

										if (tile17 != null && tile17.nactive() && !tile17.halfBrick() && !tile17.topSlope())
											num48 = tile17.type;

										if (tile10 != null && tile10.nactive())
											num49 = tile10.type;

										if (tile11 != null && tile11.nactive())
											num50 = tile11.type;

										if (tile12 != null && tile12.nactive())
											num51 = tile12.type;

										if (tile13 != null && tile13.nactive())
											num52 = tile13.type;

										if (tile14 != null && tile14.nactive())
											num53 = tile14.type;

										if (tile15 != null && tile15.nactive())
											num54 = tile15.type;

										if (num48 >= 0 && Main.tileSolid[num48] && !Main.tileNoAttach[num48] && !tile17.halfBrick() && (tile17.slope() == 0 || tile17.bottomSlope()))
											tile.frameX = 0;
										else if ((num49 >= 0 && Main.tileSolid[num49] && !Main.tileNoAttach[num49] && (tile10.leftSlope() || tile10.slope() == 0) && !tile10.halfBrick()) || num49 == 124 || (num49 == 5 && num53 == 5 && num51 == 5))
											tile.frameX = 18;
										else if ((num50 >= 0 && Main.tileSolid[num50] && !Main.tileNoAttach[num50] && (tile11.rightSlope() || tile11.slope() == 0) && !tile11.halfBrick()) || num50 == 124 || (num50 == 5 && num54 == 5 && num52 == 5))
											tile.frameX = 36;
										else if (tile.wall > 0)
											tile.frameX = 54;
										else
											KillTile(i, j);

										break;
									}
								case 129:
								case 149: {
										Tile tile16 = Main.tile[i, j - 1];
										Tile tile17 = Main.tile[i, j + 1];
										Tile tile10 = Main.tile[i - 1, j];
										Tile tile11 = Main.tile[i + 1, j];
										int num27 = -1;
										int num28 = -1;
										int num29 = -1;
										int num30 = -1;
										if (tile16 != null && tile16.nactive() && !tile16.bottomSlope())
											num28 = tile16.type;

										if (tile17 != null && tile17.nactive() && !tile17.halfBrick() && !tile17.topSlope())
											num27 = tile17.type;

										if (tile10 != null && tile10.nactive())
											num29 = tile10.type;

										if (tile11 != null && tile11.nactive())
											num30 = tile11.type;

										if (num27 >= 0 && Main.tileSolid[num27] && !Main.tileSolidTop[num27])
											tile.frameY = 0;
										else if (num29 >= 0 && Main.tileSolid[num29] && !Main.tileSolidTop[num29])
											tile.frameY = 54;
										else if (num30 >= 0 && Main.tileSolid[num30] && !Main.tileSolidTop[num30])
											tile.frameY = 36;
										else if (num28 >= 0 && Main.tileSolid[num28] && !Main.tileSolidTop[num28])
											tile.frameY = 18;
										else
											KillTile(i, j);

										break;
									}
								default:
									if (num != 461) {
										switch (num) {
											case 178: {
													Tile tile16 = Main.tile[i, j - 1];
													Tile tile17 = Main.tile[i, j + 1];
													Tile tile10 = Main.tile[i - 1, j];
													Tile tile11 = Main.tile[i + 1, j];
													int num17 = -1;
													int num18 = -1;
													int num19 = -1;
													int num20 = -1;
													if (tile16 != null && tile16.active() && !tile16.bottomSlope())
														num18 = tile16.type;

													if (tile17 != null && tile17.active() && !tile17.halfBrick() && !tile17.topSlope())
														num17 = tile17.type;

													if (tile10 != null && tile10.active())
														num19 = tile10.type;

													if (tile11 != null && tile11.active())
														num20 = tile11.type;

													short num21 = (short)(genRand.Next(3) * 18);
													if (num17 >= 0 && Main.tileSolid[num17] && !Main.tileSolidTop[num17]) {
														if (tile.frameY < 0 || tile.frameY > 36)
															tile.frameY = num21;
													}
													else if (num19 >= 0 && Main.tileSolid[num19] && !Main.tileSolidTop[num19]) {
														if (tile.frameY < 108 || tile.frameY > 54)
															tile.frameY = (short)(108 + num21);
													}
													else if (num20 >= 0 && Main.tileSolid[num20] && !Main.tileSolidTop[num20]) {
														if (tile.frameY < 162 || tile.frameY > 198)
															tile.frameY = (short)(162 + num21);
													}
													else if (num18 >= 0 && Main.tileSolid[num18] && !Main.tileSolidTop[num18]) {
														if (tile.frameY < 54 || tile.frameY > 90)
															tile.frameY = (short)(54 + num21);
													}
													else {
														KillTile(i, j);
													}

													break;
												}
											case 184: {
													Tile tile16 = Main.tile[i, j - 1];
													Tile tile17 = Main.tile[i, j + 1];
													Tile tile10 = Main.tile[i - 1, j];
													Tile tile11 = Main.tile[i + 1, j];
													int num22 = -1;
													int num23 = -1;
													int num24 = -1;
													int num25 = -1;
													if (tile16 != null && tile16.active() && !tile16.bottomSlope())
														num23 = tile16.type;

													if (tile17 != null && tile17.active() && !tile17.halfBrick() && !tile17.topSlope())
														num22 = tile17.type;

													if (tile10 != null && tile10.active())
														num24 = tile10.type;

													if (tile11 != null && tile11.active())
														num25 = tile11.type;

													short num26 = (short)(genRand.Next(3) * 18);
													if (num22 >= 0 && Main.tileMoss[num22]) {
														if (num22 == 381)
															tile.frameX = 110;
														else
															tile.frameX = (short)(22 * (num22 - 179));

														if (tile.frameY < 0 || tile.frameY > 36)
															tile.frameY = num26;
													}
													else if (num23 >= 0 && Main.tileMoss[num23]) {
														if (num23 == 381)
															tile.frameX = 110;
														else
															tile.frameX = (short)(22 * (num23 - 179));

														if (tile.frameY < 54 || tile.frameY > 90)
															tile.frameY = (short)(54 + num26);
													}
													else if (num24 >= 0 && Main.tileMoss[num24]) {
														if (num24 == 381)
															tile.frameX = 110;
														else
															tile.frameX = (short)(22 * (num24 - 179));

														if (tile.frameY < 108 || tile.frameY > 54)
															tile.frameY = (short)(108 + num26);
													}
													else if (num25 >= 0 && Main.tileMoss[num25]) {
														if (num25 == 381)
															tile.frameX = 110;
														else
															tile.frameX = (short)(22 * (num25 - 179));

														if (tile.frameY < 162 || tile.frameY > 198)
															tile.frameY = (short)(162 + num26);
													}
													else {
														KillTile(i, j);
													}

													break;
												}
											case 3:
											case 24:
											case 61:
											case 71:
											case 73:
											case 74:
											case 110:
											case 113:
											case 201:
												PlantCheck(i, j);
												break;
											case 227:
												CheckDye(i, j);
												break;
											case 12:
											case 31:
												CheckOrb(i, j, num);
												break;
											case 165:
												CheckTight(i, j);
												break;
											case 324: {
													Tile tile17 = Main.tile[i, j + 1];
													if (tile17 == null) {
														tile17 = new Tile();
														Main.tile[i, j + 1] = tile17;
													}

													if (!tile17.nactive() || (!Main.tileSolid[tile17.type] && !Main.tileSolidTop[tile17.type]))
														KillTile(i, j);

													break;
												}
											case 235:
												Check3x1(i, j, num);
												break;
											case 185:
												CheckPile(i, j);
												break;
											default:
												if (num != 296 && num != 297 && num != 309 && num != 358 && num != 359 && num != 413 && num != 414) {
													if (num == 10) {
														if (!destroyObject) {
															int num2 = j;
															bool flag = false;
															int frameY2 = tile.frameY;
															int num3 = frameY2 / 54;
															num3 += tile.frameX / 54 * 36;
															num2 = j - frameY2 % 54 / 18;
															Tile tile2 = Main.tile[i, num2 - 1];
															Tile tile3 = Main.tile[i, num2];
															Tile tile4 = Main.tile[i, num2 + 1];
															Tile tile5 = Main.tile[i, num2 + 2];
															Tile tile6 = Main.tile[i, num2 + 3];
															if (tile2 == null) {
																tile2 = new Tile();
																Main.tile[i, num2 - 1] = tile2;
															}

															if (tile3 == null) {
																tile3 = new Tile();
																Main.tile[i, num2] = tile3;
															}

															if (tile4 == null) {
																tile4 = new Tile();
																Main.tile[i, num2 + 1] = tile4;
															}

															if (tile5 == null) {
																tile5 = new Tile();
																Main.tile[i, num2 + 2] = tile5;
															}

															if (tile6 == null) {
																tile6 = new Tile();
																Main.tile[i, num2 + 3] = tile6;
															}

															if (!tile2.active() || !Main.tileSolid[tile2.type])
																flag = true;

															if (!SolidTile(tile6))
																flag = true;

															if (!tile3.active() || tile3.type != num)
																flag = true;

															if (!tile4.active() || tile4.type != num)
																flag = true;

															if (!tile5.active() || tile5.type != num)
																flag = true;

															if (flag) {
																destroyObject = true;
																KillTile(i, num2);
																KillTile(i, num2 + 1);
																KillTile(i, num2 + 2);
																DropDoorItem(i, j, num3);
															}

															destroyObject = false;
														}

														break;
													}

													if (num == 11) {
														if (destroyObject)
															break;

														int num4 = 0;
														int num5 = i;
														int num6 = j;
														short frameX2 = tile.frameX;
														int frameY3 = tile.frameY;
														int num7 = frameY3 / 54;
														num7 += tile.frameX / 72 * 36;
														num6 = j - frameY3 % 54 / 18;
														bool flag2 = false;
														switch (frameX2 % 72) {
															case 0:
																num5 = i;
																num4 = 1;
																break;
															case 18:
																num5 = i - 1;
																num4 = 1;
																break;
															case 36:
																num5 = i + 1;
																num4 = -1;
																break;
															case 54:
																num5 = i;
																num4 = -1;
																break;
														}

														Tile tile7 = Main.tile[num5, num6 - 1];
														Tile tile8 = Main.tile[num5, num6 + 3];
														if (tile7 == null) {
															tile7 = new Tile();
															Main.tile[num5, num6 - 1] = tile7;
														}

														if (tile8 == null) {
															tile8 = new Tile();
															Main.tile[num5, num6 + 3] = tile8;
														}

														if (!tile7.active() || !Main.tileSolid[tile7.type] || !SolidTile(tile8)) {
															flag2 = true;
															destroyObject = true;
															DropDoorItem(i, j, num7);
														}

														int num8 = num5;
														if (num4 == -1)
															num8 = num5 - 1;

														for (int k = num8; k < num8 + 2; k++) {
															for (int l = num6; l < num6 + 3; l++) {
																if (!flag2) {
																	Tile tile9 = Main.tile[k, l];
																	if (!tile9.active() || tile9.type != 11) {
																		destroyObject = true;
																		DropDoorItem(i, j, num7);
																		flag2 = true;
																		k = num8;
																		l = num6;
																	}
																}

																if (flag2)
																	KillTile(k, l);
															}
														}

														destroyObject = false;
														break;
													}

													if (num == 314) {
														Minecart.FrameTrack(i, j, pound: false);
														break;
													}

													if (num == 380) {
														Tile tile10 = Main.tile[i - 1, j];
														if (tile10 == null)
															break;

														Tile tile11 = Main.tile[i + 1, j];
														if (tile11 == null)
															break;

														Tile tile12 = Main.tile[i - 1, j + 1];
														if (tile12 == null)
															break;

														Tile tile13 = Main.tile[i + 1, j + 1];
														if (tile13 == null)
															break;

														Tile tile14 = Main.tile[i - 1, j - 1];
														if (tile14 == null)
															break;

														Tile tile15 = Main.tile[i + 1, j - 1];
														if (tile15 != null) {
															int num9 = -1;
															int num10 = -1;
															if (tile10 != null && tile10.active())
																num10 = (Main.tileStone[tile10.type] ? 1 : tile10.type);

															if (tile11 != null && tile11.active())
																num9 = (Main.tileStone[tile11.type] ? 1 : tile11.type);

															if (num9 >= 0 && !Main.tileSolid[num9])
																num9 = -1;

															if (num10 >= 0 && !Main.tileSolid[num10])
																num10 = -1;

															if (num10 == num && num9 == num)
																rectangle.X = 18;
															else if (num10 == num && num9 != num)
																rectangle.X = 36;
															else if (num10 != num && num9 == num)
																rectangle.X = 0;
															else
																rectangle.X = 54;

															tile.frameX = (short)rectangle.X;
														}

														break;
													}

													if (num >= 0 && TileID.Sets.Platforms[num]) {
														Tile tile10 = Main.tile[i - 1, j];
														if (tile10 == null)
															break;

														Tile tile11 = Main.tile[i + 1, j];
														if (tile11 == null)
															break;

														Tile tile12 = Main.tile[i - 1, j + 1];
														if (tile12 == null)
															break;

														Tile tile13 = Main.tile[i + 1, j + 1];
														if (tile13 == null)
															break;

														Tile tile14 = Main.tile[i - 1, j - 1];
														if (tile14 == null)
															break;

														Tile tile15 = Main.tile[i + 1, j - 1];
														if (tile15 == null)
															break;

														int num11 = -1;
														int num12 = -1;
														if (tile10 != null && tile10.active())
															num12 = (Main.tileStone[tile10.type] ? 1 : ((!TileID.Sets.Platforms[tile10.type]) ? tile10.type : num));

														if (tile11 != null && tile11.active())
															num11 = (Main.tileStone[tile11.type] ? 1 : ((!TileID.Sets.Platforms[tile11.type]) ? tile11.type : num));

														if (num11 >= 0 && !Main.tileSolid[num11])
															num11 = -1;

														if (num12 >= 0 && !Main.tileSolid[num12])
															num12 = -1;

														if (num12 == num && tile10.halfBrick() != tile.halfBrick())
															num12 = -1;

														if (num11 == num && tile11.halfBrick() != tile.halfBrick())
															num11 = -1;

														if (num12 != -1 && num12 != num && tile.halfBrick())
															num12 = -1;

														if (num11 != -1 && num11 != num && tile.halfBrick())
															num11 = -1;

														if (num12 == -1 && tile14.active() && tile14.type == num && tile14.slope() == 1)
															num12 = num;

														if (num11 == -1 && tile15.active() && tile15.type == num && tile15.slope() == 2)
															num11 = num;

														if (num12 == num && tile10.slope() == 2 && num11 != num)
															num11 = -1;

														if (num11 == num && tile11.slope() == 1 && num12 != num)
															num12 = -1;

														if (tile.slope() == 1) {
															if (TileID.Sets.Platforms[tile11.type] && tile11.slope() == 0) {
																rectangle.X = 468;
															}
															else if (!tile13.active() && (!TileID.Sets.Platforms[tile13.type] || tile13.slope() == 2)) {
																if (!tile10.active() && (!TileID.Sets.Platforms[tile14.type] || tile14.slope() != 1))
																	rectangle.X = 432;
																else
																	rectangle.X = 360;
															}
															else if (!tile10.active() && (!TileID.Sets.Platforms[tile14.type] || tile14.slope() != 1)) {
																rectangle.X = 396;
															}
															else {
																rectangle.X = 180;
															}
														}
														else if (tile.slope() == 2) {
															if (TileID.Sets.Platforms[tile10.type] && tile10.slope() == 0) {
																rectangle.X = 450;
															}
															else if (!tile12.active() && (!TileID.Sets.Platforms[tile12.type] || tile12.slope() == 1)) {
																if (!tile11.active() && (!TileID.Sets.Platforms[tile15.type] || tile15.slope() != 2))
																	rectangle.X = 414;
																else
																	rectangle.X = 342;
															}
															else if (!tile11.active() && (!TileID.Sets.Platforms[tile15.type] || tile15.slope() != 2)) {
																rectangle.X = 378;
															}
															else {
																rectangle.X = 144;
															}
														}
														else if (num12 == num && num11 == num) {
															if (tile10.slope() == 2 && tile11.slope() == 1)
																rectangle.X = 252;
															else if (tile10.slope() == 2)
																rectangle.X = 216;
															else if (tile11.slope() == 1)
																rectangle.X = 234;
															else
																rectangle.X = 0;
														}
														else if (num12 == num && num11 == -1) {
															if (tile10.slope() == 2)
																rectangle.X = 270;
															else
																rectangle.X = 18;
														}
														else if (num12 == -1 && num11 == num) {
															if (tile11.slope() == 1)
																rectangle.X = 288;
															else
																rectangle.X = 36;
														}
														else if (num12 != num && num11 == num) {
															rectangle.X = 54;
														}
														else if (num12 == num && num11 != num) {
															rectangle.X = 72;
														}
														else if (num12 != num && num12 != -1 && num11 == -1) {
															rectangle.X = 108;
														}
														else if (num12 == -1 && num11 != num && num11 != -1) {
															rectangle.X = 126;
														}
														else {
															rectangle.X = 90;
														}

														tile.frameX = (short)rectangle.X;
														break;
													}

													switch (num) {
														case 233:
														case 236:
														case 238:
															CheckJunglePlant(i, j, num);
															break;
														case 240:
														case 440:
															Check3x3Wall(i, j);
															break;
														case 245:
															Check2x3Wall(i, j);
															break;
														case 246:
															Check3x2Wall(i, j);
															break;
														case 241:
															Check4x3Wall(i, j);
															break;
														case 242:
															Check6x4Wall(i, j);
															break;
														case 464:
														case 466:
															Check5x4(i, j, num);
															break;
														case 334:
															CheckWeaponsRack(i, j);
															break;
														case 34:
														case 454:
															CheckChand(i, j, num);
															break;
														default:
															if (num != 354 && num != 406 && num != 412 && num != 355 && num != 452 && num != 455) {
																switch (num) {
																	case 15:
																	case 20:
																	case int _ when TileLoader.IsSapling(num):
																	case 216:
																	case 338:
																	case 390:
																		Check1x2(i, j, (ushort)num);
																		return;
																	default:
																		if (num >= 391 && num <= 394)
																			break;
																		switch (num) {
																			case 405:
																				break;
																			case 36:
																			case 135:
																			case 141:
																			case 144:
																			case 210:
																			case 239:
																			case 428:
																				Check1x1(i, j, num);
																				return;
																			case 419:
																			case 420:
																			case 423:
																			case 424:
																			case 429:
																			case 445:
																				CheckLogicTiles(i, j, num);
																				return;
																			case 16:
																			case 18:
																			case 29:
																			case 103:
																			case 134:
																			case 462:
																				Check2x1(i, j, (ushort)num);
																				return;
																			case 13:
																			case 33:
																			case 50:
																			case 78:
																			case 174:
																			case 372:
																				CheckOnTable1x1(i, j, (byte)num);
																				return;
																			default:
																				if (TileID.Sets.BasicChest[num] && num < TileID.Count) {
																					CheckChest(i, j, num);
																					return;
																				}
																				switch (num) {
																					case 128:
																						CheckMan(i, j);
																						break;
																					case 269:
																						CheckWoman(i, j);
																						break;
																					case 27:
																						CheckSunflower(i, j);
																						break;
																					case 28:
																						CheckPot(i, j);
																						break;
																					case 171:
																						CheckXmasTree(i, j);
																						break;
																					default:
																						if (!TileID.Sets.BasicChestFake[num] && num != 457) {
																							switch (num) {
																								case 335:
																								case 411:
																									Check2x2(i, j, num);
																									return;
																								default:
																									if (num >= 316 && num <= 318)
																										break;
																									switch (num) {
																										case 172:
																										case 360:
																											break;
																										case 376:
																										case 443:
																										case 444:
																											CheckSuper(i, j, num);
																											return;
																										case 91:
																											CheckBanner(i, j, (byte)num);
																											return;
																										case 35:
																										case 139:
																											CheckMB(i, j, (byte)num);
																											return;
																										case 386:
																										case 387:
																											CheckTrapDoor(i, j, num);
																											return;
																										case 388:
																										case 389:
																											CheckTallGate(i, j, num);
																											return;
																										case 92:
																										case 93:
																										case 453:
																											Check1xX(i, j, (short)num);
																											return;
																										case 104:
																										case 105:
																										case 207:
																										case 320:
																										case 337:
																										case 349:
																										case 356:
																										case 378:
																										case 410:
																										case 456:
																										case 465:
																											Check2xX(i, j, (ushort)num);
																											return;
																										case 101:
																										case 102:
																										case 463:
																											Check3x4(i, j, num);
																											return;
																										case 42:
																										case 270:
																										case 271:
																											Check1x2Top(i, j, (ushort)num);
																											return;
																										case 55:
																										case 85:
																										case 395:
																										case 425:
																											CheckSign(i, j, (ushort)num);
																											return;
																										case 209:
																											CheckCannon(i, j, num);
																											return;
																										case 79:
																										case 90:
																											Check4x2(i, j, num);
																											return;
																										case 94:
																										case 95:
																										case 97:
																										case 98:
																										case 99:
																										case 100:
																										case 125:
																										case 126:
																										case 173:
																										case 282:
																										case 287:
																										case 319:
																											Check2x2(i, j, num);
																											return;
																										case 96:
																											Check2x2Style(i, j, num);
																											return;
																										case 81: {
																												Tile tile16 = Main.tile[i, j - 1];
																												Tile tile17 = Main.tile[i, j + 1];
																												Tile tile10 = Main.tile[i - 1, j];
																												Tile tile11 = Main.tile[i + 1, j];
																												int num15 = -1;
																												int num16 = -1;
																												if (tile16 != null && tile16.active())
																													num16 = tile16.type;

																												if (tile17 != null && tile17.active())
																													num15 = tile17.type;

																												if (num16 != -1)
																													KillTile(i, j);
																												else if (num15 < 0 || !Main.tileSolid[num15] || tile17.halfBrick() || tile17.topSlope())
																													KillTile(i, j);

																												return;
																											}
																										default:
																											if (Main.tileAlch[num]) {
																												CheckAlch(i, j);
																												return;
																											}
																											switch (num) {
																												case 72: {
																														Tile tile16 = Main.tile[i, j - 1];
																														Tile tile17 = Main.tile[i, j + 1];
																														int num13 = -1;
																														int num14 = -1;
																														if (tile16 != null && tile16.active())
																															num14 = tile16.type;

																														if (tile17 != null && tile17.active())
																															num13 = tile17.type;

																														if (num13 != num && num13 != 70) {
																															KillTile(i, j);
																														}
																														else if (num14 != num && tile.frameX == 0) {
																															tile.frameNumber((byte)genRand.Next(3));
																															if (tile.frameNumber() == 0) {
																																tile.frameX = 18;
																																tile.frameY = 0;
																															}

																															if (tile.frameNumber() == 1) {
																																tile.frameX = 18;
																																tile.frameY = 18;
																															}

																															if (tile.frameNumber() == 2) {
																																tile.frameX = 18;
																																tile.frameY = 36;
																															}
																														}

																														break;
																													}
																												case 5:
																													CheckTree(i, j);
																													break;
																												case 323:
																													CheckPalmTree(i, j);
																													break;
																											}
																											TileLoader.CheckModTile(i, j, num); // TODO: Test this. Not sure this is still correct.
																											return;
																									}
																									break;
																								case 132:
																								case 138:
																								case 142:
																								case 143:
																								case 288:
																								case 289:
																								case 290:
																								case 291:
																								case 292:
																								case 293:
																								case 294:
																								case 295:
																									break;
																							}

																							Check2x2(i, j, num);
																							break;
																						}
																						goto case 254;
																					case 254:
																						Check2x2Style(i, j, num);
																						break;
																				}
																				return;
																		}
																		break;
																	case 14:
																	case 17:
																	case 26:
																	case 77:
																	case 86:
																	case 87:
																	case 88:
																	case 89:
																	case 114:
																	case 133:
																	case 186:
																	case 187:
																	case 215:
																	case 217:
																	case 218:
																	case 237:
																	case 244:
																	case 285:
																	case 286:
																	case 298:
																	case 299:
																	case 310:
																	case 339:
																	case 361:
																	case 362:
																	case 363:
																	case 364:
																	case 377:
																	case 469:
																		break;
																}

																Check3x2(i, j, (ushort)num);
																break;
															}
															goto case 106;
														case 106:
														case 212:
														case 219:
														case 220:
														case 228:
														case 231:
														case 243:
														case 247:
														case 283:
														case 300:
														case 301:
														case 302:
														case 303:
														case 304:
														case 305:
														case 306:
														case 307:
														case 308:
															Check3x3(i, j, (ushort)num);
															break;
													}

													break;
												}
												goto case 275;
											case 275:
											case 276:
											case 277:
											case 278:
											case 279:
											case 280:
											case 281:
												Check6x3(i, j, num);
												break;
										}

										break;
									}
									goto case 373;
								case 373:
								case 374:
								case 375: {
										Tile tile16 = Main.tile[i, j - 1];
										if (tile16 == null || !tile16.active() || tile16.bottomSlope() || !Main.tileSolid[tile16.type] || Main.tileSolidTop[tile16.type])
											KillTile(i, j);

										break;
									}
							}

							return;
						}

						if (num < 255 || num > 268) {
							switch (num) {
								case 385:
								case 446:
								case 447:
								case 448:
									break;
								default: {
										Tile tile16 = Main.tile[i, j - 1];
										Tile tile17 = Main.tile[i, j + 1];
										Tile tile10 = Main.tile[i - 1, j];
										Tile tile11 = Main.tile[i + 1, j];
										Tile tile12 = Main.tile[i - 1, j + 1];
										Tile tile13 = Main.tile[i + 1, j + 1];
										Tile tile14 = Main.tile[i - 1, j - 1];
										Tile tile15 = Main.tile[i + 1, j - 1];
										int upLeft = -1;
										int up = -1;
										int upRight = -1;
										int left = -1;
										int right = -1;
										int downLeft = -1;
										int down = -1;
										int downRight = -1;
										if (tile10 != null && tile10.active()) {
											left = (Main.tileStone[tile10.type] ? 1 : tile10.type);
											if (tile10.slope() == 1 || tile10.slope() == 3)
												left = -1;
										}

										if (tile11 != null && tile11.active()) {
											right = (Main.tileStone[tile11.type] ? 1 : tile11.type);
											if (tile11.slope() == 2 || tile11.slope() == 4)
												right = -1;
										}

										if (tile16 != null && tile16.active()) {
											up = (Main.tileStone[tile16.type] ? 1 : tile16.type);
											if (tile16.slope() == 3 || tile16.slope() == 4)
												up = -1;
										}

										if (tile17 != null && tile17.active()) {
											down = (Main.tileStone[tile17.type] ? 1 : tile17.type);
											if (tile17.slope() == 1 || tile17.slope() == 2)
												down = -1;
										}

										if (tile14 != null && tile14.active())
											upLeft = (Main.tileStone[tile14.type] ? 1 : tile14.type);

										if (tile15 != null && tile15.active())
											upRight = (Main.tileStone[tile15.type] ? 1 : tile15.type);

										if (tile12 != null && tile12.active())
											downLeft = (Main.tileStone[tile12.type] ? 1 : tile12.type);

										if (tile13 != null && tile13.active())
											downRight = (Main.tileStone[tile13.type] ? 1 : tile13.type);

										if (tile.slope() == 2) {
											up = -1;
											left = -1;
										}

										if (tile.slope() == 1) {
											up = -1;
											right = -1;
										}

										if (tile.slope() == 4) {
											down = -1;
											left = -1;
										}

										if (tile.slope() == 3) {
											down = -1;
											right = -1;
										}

										switch (num) {
											case int _ when TileID.Sets.Snow[num]:
												TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
											case int _ when TileID.Sets.Ices[num]:
												TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
											case 162:
												TileMergeAttempt(num, Main.tileBrick, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
											default:
												if (Main.tileBrick[num]) {
													if (TileID.Sets.GrassSpecial[num])
														TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													else
														TileMergeAttempt(num, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												}
												else if (Main.tilePile[num]) {
													TileMergeAttempt(num, Main.tilePile, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												}
												break;
										}

										if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && down == 165) {
											if (tile17.frameY == 72)
												down = num;
											else if (tile17.frameY == 0)
												down = num;
										}

										if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && up == 165) {
											if (tile16.frameY == 90)
												up = num;
											else if (tile16.frameY == 54)
												up = num;
										}

										if (num == 225) {
											if (down == 165)
												down = num;

											if (up == 165)
												up = num;
										}

										if (TileID.Sets.Ices[num] && down == 165)
											down = num;

										if ((tile.slope() == 1 || tile.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
											down = num;

										if (up > -1 && (tile16.slope() == 1 || tile16.slope() == 2) && !TileID.Sets.Platforms[up])
											up = num;

										if ((tile.slope() == 3 || tile.slope() == 4) && up > -1 && !TileID.Sets.Platforms[up])
											up = num;

										if (down > -1 && (tile17.slope() == 3 || tile17.slope() == 4) && !TileID.Sets.Platforms[down])
											down = num;

										if (num == 124) {
											if (up > -1 && Main.tileSolid[up])
												up = num;

											if (down > -1 && Main.tileSolid[down])
												down = num;
										}

										if (up > -1 && tile16.halfBrick() && !TileID.Sets.Platforms[up])
											up = num;

										if (left > -1 && tile10.halfBrick()) {
											if (tile.halfBrick())
												left = num;
											else if (tile10.type != num)
												left = -1;
										}

										if (right > -1 && tile11.halfBrick()) {
											if (tile.halfBrick())
												right = num;
											else if (tile11.type != num)
												right = -1;
										}

										if (tile.halfBrick()) {
											if (left != num)
												left = -1;

											if (right != num)
												right = -1;

											up = -1;
										}

										if (tile17 != null && tile17.halfBrick())
											down = -1;

										if (!Main.tileSolid[num]) {
											switch (num) {
												case 49:
													CheckOnTable1x1(i, j, (byte)num);
													return;
												case 80:
													CactusFrame(i, j);
													return;
											}
										}

										mergeUp = false;
										mergeDown = false;
										mergeLeft = false;
										mergeRight = false;
										int num55 = 0;
										if (resetFrame) {
											num55 = genRand.Next(0, 3);
											tile.frameNumber((byte)num55);
										}
										else {
											num55 = tile.frameNumber();
										}

										if (Main.tileLargeFrames[num] == 1) {
											int num56 = j % 4;
											int num57 = i % 3;
											num55 = (new int[4, 3] {
												{
													2,
													4,
													2
												},
												{
												1,
												3,
												1
											},
												{
												2,
												2,
												4
											},
												{
												1,
												1,
												3
											}
											})[num56, num57] - 1;
										}

										TileMergeAttempt(num, Main.tileBlendAll, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										if (Main.tileBlendAll[num])
											TileMergeAttempt(num, Main.tileSolid, Main.tileSolidTop, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);

										switch (num) {
											case 0:
												if (up > -1 && Main.tileMergeDirt[up]) {
													TileFrame(i, j - 1);
													if (mergeDown)
														up = num;
												}
												else if (up > -1 && TileID.Sets.Snow[up]) {
													TileFrame(i, j - 1);
													if (mergeDown)
														up = num;
												}
												if (down > -1 && Main.tileMergeDirt[down]) {
													TileFrame(i, j + 1);
													if (mergeUp)
														down = num;
												}
												else if (down > -1 && TileID.Sets.Snow[down]) {
													TileFrame(i, j + 1);
													if (mergeUp)
														down = num;
												}
												if (left > -1 && Main.tileMergeDirt[left]) {
													TileFrame(i - 1, j);
													if (mergeRight)
														left = num;
												}
												else if (left > -1 && TileID.Sets.Snow[left]) {
													TileFrame(i - 1, j);
													if (mergeRight)
														left = num;
												}
												if (right > -1 && Main.tileMergeDirt[right]) {
													TileFrame(i + 1, j);
													if (mergeLeft)
														right = num;
												}
												else if (right > -1 && TileID.Sets.Snow[right]) {
													TileFrame(i + 1, j);
													if (mergeLeft)
														right = num;
												}
												if (up > -1 && TileID.Sets.Grass[up])
													up = num;
												if (down > -1 && TileID.Sets.Grass[down])
													down = num;
												if (left > -1 && TileID.Sets.Grass[left])
													left = num;
												if (right > -1 && TileID.Sets.Grass[right])
													right = num;
												if (upLeft > -1 && Main.tileMergeDirt[upLeft])
													upLeft = num;
												else if (upLeft > -1 && TileID.Sets.Grass[upLeft])
													upLeft = num;
												if (upRight > -1 && Main.tileMergeDirt[upRight])
													upRight = num;
												else if (upRight > -1 && TileID.Sets.Grass[upRight])
													upRight = num;
												if (downLeft > -1 && Main.tileMergeDirt[downLeft])
													downLeft = num;
												else if (downLeft > -1 && TileID.Sets.Grass[downLeft])
													downLeft = num;
												if (downRight > -1 && Main.tileMergeDirt[downRight])
													downRight = num;
												else if (downRight > -1 && TileID.Sets.Grass[downRight])
													downRight = num;
												TileMergeAttempt(-2, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												TileMergeAttempt(num, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
											case 213:
												if (up > -1 && Main.tileSolid[up] && !Main.tileSolidTop[up])
													up = num;
												if (down > -1 && Main.tileSolid[down])
													down = num;
												if (up != num) {
													if (left > -1 && Main.tileSolid[left])
														left = num;

													if (right > -1 && Main.tileSolid[right])
														right = num;
												}
												break;
											case 53:
												TileMergeAttemptFrametest(i, j, num, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
											case 234:
												TileMergeAttemptFrametest(i, j, num, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
											case 112:
												TileMergeAttemptFrametest(i, j, num, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
											case 116:
												TileMergeAttemptFrametest(i, j, num, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
												break;
										}

										if (Main.tileMergeDirt[num]) {
											TileMergeAttempt(-2, 0, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											if (num == 1) {
												if ((double)j > Main.rockLayer)
													TileMergeAttemptFrametest(i, j, num, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);

												TileMergeAttemptFrametest(i, j, num, 57, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											}
										}
										else {
											switch (num) {
												case int _ when TileID.Sets.HellSpecial[num]:
													TileMergeAttempt(-2, 57, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 57:
													TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case int _ when TileID.Sets.Mud[num]:
													if ((double)j > Main.rockLayer)
														TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttempt(num, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, TileID.Sets.JungleSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													if ((double)j < Main.rockLayer)
														TileMergeAttemptFrametest(i, j, num, 0, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													else
														TileMergeAttempt(num, 0, ref up, ref down, ref left, ref right);
													break;
												case 211:
													TileMergeAttempt(59, 60, ref up, ref down, ref left, ref right);
													TileMergeAttempt(-2, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 225:
												case 226:
													TileMergeAttempt(-2, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 60:
													TileMergeAttempt(59, 211, ref up, ref down, ref left, ref right);
													break;
												case 189:
													TileMergeAttemptFrametest(i, j, num, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 196:
													TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case int _ when TileID.Sets.Snow[num]:
													TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case int _ when TileID.Sets.IcesSlush[num]:
													TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 162:
													TileMergeAttempt(-2, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 32:
													if (down == 23)
														down = num;
													break;
												case 352:
													if (down == 199)
														down = num;
													break;
												case 69:
													if (down == 60)
														down = num;
													break;
												case 51:
													TileMergeAttempt(num, TileID.Sets.AllTiles, Main.tileNoAttach, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 192:
													TileMergeAttemptFrametest(i, j, num, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 191:
													TileMergeAttempt(-2, 192, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttempt(num, 0, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 384:
													TileMergeAttemptFrametest(i, j, num, 383, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 383:
													TileMergeAttempt(-2, 384, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttempt(num, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 407:
													TileMergeAttempt(-2, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 404:
													TileMergeAttempt(-2, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, 407, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 397:
													TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 396:
													TileMergeAttempt(-2, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 398:
													TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 400:
													TileMergeAttempt(-2, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 399:
													TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 401:
													TileMergeAttempt(-2, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 402:
													TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
												case 403:
													TileMergeAttempt(-2, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
													break;
											}
										}

										if (Main.tileStone[num] || num == 1)
											TileMergeAttempt(num, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);

										bool flag8 = false;
										if (up == -2 && tile.color() != tile16.color()) {
											up = num;
											mergeUp = true;
										}

										if (down == -2 && tile.color() != tile17.color()) {
											down = num;
											mergeDown = true;
										}

										if (left == -2 && tile.color() != tile10.color()) {
											left = num;
											mergeLeft = true;
										}

										if (right == -2 && tile.color() != tile11.color()) {
											right = num;
											mergeRight = true;
										}

										if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num]) {
											flag8 = true;
											TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											int num58 = TileID.Sets.NeedsGrassFramingDirt[num];
											if (TileID.Sets.GrassSpecial[num]) {
												num58 = 59;
											}
											else if (Main.tileMoss[num]) {
												num58 = 1;
											}
											else {
												switch (num) {
													case 2:
														TileMergeAttempt(num58, 23, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
														break;
													case 23:
														TileMergeAttempt(num58, 2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
														break;
												}
											}

											if (up != num && up != num58 && (down == num || down == num58)) {
												if (left == num58 && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 0;
															rectangle.Y = 198;
															break;
														case 1:
															rectangle.X = 18;
															rectangle.Y = 198;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 198;
															break;
													}
												}
												else if (left == num && right == num58) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 198;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 198;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 198;
															break;
													}
												}
											}
											else if (down != num && down != num58 && (up == num || up == num58)) {
												if (left == num58 && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 0;
															rectangle.Y = 216;
															break;
														case 1:
															rectangle.X = 18;
															rectangle.Y = 216;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 216;
															break;
													}
												}
												else if (left == num && right == num58) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 216;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 216;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 216;
															break;
													}
												}
											}
											else if (left != num && left != num58 && (right == num || right == num58)) {
												if (up == num58 && down == num) {
													switch (num55) {
														case 0:
															rectangle.X = 72;
															rectangle.Y = 144;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 162;
															break;
														default:
															rectangle.X = 72;
															rectangle.Y = 180;
															break;
													}
												}
												else if (down == num && up == num58) {
													switch (num55) {
														case 0:
															rectangle.X = 72;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 108;
															break;
														default:
															rectangle.X = 72;
															rectangle.Y = 126;
															break;
													}
												}
											}
											else if (right != num && right != num58 && (left == num || left == num58)) {
												if (up == num58 && down == num) {
													switch (num55) {
														case 0:
															rectangle.X = 90;
															rectangle.Y = 144;
															break;
														case 1:
															rectangle.X = 90;
															rectangle.Y = 162;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 180;
															break;
													}
												}
												else if (down == num && right == up) {
													switch (num55) {
														case 0:
															rectangle.X = 90;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 90;
															rectangle.Y = 108;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 126;
															break;
													}
												}
											}
											else if (up == num && down == num && left == num && right == num) {
												if (upLeft != num && upRight != num && downLeft != num && downRight != num) {
													if (downRight == num58) {
														switch (num55) {
															case 0:
																rectangle.X = 108;
																rectangle.Y = 324;
																break;
															case 1:
																rectangle.X = 126;
																rectangle.Y = 324;
																break;
															default:
																rectangle.X = 144;
																rectangle.Y = 324;
																break;
														}
													}
													else if (upRight == num58) {
														switch (num55) {
															case 0:
																rectangle.X = 108;
																rectangle.Y = 342;
																break;
															case 1:
																rectangle.X = 126;
																rectangle.Y = 342;
																break;
															default:
																rectangle.X = 144;
																rectangle.Y = 342;
																break;
														}
													}
													else if (downLeft == num58) {
														switch (num55) {
															case 0:
																rectangle.X = 108;
																rectangle.Y = 360;
																break;
															case 1:
																rectangle.X = 126;
																rectangle.Y = 360;
																break;
															default:
																rectangle.X = 144;
																rectangle.Y = 360;
																break;
														}
													}
													else if (upLeft == num58) {
														switch (num55) {
															case 0:
																rectangle.X = 108;
																rectangle.Y = 378;
																break;
															case 1:
																rectangle.X = 126;
																rectangle.Y = 378;
																break;
															default:
																rectangle.X = 144;
																rectangle.Y = 378;
																break;
														}
													}
													else {
														switch (num55) {
															case 0:
																rectangle.X = 144;
																rectangle.Y = 234;
																break;
															case 1:
																rectangle.X = 198;
																rectangle.Y = 234;
																break;
															default:
																rectangle.X = 252;
																rectangle.Y = 234;
																break;
														}
													}
												}
												else if (upLeft != num && downRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 306;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 306;
															break;
														default:
															rectangle.X = 72;
															rectangle.Y = 306;
															break;
													}
												}
												else if (upRight != num && downLeft != num) {
													switch (num55) {
														case 0:
															rectangle.X = 90;
															rectangle.Y = 306;
															break;
														case 1:
															rectangle.X = 108;
															rectangle.Y = 306;
															break;
														default:
															rectangle.X = 126;
															rectangle.Y = 306;
															break;
													}
												}
												else if (upLeft != num && upRight == num && downLeft == num && downRight == num) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 180;
															break;
													}
												}
												else if (upLeft == num && upRight != num && downLeft == num && downRight == num) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 180;
															break;
													}
												}
												else if (upLeft == num && upRight == num && downLeft != num && downRight == num) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 162;
															break;
													}
												}
												else if (upLeft == num && upRight == num && downLeft == num && downRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 162;
															break;
													}
												}
											}
											else if (up == num && down == num58 && left == num && right == num && upLeft == -1 && upRight == -1) {
												switch (num55) {
													case 0:
														rectangle.X = 108;
														rectangle.Y = 18;
														break;
													case 1:
														rectangle.X = 126;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 144;
														rectangle.Y = 18;
														break;
												}
											}
											else if (up == num58 && down == num && left == num && right == num && downLeft == -1 && downRight == -1) {
												switch (num55) {
													case 0:
														rectangle.X = 108;
														rectangle.Y = 36;
														break;
													case 1:
														rectangle.X = 126;
														rectangle.Y = 36;
														break;
													default:
														rectangle.X = 144;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up == num && down == num && left == num58 && right == num && upRight == -1 && downRight == -1) {
												switch (num55) {
													case 0:
														rectangle.X = 198;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 198;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 198;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up == num && down == num && left == num && right == num58 && upLeft == -1 && downLeft == -1) {
												switch (num55) {
													case 0:
														rectangle.X = 180;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 180;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 180;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up == num && down == num58 && left == num && right == num) {
												if (upRight != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 180;
															break;
													}
												}
												else if (upLeft != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 180;
															break;
													}
												}
											}
											else if (up == num58 && down == num && left == num && right == num) {
												if (downRight != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 162;
															break;
													}
												}
												else if (downLeft != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 162;
															break;
													}
												}
											}
											else if (up == num && down == num && left == num && right == num58) {
												if (upLeft != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 162;
															break;
													}
												}
												else if (downLeft != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 180;
															break;
													}
												}
											}
											else if (up == num && down == num && left == num58 && right == num) {
												if (upRight != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 162;
															break;
													}
												}
												else if (downRight != -1) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 180;
															break;
													}
												}
											}
											else if ((up == num58 && down == num && left == num && right == num) || (up == num && down == num58 && left == num && right == num) || (up == num && down == num && left == num58 && right == num) || (up == num && down == num && left == num && right == num58)) {
												switch (num55) {
													case 0:
														rectangle.X = 18;
														rectangle.Y = 18;
														break;
													case 1:
														rectangle.X = 36;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 54;
														rectangle.Y = 18;
														break;
												}
											}

											if ((up == num || up == num58) && (down == num || down == num58) && (left == num || left == num58) && (right == num || right == num58)) {
												if (upLeft != num && upLeft != num58 && (upRight == num || upRight == num58) && (downLeft == num || downLeft == num58) && (downRight == num || downRight == num58)) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 180;
															break;
													}
												}
												else if (upRight != num && upRight != num58 && (upLeft == num || upLeft == num58) && (downLeft == num || downLeft == num58) && (downRight == num || downRight == num58)) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 180;
															break;
													}
												}
												else if (downLeft != num && downLeft != num58 && (upLeft == num || upLeft == num58) && (upRight == num || upRight == num58) && (downRight == num || downRight == num58)) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 162;
															break;
													}
												}
												else if (downRight != num && downRight != num58 && (upLeft == num || upLeft == num58) && (downLeft == num || downLeft == num58) && (upRight == num || upRight == num58)) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 162;
															break;
													}
												}
											}

											if (up != num58 && up != num && down == num && left != num58 && left != num && right == num && downRight != num58 && downRight != num) {
												switch (num55) {
													case 0:
														rectangle.X = 90;
														rectangle.Y = 270;
														break;
													case 1:
														rectangle.X = 108;
														rectangle.Y = 270;
														break;
													default:
														rectangle.X = 126;
														rectangle.Y = 270;
														break;
												}
											}
											else if (up != num58 && up != num && down == num && left == num && right != num58 && right != num && downLeft != num58 && downLeft != num) {
												switch (num55) {
													case 0:
														rectangle.X = 144;
														rectangle.Y = 270;
														break;
													case 1:
														rectangle.X = 162;
														rectangle.Y = 270;
														break;
													default:
														rectangle.X = 180;
														rectangle.Y = 270;
														break;
												}
											}
											else if (down != num58 && down != num && up == num && left != num58 && left != num && right == num && upRight != num58 && upRight != num) {
												switch (num55) {
													case 0:
														rectangle.X = 90;
														rectangle.Y = 288;
														break;
													case 1:
														rectangle.X = 108;
														rectangle.Y = 288;
														break;
													default:
														rectangle.X = 126;
														rectangle.Y = 288;
														break;
												}
											}
											else if (down != num58 && down != num && up == num && left == num && right != num58 && right != num && upLeft != num58 && upLeft != num) {
												switch (num55) {
													case 0:
														rectangle.X = 144;
														rectangle.Y = 288;
														break;
													case 1:
														rectangle.X = 162;
														rectangle.Y = 288;
														break;
													default:
														rectangle.X = 180;
														rectangle.Y = 288;
														break;
												}
											}
											else if (up != num && up != num58 && down == num && left == num && right == num && downLeft != num && downLeft != num58 && downRight != num && downRight != num58) {
												switch (num55) {
													case 0:
														rectangle.X = 144;
														rectangle.Y = 216;
														break;
													case 1:
														rectangle.X = 198;
														rectangle.Y = 216;
														break;
													default:
														rectangle.X = 252;
														rectangle.Y = 216;
														break;
												}
											}
											else if (down != num && down != num58 && up == num && left == num && right == num && upLeft != num && upLeft != num58 && upRight != num && upRight != num58) {
												switch (num55) {
													case 0:
														rectangle.X = 144;
														rectangle.Y = 252;
														break;
													case 1:
														rectangle.X = 198;
														rectangle.Y = 252;
														break;
													default:
														rectangle.X = 252;
														rectangle.Y = 252;
														break;
												}
											}
											else if (left != num && left != num58 && down == num && up == num && right == num && upRight != num && upRight != num58 && downRight != num && downRight != num58) {
												switch (num55) {
													case 0:
														rectangle.X = 126;
														rectangle.Y = 234;
														break;
													case 1:
														rectangle.X = 180;
														rectangle.Y = 234;
														break;
													default:
														rectangle.X = 234;
														rectangle.Y = 234;
														break;
												}
											}
											else if (right != num && right != num58 && down == num && up == num && left == num && upLeft != num && upLeft != num58 && downLeft != num && downLeft != num58) {
												switch (num55) {
													case 0:
														rectangle.X = 162;
														rectangle.Y = 234;
														break;
													case 1:
														rectangle.X = 216;
														rectangle.Y = 234;
														break;
													default:
														rectangle.X = 270;
														rectangle.Y = 234;
														break;
												}
											}
											else if (up != num58 && up != num && (down == num58 || down == num) && left == num58 && right == num58) {
												switch (num55) {
													case 0:
														rectangle.X = 36;
														rectangle.Y = 270;
														break;
													case 1:
														rectangle.X = 54;
														rectangle.Y = 270;
														break;
													default:
														rectangle.X = 72;
														rectangle.Y = 270;
														break;
												}
											}
											else if (down != num58 && down != num && (up == num58 || up == num) && left == num58 && right == num58) {
												switch (num55) {
													case 0:
														rectangle.X = 36;
														rectangle.Y = 288;
														break;
													case 1:
														rectangle.X = 54;
														rectangle.Y = 288;
														break;
													default:
														rectangle.X = 72;
														rectangle.Y = 288;
														break;
												}
											}
											else if (left != num58 && left != num && (right == num58 || right == num) && up == num58 && down == num58) {
												switch (num55) {
													case 0:
														rectangle.X = 0;
														rectangle.Y = 270;
														break;
													case 1:
														rectangle.X = 0;
														rectangle.Y = 288;
														break;
													default:
														rectangle.X = 0;
														rectangle.Y = 306;
														break;
												}
											}
											else if (right != num58 && right != num && (left == num58 || left == num) && up == num58 && down == num58) {
												switch (num55) {
													case 0:
														rectangle.X = 18;
														rectangle.Y = 270;
														break;
													case 1:
														rectangle.X = 18;
														rectangle.Y = 288;
														break;
													default:
														rectangle.X = 18;
														rectangle.Y = 306;
														break;
												}
											}
											else if (up == num && down == num58 && left == num58 && right == num58) {
												switch (num55) {
													case 0:
														rectangle.X = 198;
														rectangle.Y = 288;
														break;
													case 1:
														rectangle.X = 216;
														rectangle.Y = 288;
														break;
													default:
														rectangle.X = 234;
														rectangle.Y = 288;
														break;
												}
											}
											else if (up == num58 && down == num && left == num58 && right == num58) {
												switch (num55) {
													case 0:
														rectangle.X = 198;
														rectangle.Y = 270;
														break;
													case 1:
														rectangle.X = 216;
														rectangle.Y = 270;
														break;
													default:
														rectangle.X = 234;
														rectangle.Y = 270;
														break;
												}
											}
											else if (up == num58 && down == num58 && left == num && right == num58) {
												switch (num55) {
													case 0:
														rectangle.X = 198;
														rectangle.Y = 306;
														break;
													case 1:
														rectangle.X = 216;
														rectangle.Y = 306;
														break;
													default:
														rectangle.X = 234;
														rectangle.Y = 306;
														break;
												}
											}
											else if (up == num58 && down == num58 && left == num58 && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 144;
														rectangle.Y = 306;
														break;
													case 1:
														rectangle.X = 162;
														rectangle.Y = 306;
														break;
													default:
														rectangle.X = 180;
														rectangle.Y = 306;
														break;
												}
											}

											if (up != num && up != num58 && down == num && left == num && right == num) {
												if ((downLeft == num58 || downLeft == num) && downRight != num58 && downRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 0;
															rectangle.Y = 324;
															break;
														case 1:
															rectangle.X = 18;
															rectangle.Y = 324;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 324;
															break;
													}
												}
												else if ((downRight == num58 || downRight == num) && downLeft != num58 && downLeft != num) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 324;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 324;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 324;
															break;
													}
												}
											}
											else if (down != num && down != num58 && up == num && left == num && right == num) {
												if ((upLeft == num58 || upLeft == num) && upRight != num58 && upRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 0;
															rectangle.Y = 342;
															break;
														case 1:
															rectangle.X = 18;
															rectangle.Y = 342;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 342;
															break;
													}
												}
												else if ((upRight == num58 || upRight == num) && upLeft != num58 && upLeft != num) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 342;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 342;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 342;
															break;
													}
												}
											}
											else if (left != num && left != num58 && up == num && down == num && right == num) {
												if ((upRight == num58 || upRight == num) && downRight != num58 && downRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 360;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 360;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 360;
															break;
													}
												}
												else if ((downRight == num58 || downRight == num) && upRight != num58 && upRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 0;
															rectangle.Y = 360;
															break;
														case 1:
															rectangle.X = 18;
															rectangle.Y = 360;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 360;
															break;
													}
												}
											}
											else if (right != num && right != num58 && up == num && down == num && left == num) {
												if ((upLeft == num58 || upLeft == num) && downLeft != num58 && downLeft != num) {
													switch (num55) {
														case 0:
															rectangle.X = 0;
															rectangle.Y = 378;
															break;
														case 1:
															rectangle.X = 18;
															rectangle.Y = 378;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 378;
															break;
													}
												}
												else if ((downLeft == num58 || downLeft == num) && upLeft != num58 && upLeft != num) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 378;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 378;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 378;
															break;
													}
												}
											}

											if ((up == num || up == num58) && (down == num || down == num58) && (left == num || left == num58) && (right == num || right == num58) && upLeft != -1 && upRight != -1 && downLeft != -1 && downRight != -1) {
												if ((i + j) % 2 == 1) {
													switch (num55) {
														case 0:
															rectangle.X = 108;
															rectangle.Y = 198;
															break;
														case 1:
															rectangle.X = 126;
															rectangle.Y = 198;
															break;
														default:
															rectangle.X = 144;
															rectangle.Y = 198;
															break;
													}
												}
												else {
													switch (num55) {
														case 0:
															rectangle.X = 18;
															rectangle.Y = 18;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 18;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 18;
															break;
													}
												}
											}

											TileMergeAttempt(-2, num58, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										}

										TileMergeAttempt(num, Main.tileMerge[num], ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										if (rectangle.X == -1 && rectangle.Y == -1 && (Main.tileMergeDirt[num] || (num > -1 && TileID.Sets.ChecksForMerge[num]))) {
											if (!flag8) {
												flag8 = true;
												TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											}

											if (up > -1 && up != num)
												up = -1;

											if (down > -1 && down != num)
												down = -1;

											if (left > -1 && left != num)
												left = -1;

											if (right > -1 && right != num)
												right = -1;

											if (up != -1 && down != -1 && left != -1 && right != -1) {
												if (up == -2 && down == num && left == num && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 144;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 162;
															rectangle.Y = 108;
															break;
														default:
															rectangle.X = 180;
															rectangle.Y = 108;
															break;
													}

													mergeUp = true;
												}
												else if (up == num && down == -2 && left == num && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 144;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 162;
															rectangle.Y = 90;
															break;
														default:
															rectangle.X = 180;
															rectangle.Y = 90;
															break;
													}

													mergeDown = true;
												}
												else if (up == num && down == num && left == -2 && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 162;
															rectangle.Y = 126;
															break;
														case 1:
															rectangle.X = 162;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 162;
															rectangle.Y = 162;
															break;
													}

													mergeLeft = true;
												}
												else if (up == num && down == num && left == num && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 144;
															rectangle.Y = 126;
															break;
														case 1:
															rectangle.X = 144;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 144;
															rectangle.Y = 162;
															break;
													}

													mergeRight = true;
												}
												else if (up == -2 && down == num && left == -2 && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 162;
															break;
													}

													mergeUp = true;
													mergeLeft = true;
												}
												else if (up == -2 && down == num && left == num && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 126;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 162;
															break;
													}

													mergeUp = true;
													mergeRight = true;
												}
												else if (up == num && down == -2 && left == -2 && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 36;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 180;
															break;
													}

													mergeDown = true;
													mergeLeft = true;
												}
												else if (up == num && down == -2 && left == num && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 108;
															break;
														case 1:
															rectangle.X = 54;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 180;
															break;
													}

													mergeDown = true;
													mergeRight = true;
												}
												else if (up == num && down == num && left == -2 && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 180;
															rectangle.Y = 126;
															break;
														case 1:
															rectangle.X = 180;
															rectangle.Y = 144;
															break;
														default:
															rectangle.X = 180;
															rectangle.Y = 162;
															break;
													}

													mergeLeft = true;
													mergeRight = true;
												}
												else if (up == -2 && down == -2 && left == num && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 144;
															rectangle.Y = 180;
															break;
														case 1:
															rectangle.X = 162;
															rectangle.Y = 180;
															break;
														default:
															rectangle.X = 180;
															rectangle.Y = 180;
															break;
													}

													mergeUp = true;
													mergeDown = true;
												}
												else if (up == -2 && down == num && left == -2 && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 198;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 198;
															rectangle.Y = 108;
															break;
														default:
															rectangle.X = 198;
															rectangle.Y = 126;
															break;
													}

													mergeUp = true;
													mergeLeft = true;
													mergeRight = true;
												}
												else if (up == num && down == -2 && left == -2 && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 198;
															rectangle.Y = 144;
															break;
														case 1:
															rectangle.X = 198;
															rectangle.Y = 162;
															break;
														default:
															rectangle.X = 198;
															rectangle.Y = 180;
															break;
													}

													mergeDown = true;
													mergeLeft = true;
													mergeRight = true;
												}
												else if (up == -2 && down == -2 && left == num && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 216;
															rectangle.Y = 144;
															break;
														case 1:
															rectangle.X = 216;
															rectangle.Y = 162;
															break;
														default:
															rectangle.X = 216;
															rectangle.Y = 180;
															break;
													}

													mergeUp = true;
													mergeDown = true;
													mergeRight = true;
												}
												else if (up == -2 && down == -2 && left == -2 && right == num) {
													switch (num55) {
														case 0:
															rectangle.X = 216;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 216;
															rectangle.Y = 108;
															break;
														default:
															rectangle.X = 216;
															rectangle.Y = 126;
															break;
													}

													mergeUp = true;
													mergeDown = true;
													mergeLeft = true;
												}
												else if (up == -2 && down == -2 && left == -2 && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 108;
															rectangle.Y = 198;
															break;
														case 1:
															rectangle.X = 126;
															rectangle.Y = 198;
															break;
														default:
															rectangle.X = 144;
															rectangle.Y = 198;
															break;
													}

													mergeUp = true;
													mergeDown = true;
													mergeLeft = true;
													mergeRight = true;
												}
												else if (up == num && down == num && left == num && right == num) {
													if (upLeft == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 18;
																rectangle.Y = 108;
																break;
															case 1:
																rectangle.X = 18;
																rectangle.Y = 144;
																break;
															default:
																rectangle.X = 18;
																rectangle.Y = 180;
																break;
														}
													}

													if (upRight == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 0;
																rectangle.Y = 108;
																break;
															case 1:
																rectangle.X = 0;
																rectangle.Y = 144;
																break;
															default:
																rectangle.X = 0;
																rectangle.Y = 180;
																break;
														}
													}

													if (downLeft == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 18;
																rectangle.Y = 90;
																break;
															case 1:
																rectangle.X = 18;
																rectangle.Y = 126;
																break;
															default:
																rectangle.X = 18;
																rectangle.Y = 162;
																break;
														}
													}

													if (downRight == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 0;
																rectangle.Y = 90;
																break;
															case 1:
																rectangle.X = 0;
																rectangle.Y = 126;
																break;
															default:
																rectangle.X = 0;
																rectangle.Y = 162;
																break;
														}
													}
												}
											}
											else {
												if (!TileID.Sets.Grass[num] && !TileID.Sets.GrassSpecial[num]) {
													if (up == -1 && down == -2 && left == num && right == num) {
														switch (num55) {
															case 0:
																rectangle.X = 234;
																rectangle.Y = 0;
																break;
															case 1:
																rectangle.X = 252;
																rectangle.Y = 0;
																break;
															default:
																rectangle.X = 270;
																rectangle.Y = 0;
																break;
														}

														mergeDown = true;
													}
													else if (up == -2 && down == -1 && left == num && right == num) {
														switch (num55) {
															case 0:
																rectangle.X = 234;
																rectangle.Y = 18;
																break;
															case 1:
																rectangle.X = 252;
																rectangle.Y = 18;
																break;
															default:
																rectangle.X = 270;
																rectangle.Y = 18;
																break;
														}

														mergeUp = true;
													}
													else if (up == num && down == num && left == -1 && right == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 234;
																rectangle.Y = 36;
																break;
															case 1:
																rectangle.X = 252;
																rectangle.Y = 36;
																break;
															default:
																rectangle.X = 270;
																rectangle.Y = 36;
																break;
														}

														mergeRight = true;
													}
													else if (up == num && down == num && left == -2 && right == -1) {
														switch (num55) {
															case 0:
																rectangle.X = 234;
																rectangle.Y = 54;
																break;
															case 1:
																rectangle.X = 252;
																rectangle.Y = 54;
																break;
															default:
																rectangle.X = 270;
																rectangle.Y = 54;
																break;
														}

														mergeLeft = true;
													}
												}

												if (up != -1 && down != -1 && left == -1 && right == num) {
													if (up == -2 && down == num) {
														switch (num55) {
															case 0:
																rectangle.X = 72;
																rectangle.Y = 144;
																break;
															case 1:
																rectangle.X = 72;
																rectangle.Y = 162;
																break;
															default:
																rectangle.X = 72;
																rectangle.Y = 180;
																break;
														}

														mergeUp = true;
													}
													else if (down == -2 && up == num) {
														switch (num55) {
															case 0:
																rectangle.X = 72;
																rectangle.Y = 90;
																break;
															case 1:
																rectangle.X = 72;
																rectangle.Y = 108;
																break;
															default:
																rectangle.X = 72;
																rectangle.Y = 126;
																break;
														}

														mergeDown = true;
													}
												}
												else if (up != -1 && down != -1 && left == num && right == -1) {
													if (up == -2 && down == num) {
														switch (num55) {
															case 0:
																rectangle.X = 90;
																rectangle.Y = 144;
																break;
															case 1:
																rectangle.X = 90;
																rectangle.Y = 162;
																break;
															default:
																rectangle.X = 90;
																rectangle.Y = 180;
																break;
														}

														mergeUp = true;
													}
													else if (down == -2 && up == num) {
														switch (num55) {
															case 0:
																rectangle.X = 90;
																rectangle.Y = 90;
																break;
															case 1:
																rectangle.X = 90;
																rectangle.Y = 108;
																break;
															default:
																rectangle.X = 90;
																rectangle.Y = 126;
																break;
														}

														mergeDown = true;
													}
												}
												else if (up == -1 && down == num && left != -1 && right != -1) {
													if (left == -2 && right == num) {
														switch (num55) {
															case 0:
																rectangle.X = 0;
																rectangle.Y = 198;
																break;
															case 1:
																rectangle.X = 18;
																rectangle.Y = 198;
																break;
															default:
																rectangle.X = 36;
																rectangle.Y = 198;
																break;
														}

														mergeLeft = true;
													}
													else if (right == -2 && left == num) {
														switch (num55) {
															case 0:
																rectangle.X = 54;
																rectangle.Y = 198;
																break;
															case 1:
																rectangle.X = 72;
																rectangle.Y = 198;
																break;
															default:
																rectangle.X = 90;
																rectangle.Y = 198;
																break;
														}

														mergeRight = true;
													}
												}
												else if (up == num && down == -1 && left != -1 && right != -1) {
													if (left == -2 && right == num) {
														switch (num55) {
															case 0:
																rectangle.X = 0;
																rectangle.Y = 216;
																break;
															case 1:
																rectangle.X = 18;
																rectangle.Y = 216;
																break;
															default:
																rectangle.X = 36;
																rectangle.Y = 216;
																break;
														}

														mergeLeft = true;
													}
													else if (right == -2 && left == num) {
														switch (num55) {
															case 0:
																rectangle.X = 54;
																rectangle.Y = 216;
																break;
															case 1:
																rectangle.X = 72;
																rectangle.Y = 216;
																break;
															default:
																rectangle.X = 90;
																rectangle.Y = 216;
																break;
														}

														mergeRight = true;
													}
												}
												else if (up != -1 && down != -1 && left == -1 && right == -1) {
													if (up == -2 && down == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 108;
																rectangle.Y = 216;
																break;
															case 1:
																rectangle.X = 108;
																rectangle.Y = 234;
																break;
															default:
																rectangle.X = 108;
																rectangle.Y = 252;
																break;
														}

														mergeUp = true;
														mergeDown = true;
													}
													else if (up == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 126;
																rectangle.Y = 144;
																break;
															case 1:
																rectangle.X = 126;
																rectangle.Y = 162;
																break;
															default:
																rectangle.X = 126;
																rectangle.Y = 180;
																break;
														}

														mergeUp = true;
													}
													else if (down == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 126;
																rectangle.Y = 90;
																break;
															case 1:
																rectangle.X = 126;
																rectangle.Y = 108;
																break;
															default:
																rectangle.X = 126;
																rectangle.Y = 126;
																break;
														}

														mergeDown = true;
													}
												}
												else if (up == -1 && down == -1 && left != -1 && right != -1) {
													if (left == -2 && right == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 162;
																rectangle.Y = 198;
																break;
															case 1:
																rectangle.X = 180;
																rectangle.Y = 198;
																break;
															default:
																rectangle.X = 198;
																rectangle.Y = 198;
																break;
														}

														mergeLeft = true;
														mergeRight = true;
													}
													else if (left == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 0;
																rectangle.Y = 252;
																break;
															case 1:
																rectangle.X = 18;
																rectangle.Y = 252;
																break;
															default:
																rectangle.X = 36;
																rectangle.Y = 252;
																break;
														}

														mergeLeft = true;
													}
													else if (right == -2) {
														switch (num55) {
															case 0:
																rectangle.X = 54;
																rectangle.Y = 252;
																break;
															case 1:
																rectangle.X = 72;
																rectangle.Y = 252;
																break;
															default:
																rectangle.X = 90;
																rectangle.Y = 252;
																break;
														}

														mergeRight = true;
													}
												}
												else if (up == -2 && down == -1 && left == -1 && right == -1) {
													switch (num55) {
														case 0:
															rectangle.X = 108;
															rectangle.Y = 144;
															break;
														case 1:
															rectangle.X = 108;
															rectangle.Y = 162;
															break;
														default:
															rectangle.X = 108;
															rectangle.Y = 180;
															break;
													}

													mergeUp = true;
												}
												else if (up == -1 && down == -2 && left == -1 && right == -1) {
													switch (num55) {
														case 0:
															rectangle.X = 108;
															rectangle.Y = 90;
															break;
														case 1:
															rectangle.X = 108;
															rectangle.Y = 108;
															break;
														default:
															rectangle.X = 108;
															rectangle.Y = 126;
															break;
													}

													mergeDown = true;
												}
												else if (up == -1 && down == -1 && left == -2 && right == -1) {
													switch (num55) {
														case 0:
															rectangle.X = 0;
															rectangle.Y = 234;
															break;
														case 1:
															rectangle.X = 18;
															rectangle.Y = 234;
															break;
														default:
															rectangle.X = 36;
															rectangle.Y = 234;
															break;
													}

													mergeLeft = true;
												}
												else if (up == -1 && down == -1 && left == -1 && right == -2) {
													switch (num55) {
														case 0:
															rectangle.X = 54;
															rectangle.Y = 234;
															break;
														case 1:
															rectangle.X = 72;
															rectangle.Y = 234;
															break;
														default:
															rectangle.X = 90;
															rectangle.Y = 234;
															break;
													}

													mergeRight = true;
												}
											}
										}

										int num59 = tile.blockType();
										if (TileID.Sets.HasSlopeFrames[num]) {
											if (num59 == 0) {
												bool flag9 = num == up && tile16.topSlope();
												bool flag10 = num == left && tile10.leftSlope();
												bool flag11 = num == right && tile11.rightSlope();
												bool flag12 = num == down && tile17.bottomSlope();
												int num60 = 0;
												int num61 = 0;
												if (flag9.ToInt() + flag10.ToInt() + flag11.ToInt() + flag12.ToInt() > 2) {
													int num62 = (tile16.slope() == 1).ToInt() + (tile11.slope() == 1).ToInt() + (tile17.slope() == 4).ToInt() + (tile10.slope() == 4).ToInt();
													int num63 = (tile16.slope() == 2).ToInt() + (tile11.slope() == 3).ToInt() + (tile17.slope() == 3).ToInt() + (tile10.slope() == 2).ToInt();
													if (num62 == num63) {
														num60 = 2;
														num61 = 4;
													}
													else if (num62 > num63) {
														bool num64 = num == upLeft && tile14.slope() == 0;
														bool flag13 = num == downRight && tile13.slope() == 0;
														if (num64 && flag13) {
															num61 = 4;
														}
														else if (flag13) {
															num60 = 6;
														}
														else {
															num60 = 7;
															num61 = 1;
														}
													}
													else {
														bool num65 = num == upRight && tile15.slope() == 0;
														bool flag14 = num == downLeft && tile12.slope() == 0;
														if (num65 && flag14) {
															num61 = 4;
															num60 = 1;
														}
														else if (flag14) {
															num60 = 7;
														}
														else {
															num60 = 6;
															num61 = 1;
														}
													}

													rectangle.X = (18 + num60) * 18;
													rectangle.Y = num61 * 18;
												}
												else {
													if (flag9 && flag10 && num == down && num == right) {
														num61 = 2;
													}
													else if (flag9 && flag11 && num == down && num == left) {
														num60 = 1;
														num61 = 2;
													}
													else if (flag11 && flag12 && num == up && num == left) {
														num60 = 1;
														num61 = 3;
													}
													else if (flag12 && flag10 && num == up && num == right) {
														num61 = 3;
													}

													if (num60 != 0 || num61 != 0) {
														rectangle.X = (18 + num60) * 18;
														rectangle.Y = num61 * 18;
													}
												}
											}

											if (num59 >= 2 && (rectangle.X < 0 || rectangle.Y < 0)) {
												int num66 = -1;
												int num67 = -1;
												int num68 = -1;
												int num69 = 0;
												int num70 = 0;
												switch (num59) {
													case 2:
														num66 = left;
														num67 = down;
														num68 = downLeft;
														num69++;
														break;
													case 3:
														num66 = right;
														num67 = down;
														num68 = downRight;
														break;
													case 4:
														num66 = left;
														num67 = up;
														num68 = upLeft;
														num69++;
														num70++;
														break;
													case 5:
														num66 = right;
														num67 = up;
														num68 = upRight;
														num70++;
														break;
												}

												if (num != num66 || num != num67 || num != num68) {
													if (num == num66 && num == num67) {
														num69 += 2;
													}
													else if (num == num66) {
														num69 += 4;
													}
													else if (num == num67) {
														num69 += 4;
														num70 += 2;
													}
													else {
														num69 += 2;
														num70 += 2;
													}
												}

												rectangle.X = (18 + num69) * 18;
												rectangle.Y = num70 * 18;
											}
										}

										if (rectangle.X < 0 || rectangle.Y < 0) {
											if (!flag8) {
												flag8 = true;
												TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											}

											if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num])
												TileMergeAttempt(num, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);

											if (up == num && down == num && left == num && right == num) {
												if (upLeft != num && upRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 108;
															rectangle.Y = 18;
															break;
														case 1:
															rectangle.X = 126;
															rectangle.Y = 18;
															break;
														default:
															rectangle.X = 144;
															rectangle.Y = 18;
															break;
													}
												}
												else if (downLeft != num && downRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 108;
															rectangle.Y = 36;
															break;
														case 1:
															rectangle.X = 126;
															rectangle.Y = 36;
															break;
														default:
															rectangle.X = 144;
															rectangle.Y = 36;
															break;
													}
												}
												else if (upLeft != num && downLeft != num) {
													switch (num55) {
														case 0:
															rectangle.X = 180;
															rectangle.Y = 0;
															break;
														case 1:
															rectangle.X = 180;
															rectangle.Y = 18;
															break;
														default:
															rectangle.X = 180;
															rectangle.Y = 36;
															break;
													}
												}
												else if (upRight != num && downRight != num) {
													switch (num55) {
														case 0:
															rectangle.X = 198;
															rectangle.Y = 0;
															break;
														case 1:
															rectangle.X = 198;
															rectangle.Y = 18;
															break;
														default:
															rectangle.X = 198;
															rectangle.Y = 36;
															break;
													}
												}
												else {
													switch (num55) {
														case 0:
															rectangle.X = 18;
															rectangle.Y = 18;
															break;
														case 1:
															rectangle.X = 36;
															rectangle.Y = 18;
															break;
														default:
															rectangle.X = 54;
															rectangle.Y = 18;
															break;
													}
												}
											}
											else if (up != num && down == num && left == num && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 18;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 36;
														rectangle.Y = 0;
														break;
													default:
														rectangle.X = 54;
														rectangle.Y = 0;
														break;
												}
											}
											else if (up == num && down != num && left == num && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 18;
														rectangle.Y = 36;
														break;
													case 1:
														rectangle.X = 36;
														rectangle.Y = 36;
														break;
													default:
														rectangle.X = 54;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up == num && down == num && left != num && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 0;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 0;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 0;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up == num && down == num && left == num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 72;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 72;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 72;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up != num && down == num && left != num && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 0;
														rectangle.Y = 54;
														break;
													case 1:
														rectangle.X = 36;
														rectangle.Y = 54;
														break;
													default:
														rectangle.X = 72;
														rectangle.Y = 54;
														break;
												}
											}
											else if (up != num && down == num && left == num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 18;
														rectangle.Y = 54;
														break;
													case 1:
														rectangle.X = 54;
														rectangle.Y = 54;
														break;
													default:
														rectangle.X = 90;
														rectangle.Y = 54;
														break;
												}
											}
											else if (up == num && down != num && left != num && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 0;
														rectangle.Y = 72;
														break;
													case 1:
														rectangle.X = 36;
														rectangle.Y = 72;
														break;
													default:
														rectangle.X = 72;
														rectangle.Y = 72;
														break;
												}
											}
											else if (up == num && down != num && left == num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 18;
														rectangle.Y = 72;
														break;
													case 1:
														rectangle.X = 54;
														rectangle.Y = 72;
														break;
													default:
														rectangle.X = 90;
														rectangle.Y = 72;
														break;
												}
											}
											else if (up == num && down == num && left != num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 90;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 90;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 90;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up != num && down != num && left == num && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 108;
														rectangle.Y = 72;
														break;
													case 1:
														rectangle.X = 126;
														rectangle.Y = 72;
														break;
													default:
														rectangle.X = 144;
														rectangle.Y = 72;
														break;
												}
											}
											else if (up != num && down == num && left != num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 108;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 126;
														rectangle.Y = 0;
														break;
													default:
														rectangle.X = 144;
														rectangle.Y = 0;
														break;
												}
											}
											else if (up == num && down != num && left != num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 108;
														rectangle.Y = 54;
														break;
													case 1:
														rectangle.X = 126;
														rectangle.Y = 54;
														break;
													default:
														rectangle.X = 144;
														rectangle.Y = 54;
														break;
												}
											}
											else if (up != num && down != num && left != num && right == num) {
												switch (num55) {
													case 0:
														rectangle.X = 162;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 162;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 162;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up != num && down != num && left == num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 216;
														rectangle.Y = 0;
														break;
													case 1:
														rectangle.X = 216;
														rectangle.Y = 18;
														break;
													default:
														rectangle.X = 216;
														rectangle.Y = 36;
														break;
												}
											}
											else if (up != num && down != num && left != num && right != num) {
												switch (num55) {
													case 0:
														rectangle.X = 162;
														rectangle.Y = 54;
														break;
													case 1:
														rectangle.X = 180;
														rectangle.Y = 54;
														break;
													default:
														rectangle.X = 198;
														rectangle.Y = 54;
														break;
												}
											}
										}

										if (rectangle.X <= -1 || rectangle.Y <= -1) {
											if (num55 <= 0) {
												rectangle.X = 18;
												rectangle.Y = 18;
											}
											else if (num55 == 1) {
												rectangle.X = 36;
												rectangle.Y = 18;
											}

											if (num55 >= 2) {
												rectangle.X = 54;
												rectangle.Y = 18;
											}
										}

										if (Main.tileLargeFrames[num] == 1 && num55 == 3)
											rectangle.Y += 90;

										tile.frameX = (short)rectangle.X;
										tile.frameY = (short)rectangle.Y;
										if (num == 52 || num == 62 || num == 115 || num == 205) {
											up = ((tile16 == null) ? num : ((!tile16.active()) ? (-1) : ((!tile16.bottomSlope()) ? tile16.type : (-1))));
											if ((num == 52 || num == 205) && (up == 109 || up == 115)) {
												tile.type = 115;
												SquareTileFrame(i, j);
												return;
											}

											if ((num == 115 || num == 205) && (up == 2 || up == 52)) {
												tile.type = 52;
												SquareTileFrame(i, j);
												return;
											}

											if ((num == 52 || num == 115) && (up == 199 || up == 205)) {
												tile.type = 205;
												SquareTileFrame(i, j);
												return;
											}

											if (up != num) {
												bool flag15 = false;
												if (up == -1)
													flag15 = true;

												if (num == 52 && up != 2 && up != 192)
													flag15 = true;

												if (num == 62 && up != 60)
													flag15 = true;

												if (num == 115 && up != 109)
													flag15 = true;

												if (num == 205 && up != 199)
													flag15 = true;

												if (flag15)
													KillTile(i, j);
											}
										}

										if (!noTileActions && tile.active() && (num == 53 || num == 112 || num == 116 || num == 123 || num == 234 || num == 224 || num == 330 || num == 331 || num == 332 || num == 333)) {
											if (Main.netMode == 0) {
												if (tile17 != null && !tile17.active()) {
													bool flag16 = true;
													if (tile16.active() && (TileID.Sets.BasicChest[tile16.type] || TileID.Sets.BasicChestFake[tile16.type] || tile16.type == 323 || TileLoader.IsDresser(tile16.type)))
														flag16 = false;

													if (flag16) {
														int damage = 10;
														int type;
														switch (num) {
															case 112:
																type = 56;
																break;
															case 59:
																type = 39;
																break;
															case 116:
																type = 67;
																break;
															case 123:
																type = 71;
																break;
															case 224:
																type = 179;
																break;
															case 234:
																type = 241;
																break;
															case 330:
																type = 411;
																damage = 0;
																break;
															case 331:
																type = 412;
																damage = 0;
																break;
															case 332:
																type = 413;
																damage = 0;
																break;
															case 333:
																type = 414;
																damage = 0;
																break;
															default:
																type = 31;
																break;
														}

														tile.ClearTile();
														int num71 = Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
														Main.projectile[num71].ai[0] = 1f;
														SquareTileFrame(i, j);
													}
												}
											}
											else if (Main.netMode == 2 && tile17 != null && !tile17.active()) {
												bool flag17 = true;
												if (tile16.active() && (TileID.Sets.BasicChest[tile16.type] || TileID.Sets.BasicChestFake[tile16.type] || tile16.type == 323 || TileLoader.IsDresser(tile16.type)))
													flag17 = false;

												if (flag17) {
													int damage2 = 10;
													int num72;
													switch (num) {
														case 112:
															num72 = 56;
															break;
														case 116:
															num72 = 67;
															break;
														case 59:
															num72 = 39;
															break;
														case 123:
															num72 = 71;
															break;
														case 224:
															num72 = 179;
															break;
														case 234:
															num72 = 241;
															break;
														case 330:
															num72 = 411;
															damage2 = 0;
															break;
														case 331:
															num72 = 412;
															damage2 = 0;
															break;
														case 332:
															num72 = 413;
															damage2 = 0;
															break;
														case 333:
															num72 = 414;
															damage2 = 0;
															break;
														default:
															num72 = 31;
															break;
													}

													tile.active(active: false);
													bool flag18 = false;
													for (int m = 0; m < 1000; m++) {
														if (Main.projectile[m].active && Main.projectile[m].owner == Main.myPlayer && Main.projectile[m].type == num72 && Math.Abs(Main.projectile[m].timeLeft - 3600) < 60 && Main.projectile[m].Distance(new Vector2(i * 16 + 8, j * 16 + 10)) < 4f) {
															flag18 = true;
															break;
														}
													}

													if (!flag18) {
														int num73 = Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 2.5f, num72, damage2, 0f, Main.myPlayer);
														Main.projectile[num73].velocity.Y = 0.5f;
														Main.projectile[num73].position.Y += 2f;
														Main.projectile[num73].netUpdate = true;
													}

													NetMessage.SendTileSquare(-1, i, j, 1);
													SquareTileFrame(i, j);
												}
											}
										}

										if (rectangle.X != frameX && rectangle.Y != frameY && frameX >= 0 && frameY >= 0) {
											tileReframeCount++;
#if DEBUG
											if (tileReframeCount < 20) {
#else
											if (tileReframeCount < 55) {
#endif
												bool num74 = mergeUp;
												bool flag19 = mergeDown;
												bool flag20 = mergeLeft;
												bool flag21 = mergeRight;
												TileFrame(i - 1, j);
												TileFrame(i + 1, j);
												TileFrame(i, j - 1);
												TileFrame(i, j + 1);
												mergeUp = num74;
												mergeDown = flag19;
												mergeLeft = flag20;
												mergeRight = flag21;
											}

											tileReframeCount--;
										}

										goto end_IL_0002;
									}
							}
						}

						Framing.SelfFrame8Way(i, j, tile, resetFrame);
						return;
					}
				}

			end_IL_0002:;
			}
			catch {
			}

			if (i > 0 && j > 0)
				UpdateMapTile(i, j, addToList);
		}

		public static void TriggerLunarApocalypse() {
			List<int> list = new List<int> {
				517,
				422,
				507,
				493
			};

			int[] array = new int[4];
			for (int i = 0; i < 4; i++) {
				array[i] = list[Main.rand.Next(list.Count)];
				list.Remove(array[i]);
			}

			int num = Main.maxTilesX / 5;
			int num2 = (int)Main.worldSurface;
			for (int j = 0; j < 4; j++) {
				int num3 = num * (1 + j);
				bool flag = false;
				for (int k = 0; k < 30; k++) {
					int num4 = Main.rand.Next(-100, 101);
					for (int num5 = num2; num5 > 100; num5--) {
						if (!Collision.SolidTiles(num3 + num4 - 10, num3 + num4 + 10, num5 - 20, num5 + 15) && !PlayerLOS(num3 + num4 - 10, num5) && !PlayerLOS(num3 + num4 + 10, num5) && !PlayerLOS(num3 + num4 - 10, num5 - 20) && !PlayerLOS(num3 + num4 + 10, num5 - 20)) {
							int num6 = NPC.NewNPC((num3 + num4) * 16, num5 * 16, array[j]);
							if (Main.netMode == 2 && num6 < 200)
								NetMessage.SendData(23, -1, -1, null, num6);

							flag = true;
							break;
						}
					}

					if (flag)
						break;
				}

				if (!flag)
					NPC.NewNPC(num3 * 16, (num2 - 40) * 16, array[j]);
			}

			NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveSolar = (NPC.TowerActiveStardust = true)));
			NPC.LunarApocalypseIsUp = true;
			NPC.ShieldStrengthTowerSolar = (NPC.ShieldStrengthTowerVortex = (NPC.ShieldStrengthTowerNebula = (NPC.ShieldStrengthTowerStardust = NPC.ShieldStrengthTowerMax)));
			NetMessage.SendData(101);
			MessageLunarApocalypse();
		}

		public static void UpdateLunarApocalypse() {
			if (!NPC.LunarApocalypseIsUp)
				return;

			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			for (int i = 0; i < 200; i++) {
				if (Main.npc[i].active) {
					switch (Main.npc[i].type) {
						case 398:
							flag = true;
							break;
						case 517:
							flag2 = true;
							break;
						case 422:
							flag3 = true;
							break;
						case 507:
							flag4 = true;
							break;
						case 493:
							flag5 = true;
							break;
					}
				}
			}

			if (!flag2)
				NPC.TowerActiveSolar = false;

			if (!flag3)
				NPC.TowerActiveVortex = false;

			if (!flag4)
				NPC.TowerActiveNebula = false;

			if (!flag5)
				NPC.TowerActiveStardust = false;

			if (!NPC.TowerActiveSolar && !NPC.TowerActiveVortex && !NPC.TowerActiveNebula && !NPC.TowerActiveStardust && !flag)
				StartImpendingDoom();
		}

		public static void StartImpendingDoom() {
			NPC.LunarApocalypseIsUp = false;
			NPC.MoonLordCountdown = 3600;
			NetMessage.SendData(103, -1, -1, null, NPC.MoonLordCountdown);
			BroadcastText(NetworkText.FromKey(Lang.misc[52].Key), 50, 255, 130);
			if (Main.netMode != 1)
				GetRidOfCultists();
		}

		public static void GetRidOfCultists() {
			for (int i = 0; i < 200; i++) {
				if (Main.npc[i].active && (Main.npc[i].type == 437 || Main.npc[i].type == 438 || Main.npc[i].type == 379)) {
					Main.npc[i].active = false;
					if (Main.netMode != 1)
						NetMessage.SendData(23, -1, -1, null, i);
				}
			}
		}

		public static void MessageLunarApocalypse() {
			if (NPC.LunarApocalypseIsUp) {
				int num = 0;
				if (!NPC.TowerActiveSolar)
					num++;

				if (!NPC.TowerActiveVortex)
					num++;

				if (!NPC.TowerActiveNebula)
					num++;

				if (!NPC.TowerActiveStardust)
					num++;

				BroadcastText(NetworkText.FromKey(Lang.misc[43 + num].Key), 175, 75, 255);
			}
		}

		public static void BroadcastText(NetworkText text, Vector4 color) {
			BroadcastText(text, new Color(color));
		}

		public static void BroadcastText(NetworkText text, Vector3 color) {
			BroadcastText(text, new Color(color));
		}

		public static void BroadcastText(NetworkText text, int r, int g, int b) {
			BroadcastText(text, new Color(r, g, b));
		}

		public static void BroadcastText(NetworkText text, byte r, byte g, byte b) {
			BroadcastText(text, new Color(r, g, b));
		}

		public static void BroadcastText(NetworkText text, Color color) {
			if (Main.netMode == 0)
				Main.NewText(text.ToString(), color.R, color.G, color.B);
			else if (Main.netMode == 2)
				NetMessage.BroadcastChatMessage(text, color);
		}

		public static bool CanCutTile(int x, int y, TileCuttingContext context) {
			if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380) {
				if (Main.tile[x, y].type == 254)
					return context == TileCuttingContext.TilePlacement;

				return true;
			}

			return false;
		}
	}
}
